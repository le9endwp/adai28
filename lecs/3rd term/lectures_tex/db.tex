\documentclass[12pt]{article}
\usepackage{config}
\usepackage{subfiles}
\pgfplotsset{compat=1.18}

\begin{document}

\begin{flushright}
    Конспект Шорохова Сергея

    Если нашли опечатку/ошибку - пишите @le9endwp 
\end{flushright}

\tableofcontents
\newpage

\section{Лекция 1. Введение в реляционные базы данных}

\subsection{Понятие базы данных и СУБД}

\begin{defin}{Данные}
    Данные -- факты, текст, графики, картинки, звуки, аналоговые или цифровые видео-сегменты, представленные в форме, пригодной для хранения,  передачи и обработки
\end{defin}

\begin{nota}{Задачи технологий работы с данными}
    \begin{itemize}
        \item Загрузить 
        \begin{itemize}
            \item Получить
            \item Передать между системами
            \item Собрать в одном месте
        \end{itemize}
        \item Сохранить 
        \begin{itemize}
            \item Обеспечить эффективное безопасное хранение
            \item Предоставить доступ
            \item Обеспечить быстрый поиск
        \end{itemize}
        \item Обработать
        \begin{itemize}
            \item Объединить в одной структуре
            \item Рассчитать показатели
            \item Обработать модель
        \end{itemize}
        \item Принять решение
        \begin{itemize}
            \item Отчеты
            \item Дашборды
            \item Визуализация
            \item Предписание в операционном процессе
        \end{itemize}
    \end{itemize}
\end{nota}

\begin{nota}{Что должны обеспечивать системы обработки данных?}
    \begin{itemize}
        \item Поддержку необходимых требований к данными
        \begin{itemize}
            \item Сохранность и достоверность данных в соответствии со спецификой предметной области
            \item Защиту от искажения, уничтожения данных и несанкционированного доступа
            \item Простоту и легкость использования данных
            \item Требуемую скорость доступа к данным
        \end{itemize}
        \item Независимость прикладных программ от данных 
        \begin{itemize}
            \item Возможность использования одних и тех же данных различными приложениями
            \item Изменение логического представления данных (добавление/удаление новых элементов данных) не должно приводить к изменению прикладных программ обработки
            \item Изменение параметров физической организации данных (характеристик носителя, длины блока, и др.) или методов доступа к ним не должны приводить к изменению прикладных программ
        \end{itemize}
    \end{itemize}
\end{nota}

\begin{defin}{Независимость (от) данных}
    \begin{itemize}
        \item \textbf{Логическая}
        
        Изменение логического представления данных (добавление/удаление новых элементов данных, разделение на несколько логических сегментов, изменение порядка хранения) не должно приводить к изменению прикладных программ обработки
        \item \textbf{Физическая}
        
        Изменение параметров физической организации данных (характеристик носителя, длины блока, и др.) или методов доступа к ним не должны приводить к изменению логической структуры данных или прикладных программ их обработки            
    \end{itemize}
\end{defin}

\begin{nota}{Концепции обработки данных}
    \begin{itemize}
        \item \textbf{Файловая обработка данных}
        
        До середины 60-х годов прошлого века – основная концепция построения программного обеспечения обработки данных

        \item \textbf{Базы данных}
        
        Независимость прикладных программ от данных

        \item \textbf{Объектно-ориентированные базы данных}
        
        Независимость прикладных программ от данных вместе с процедурами их обработки (объектно-ориентированный подход в программировании)
    \end{itemize}
\end{nota}

\begin{Remark}{Файловая обработка данных}
    \begin{itemize}
        \item Совмещение логического и физического представления данных
        \begin{itemize}
            \item Физически данные ИС размещаются в файлах операционной системы
            \item Прикладные программы работают напрямую с файлами
            \item Структура файла зависит от требований конкретной прикладной программы, с ним работающей, и определяется разработчиком приложения
        \end{itemize}
        \item Зависимость программ обработки от организации данных
        \begin{itemize}
            \item Возможная избыточность и противоречивость данных 
            \item Для каждой задачи – свой алгоритм получения данных 
        \end{itemize}
        \item Разграничение доступа и защита данных – на уровне средств ОС
    \end{itemize}

    Она не обеспечивает:
    \begin{itemize}
        \item Поддержание логически согласованного набора файлов
        \item Единого языка манипулирования данными
        \item Восстановление информации после разного рода сбоев
        \item Реально параллельной работы нескольких пользователей
    \end{itemize}
\end{Remark}

\begin{Remark}{Базы данных}
    \begin{itemize}
        \item Разделение логического и физического представления данных
        \begin{itemize}
            \item Физически данные как правило размещаются в файлах операционной системы
            \item Разрабатывается определённая логическая структура данных, с которой «общаются» прикладные программы
            \item Логическая структура данных основана на физической, но не меняется при изменении последней
        \end{itemize}
        \item Независимость программ обработки от организации данных
        \begin{itemize}
            \item Сокращение избыточности и противоречивости данных
            \item Единые языки для получения и изменения данных
            \item Дополнительные средства разграничения доступа и защиты данных, учитывающие их логическую структуру
        \end{itemize}
    \end{itemize}
\end{Remark}

\begin{Remark}{Объектно-ориентированные БД}
    \begin{itemize}
        \item Разделение логического и физического представления данных
        \begin{itemize}
            \item Физические данные как правило размещаются в файлах операционной системы
            \item На логическом уровне данные представляют собой объекты
            \begin{itemize}
                \item Данные $\to$ свойства объекта (статическая часть)
                \item Обработка данных $\to$ методы объекта (динамическая часть)
            \end{itemize}
        \end{itemize}
        \item Независимость прикладных программ от объектов
        \item Концепция повторного использования программного кода
        \begin{itemize}
            \item Разные прикладные программы используют унифицированные методы обработки одних и тех же данных
        \end{itemize}
    \end{itemize}
\end{Remark}

\newpage

\subsection{Базы данных и СУБД}

\begin{defin}{База данных}
    База данных -- логически структурированная совокупность постоянно хранимых в памяти компьютера данных, характеризующих актуальное состояние некоторой предметной области и используемых прикладными программными системами какого-либо предприятия

    База данных (БД) -- совокупность данных, хранимых в соответствии со схемой данных, манипулирование которыми выполняют в соответствии с правилами средств моделирования данных (ГОСТ)
\end{defin}

\begin{nota}{Основные характеристики БД}
    \begin{itemize}
        \item Компьютерная система -- БД хранится и обрабатываемя в вычислительной системе
        \item Содержит структурированную информацию -- данные в БД логически структурированы (систематизированы) с целью обеспечения возможности их эффективного поиска и обработки в вычислительной системе 
        \begin{itemize}
            \item Структурированность БД оценивается не на уровне физического хранения, а на уровне некоторой логической модели данных
        \end{itemize}
        \item Поддерживает определенный набор операций над данными 
        \begin{itemize}
            \item Структурированность определяет семантику и допустимые операции
        \end{itemize}
    \end{itemize}
\end{nota}

\begin{defin}{Система баз данных (банк данных)}
    База данных является составной частью системы баз данных 

    Система базы данных -- компьютеризированная система обработки данных, хранящихся в БД

    Основные функции системы баз данных:

    \begin{itemize}
        \item Добавление новых структур данных (таблиц) в базу данных
        \item Изменение существующих структур данных (таблиц)
        \item Добавление новых элементов данных (записей в таблицы)
        \item Выборка необходимых элементов данных (записей из таблиц)
        \item Обновление элементов данных (записей в таблицах)
        \item Удаление элементов данных (записей из таблиц)
        \item Удаление структур данных (таблиц) из базы данных 
    \end{itemize}
\end{defin}

\begin{defin}{Системы управления базами данных}
    СУБД -- совокупность программных средств, предназначенная для модификации и извлечения из БД необходимых пользователю (прикладной программе) данных, а также для создания БД, поддержания их в работоспособном состоянии, обеспечения безопасности БД и решения других задач администрирования

    \textbf{Цель:} Обеспечивать совместное безопасное использование данных различными приложениями и пользователями

    Основные функции СУБД:

    \begin{itemize}
        \item Обеспечение физической и логической независимости данных
        \item Поддержка связи между логической и физической организацией данных
        \item Предоставление интерфейса доступа к данным пользователям и прикладным программам
        \item Обеспечение целостности и непротиворечивости данных при совместной работе нескольких пользователей
        \item Предоставление механизмов защиты данных
        \item Предоставление механизмов восстановления данных
    \end{itemize}
\end{defin}

\begin{nota}{Обеспечение логической и физической независимости данных}
    СУБД обеспечивает необходимые структуры внешней памяти как для хранения пользовательских данных БД, так и для служебных целей

    СУБД скрывает от пользователей как используется файловая система и как организованы файлы

    Для связи логической и физической структур данных СУБД использует служебную (мета) информация, хранящуюся в словаре данных
\end{nota}

\begin{nota}{Управление буферами оперативной памяти}
    Для увеличения скорости обработки данных используется буферизация данных в оперативной памяти

    СУБД поддерживает собственный набор буферов оперативной памяти с собственным алгоритмом замены буферов
\end{nota}

\begin{nota}{Предоставление интерфейса доступа к данным}
    Для работы с базами данных СУБД предоставляет поддержку специальных языков, называемых языками баз данных

    \begin{itemize}
        \item Язык описания данных (DDL) -- позволяет создавать и изменять структуру объектов базы данных
        \item Язык манипулирования данными (DML) -- позволяет заносить данные в БД, удалять, модифицировать или выбирать существующие данные
    \end{itemize}

    Использование данных языков позволяет пользователям сохранять, извлекать и обновлять данные в БД без необходимости понимания физической реализации системы
\end{nota}

\begin{nota}{Обеспечение целостности}
    Целостность БД -- свойство БД, означающее, что в ней содержится полная, непротиворечивая и адекватно отражающая предметную область информация 

    Целостность данных предполагает:
    
    \begin{itemize}
        \item Отсутствие неточно введенных данных или двух одинаковых записей об одном и том же факте
        \item Защиту от ошибок при обновлении данных в БД
        \item Невозможность удаления (или каскадное удаление) записей, которые связаны с другими записями
        \item Неискажение данных при работе в многопользовательском режиме
        \item Сохранность данных при сбоях техники (восстановление данных)
    \end{itemize}

    СУБД должна обладать инструментами контроля за тем, чтобы данные и их изменения соответствовали заданным правилам 
\end{nota}

\begin{nota}{Управление параллельной работой пользователей}
    Для управления параллельной работой пользователей и поддержки целостности данных в СУБД реализован механизм изоляции транзакций
\end{nota}

\begin{defin}{Транзакция}
    Транзакция -- некоторая неделимая последовательность операций над данными БД, которая отслеживается СУБД от начала и до завершения

    Если по каким-либо причинам (сбои и отказы оборудования, ошибки в программном обеспечении) транзакция остается незавершенной или при выполнении транзакции нарушается целостность данных, то она отменяется
\end{defin}

\begin{defin}{Журнализация}
    СУБД должна иметь возможность восстановить последнее согласованное состояние БД после любого аппаратного или программного сбоя 

    Для восстановления БД нужно располагать некоторой дополнительной информацией, которая должна храниться особо надежно

    Наиболее распространенным методом поддержания такой избыточной информации является ведение журнала изменений БД -- журнала транзакций
\end{defin}

\begin{nota}{Обеспечение безопасности БД}
    СУБД должна иметь механизм, гарантирующий возможность доступа к базе данных только санкционированных пользователей

    Термин безопасность относится к защите БД от преднамеренного или случайного несанкционированного доступа

    Защита данных от несанкционированного доступа может достигаться:

    \begin{itemize}
        \item Созданием ролей и ввдеением системы паролей
        \item Настройкой разрешений на доступ к данным и выполнение операций с данными
        \item Шифрованием соединения с прикладными программами
        \item Шифрованием данных 
    \end{itemize}
\end{nota}

\begin{nota}{Выбор СУБД}
    Выбор СУБД -- важный шаг при создании ИС, влияющий на эффективность, как проектирования, так и функционирования системы

    Учитывая тенденции развития ИС, СУБД должна отвечать следующим требованиям:

    \begin{itemize}
        \item Обеспечивать работу в гетерогенной сетевой среде, включая возможность эффективной работы в Интернете
        \item Легко переноситься с платформы на платформу
        \item Обеспечивать работу с большими объемами разнотипных данных
        \item Быть надежной и эффективной
    \end{itemize}
\end{nota}

\newpage

\subsection{Принципы организации базы данных}

\begin{nota}{Требования к БД и СУБД}
    \begin{itemize}
        \item Высокое быстродействие (малое время отклика на запрос)
        \item Простота обновления данных
        \item Защита данных от преднамеренного или непреднамеренного нарушения секретности, искажения или разрушения
        \item Поддержка целостности данных
        \item Независимость данных -- возможность изменения логической и физической структуры БД без изменения предсталвений пользователей
        \item Совместное использование данных многими пользователями
        \item Стандартизация построения и эксплуатации БД
        \item Адекватность отображения данных соответствующей предметной области 
    \end{itemize}
\end{nota}

\begin{nota}{Принципы организации БД}
    \begin{itemize}
        \item Разделение различных видов данных
        \begin{itemize}
            \item Данные пользовательские (приложений)
            \item Вспомогательные данные (индексы)
            \item Метаданные (словарь данных БД)
            \item Служебная информация
        \end{itemize}
        \item Позволяет повысить безопасность данных и быстродействие работы с ними
        \item Проектирование логической структуры данных 
        
        Выбор модели данных (в зависимости от требований доступа к данным)

        \item Позволяет обеспечить: 
        \begin{itemize}
            \item Логическую и физическую независимость данных 
            \item Адекватность отображения данных соответствующей предметной области 
            \item Удобство работы и гибкость
        \end{itemize}
        \item Определение ограничений данных 
        \begin{itemize}
            \item Уменьшение ошибок ввода/изменения данных 
            \item Зависимость от семантики данных
        \end{itemize}
        \item Позволяет поддержать целостность данных 
    \end{itemize}
\end{nota}

\subsection{Реляционная модель данных}

\begin{defin}{Модель данных}
    Модель данных -- формальное описание представления и обработки данных в системе управления базами данных
\end{defin}

\begin{nota}{Компоненты реляционной модели данных}
    \begin{itemize}
        \item Структурный аспект 
        
        \begin{itemize}
            \item Какие структуры данных рассматриваются реляционной моделью 
            \item Постулируется, что единственной структурой данных, используемой в реляционной модели, являются нормализованные $n$-арные отношения
        \end{itemize}

        \item Аспект целостности 
        
        \begin{itemize}
            \item Ограничения специального вида, которые должны выполняться для любых отношений в любых реляционных базах данных 
            \item Целостность сущностей реального мира 
            \item Ссылочная целостность 
        \end{itemize}

        \item Аспект обработки 
        
        \begin{itemize}
            \item Способы манипулирования реляционными данными
            \item Реляционная алгебра -- базируется на теории множеств
            \item Реляционное исчисление -- базируется на логическом аппарате исчисления предикатов первого порядка 
        \end{itemize}
    \end{itemize}
\end{nota}

\newpage

\subsection{Структурный аспект реляционной модели}

\begin{defin}{Отношение}
    Отношение (relation) -- класс объектов реального мира, каждый из которых должен быть уникально идентифицирован

    \begin{itemize}
        \item Подмножество $R$ декартового произведения множеств элементов доменов: (не обязательно различных)
        \item Или множество кортежей, соответствующих одной схеме отношения 
        \item Мощность отношения -- количество кортежей в отношении
        \item На бытовом уровне -- тело таблицы
    \end{itemize}
\end{defin}

\begin{defin}{Схема отношения}
    \begin{itemize}
        \item Именованное конечное множество пар вида $\{$Имя\_атрибута: Имя\_домена$\}$
        \item Степень или -арность (схемы) отношения -- количество атрибутов
        \item На бытовом уровне -- заголовок таблицы 
    \end{itemize}
\end{defin}

\begin{defin}{Атрибут}
    Атрибут (поле, столбец) -- характеристика объекта, принимающая значения определенного типа данных 

    \begin{itemize}
        \item Подмножество домена (атрибут $A_n$ определен на домене $D_n$, который содержит множество возможных значений атрибута)
        
        $A_1(D_1), A_2(D_2), \ldots A_n(D_n)$

        \item На бытовом уровне -- столбец таблицы 
        \item Имена атрибутов должны быть уникальны в пределах отношения 
    \end{itemize}
\end{defin}

\begin{defin}{Тип данных}
    Тип данных -- реляционная модель данных допускает использование только простых типов 

    \begin{itemize}
        \item Соответствует понятию типа данных в языках программирования 
        \item Реляционная модель данных допускает использование только простых типов (логические, символьные, числовые \dots), т.к. в реляционных операциях не должна учитываться внутренняя структура данных 
    \end{itemize}
\end{defin}

\begin{defin}{Домен}
    Домен -- произвольное логическое выражение (опционально), определяющее набор допустимых значений атрибута 

    \begin{itemize}
        \item Базовый тип данных + произвольное логическое выражение (опционально)
        \item Если вычисление заданного логического выражения для элемента данных заданного типа дает результат "истина"\ , то он является элементом домена
        \item Домены ограничивают сравнения: некорректно, с логической точки зрения, сравнивать значения из различных доменов, даже если они имеют одинаковый тип данных (например, возраст сотрудника и количество его детей)
    \end{itemize}
\end{defin}

\begin{defin}{Кортеж}
    Кортеж (запись, строка) -- набор связанных значений атрибутов, относящихся к одному объекту (сущности)

    \begin{itemize}
        \item Множества пар вида $\{$ Имя\_атрибута: Значение\_атрибута $\}$
        \item На бытовом уровне -- строка таблицы 
        \item Значение атрибута должно быть в пределах заданного домена
        \item Каждый кортеж отношения должен быть уникально идентифицирован
    \end{itemize}
\end{defin}

\begin{defin}{Схема БД}
    Схема БД (в структурном смысле) -- набор именованных схем отношений 
\end{defin}

\begin{defin}{Реляционная база данных}
    Реляционная база данных -- набор отношений, имена которых совпадают с именами схем отношений в схеме БД
\end{defin}

\begin{nota}{Свойства отношений}
    \begin{itemize}
        \item В отношении нет кортежей-дубликатов
        
        Т.к. отношение -- это множество кортежей, а каждое множество (в классической теории множеств) состоит из различных элементов 

        Во многих РСУБД может нарушаться для отношений, являющихся результатами запросов

        \item Кортежи не упорядочены
        
        Множество не упорядочено

        \item Атрибуты не упорядочены 
        
        Каждый атрибут имеет уникальное имя в пределах отношения, поэтому порядок атрибутов не имеет значения 

        \item Значение атрибута должно быть атомарным (неразделяемым на несколько значений)
        
        В современных РСУБД в ячейки таблиц можно поместить что угодно -- массивы, структуры и даже другие таблицы 

        \item Домены ограничивают сравнения
        
        Некорректно, с логической точки зрения, сравнивать значения из различных доменов, даже если они имеют одинаковый тип данных 
    \end{itemize}
\end{nota}

\newpage

\subsection{Аспект целостности реляционной модели}

\begin{defin}{Целостность базы данных}
    Целостность базы данных (database integrity) -- соответствие имеющейся в базе данных информации ее внутренней логике, структуре и всем явно заданным правилам 

    Каждое такое правило, налагающее ограничение на возможное состояние базы данных, называется ограничением целостности (integrity constraint)

    Задача аналитика и проектировщика БД -- возможно более полно выявить все имеющиеся ограничения целостности и задать их в базе данных 

    СУБД может (и должна) контролировать целостность БД
\end{defin}

\begin{nota}{Сущностная целостность}
    Каждый кортеж отношения должен быть уникально идентфиицирован по значениям его атрибутов

    Потенциальный ключ обладает следующими свойствами:

    \begin{itemize}
        \item Свойством уникальности -- в отношении не моежт быть двух различных кортежей с одинаковым значением потенциального ключа
        \item Свойством неизбыточности -- никакое подмножество в потенциальном ключе не обладает свойством уникальности, т.к. если из потенциального ключа убрать любой атрибут, он утратит свойство уникальности
    \end{itemize}

    Отношение может иметь несколько потенциальных ключей:

    \begin{itemize}
        \item Один из потенциальных ключей объявляется первичным -- Primary Key, а остальные -- альтернативными -- Alternate Key
        \item С точки зрения реляционной модели данных, нет оснований выделять таким образом один из потенциальных ключей 
    \end{itemize}
\end{nota}

\begin{nota}{Правила для поддержки сущностной целостности}
    Потенциальный ключ может быть:

    \begin{itemize}
        \item Простым -- состоит из одного атрибута 
        \item Составным -- состоит из нескольких атрибутов 
    \end{itemize}

    Потенциальные ключи фактически являются идентификаторами. Если бы идентификаторы могли содержать NULL значения, невозможно было бы дать ответ "да"\ или "нет"\ на вопрос, совпдаают ли два идентификатора 

    Это определяет следующее правило: значения атрибутов, входящих в состав некоторого потенциального ключа не могут быть NULL (во многих СУБД выполняется только для первичного ключа)
\end{nota}

\begin{defin}{NULL}
    Для того чтобы обойти проблему неполных или неизвестных данных, каждый тип данных в БД может быть дополнен NULL

    NULL -- это не значение, а некий маркер, показывающий, что значение неизвестно 

    В ситуации, когда возможно появление неизвестных или неполных данных, разработчик имеет на выбор два варианта: 

    \begin{itemize}
        \item Ограничиться использованием обычных типов данных и не использовать NULL, а вместо неизвестных данных вводить либо нулевые значения, либо значения специального вида 
        \item Использовать NULL вместо неизвестных данных 
    \end{itemize}

    Наличие NULL приводит к использованию трехзначной логики:

    \begin{itemize}
        \item Три возможных значений выражений: TRUE (T), FALSE (F), UNKNOWN (U)
        \item NULL = NULL $\to$ U (NOT NULL = NULL $\to$ U)
        \item NULL !+ NULL $\to$ U (NOT NULL != NULL $\to$ U)
        \item F OR NULL $\to$ U (T OR NULL $\to$ T)
        \item T AND NULL $\to$ U (F AND NULL $\to$ F)
    \end{itemize}
\end{defin}

\begin{defin}{Внешние ключи}
    Различные объекты предметной области, информация о которых хранится в базе данных, взаимосвязаны друг с другом 

    Для реализации взаимосвязи между родительским и дочерним отношениями в реляционных БД используются внешние ключи -- foreign key (FK)
\end{defin}

\begin{nota}{Требования к FK}
    Подмножество атрибутов FK отношения R будем называть внешним ключом, если 

    \begin{itemize}
        \item Существует отношения S (R и S не обязательно различны) с потенциальным ключом K
        \item Каждое значение FK в отношении R всегда совпадает со значением K для некоторого кортежа из S, либо является NULL
    \end{itemize}
\end{nota}

\begin{Remark}{Замечания относительно FK}
    \begin{itemize}
        \item Отноешние S называется родиетльским отношением, отношение R называется дочерним отношением
        \item FK, также как и потенциальный, может быть простым и Составным
        \item FK должен быть определен на тех же доменах, что и соответствующих потенциальный ключ родительского отношения
        \item FK, как правило, не обладает свойством уникальности (тип связи -- один ко многим)
        \item Для FK не требуется, чтобы он был компонентом некоторого потенциального ключа
        \item NULL для значений атрибутов FK допустимы только в том случае, когда атрибуты FK не входят в состав никакого потенциального ключа 
    \end{itemize}
\end{Remark}

\begin{defin}{Связь}
    Связь -- ассоциирование двух или более сущностей (или копий одной и той же сущности)

    Одно из основным требований к организации БД -- это обеспечение возможности поиска одних сущностей по значениям других, для чего необходимо установить между ними определенные связи 

    Типы связей:

    \begin{itemize}
        \item Связь 1:1. Один экземпляр сущности одного класса связан с одним экземпляром сущности другого класса
        \item Связь 1:M. Один экземпляр сущности одного класса связан со многими экземплярами сущности другого класса 
        \item Связь M:N. Несколько экземпляров сущности одного класса связаны с несколькими экземплярами сущности другого класса
    \end{itemize}
\end{defin}

\begin{nota}{Допустимая кратность связей}
    В реляционных БД допустимыми являются связи типа 1:M и 1:1 (значения внешнего ключа -- уникальны)

    Механизм реализации допустимых взаимосвязей состоит в том, что на дочернее отношение добавляются атрибуты, являющиеся ссылками на ключевые атрибуты родительского отношения 

    Невозможно ссылаться на несуществующие объекты $\to$ значения атрибута внешнего ключа дочернего отношения должны иметь соответствие среди значений атрибутов отношения потенциального ключа родительского

    Взаимосвязи типа M:N реализуются использованием нескольких взаимосвязей типа 1:M
\end{nota}

\newpage

\subsection{Знакомство с PostgreSQL (реклама)}

\begin{defin}{PostgreSQL}
    PostgreSQL -- это открытая, BSD-лицензированная система управления объектно-ориентированными реляционными базами данных 
\end{defin}

\begin{nota}{История PostgreSQL}
    \begin{itemize}
        \item 1986 -- старт проекта PostgreSQL на факультете компьютерных наук Калифорнийсокго университета в Беркли
        
        Первоначальное название проекта -- POSTGRES (развитие старой БД Ingres)

        \item 1996 -- проект POSTGRES переименован в PostgreSQL, для отражения поддержки SQL
        
        Global Development Group PostgreSQL, специализированное сообщество участников, продолжает выпускать релизы проекта с открытым исходным кодом 

        \item Первоначально PostgreSQL был разарботан для работы на UNIX-подобных платформах
        
        Сейчас PostgreSQL поддерживает различны платформы, такие как Windows, macOS и Solaris
    \end{itemize}
\end{nota}

\begin{nota}{Преимущества и особенности СУБД PostgreSQL}
    \begin{itemize}
        \item Надежность
        \item Производительность
        \item Расширяемость
        \item Поддержка SQL
        \item Поддержка многочисленных типов данных
    \end{itemize}
\end{nota}

\begin{nota}{Расширяемость}
    PostgreSQL спроектирован с рассчетом на расширяемость 

    Прикладные программисты могут:

    \begin{itemize}
        \item Создавать собственные типы данных на основе уже имеющихся (составные типы, диапазоны, масисвы, перечисления)
        \item Писать хранимые процедуры и функции для обработки данных в БД (в том числе триггеры)
        \item Писать расширения (языке программирования Си), которые добавляют необходимый функционал и, обычно, могут подключаться даже к работающему серверу
    \end{itemize}

    Если вам не нравится какая-либо часть системы, вы всегда можете разработать собственный плагин
\end{nota}

\begin{Remark}{Важный факт}
    Подавляющее большинство СУБД:

    \begin{itemize}
        \item Представляет собой сервис (демон в $^*$nix-системах), который взаимодействует с внешним миром по специальным протоколам (чаще всего, построенным поверх TCP/IP)
        \item Не имеет никакого человеческого интерфейса
        \item Общение осуществляется на специализированном языке через специальные библиотеки
    \end{itemize}

    MySQL Workbench, Microsoft SQL Serber Management Studio, Oracle SQL Developer и им подобные -- это не СУБД, это лишь клиентское программное обеспечение, позволяющее нам взаимодействовать с СУБД
\end{Remark}

\begin{nota}{Упрощенная архитектура PostgreSQL}
    PostgreSQL -- это СУБД клиент-серверного типа с многопроцессной архитектурой, работающая на одном хосте 

    Сбой в одном из процессов не повлияет на остальные и система продолжит функционировать 

    Набор нескольких процессов, совместно управляющих одним кластером БД, называется "сервером PostgreSQL"\

    Один сервер PostgreSQL может управлять несколькими конкурентными клиенсткими подключениями 
\end{nota}

\begin{nota}{Основные процессы}
    \begin{itemize}
        \item FrontEnd процессы -- клиентские приложения:
        
        \begin{itemize}
            \item Используют PostgreSQL в качестве менеджера баз данных
            \item Соединение может происходить через TCP/IP или локальные сокеты 
        \end{itemize}

        \item Демон postres (postmaster) -- это основной процесс PostgreSQL:
        
        \begin{itemize}
            \item Прослушивание через порт/сокет входящих клиенстких подключений
            \item Создание BackEnd процессов и выделение им ресурсов
        \end{itemize}

        \item BackEnd процессы:
        
        \begin{itemize}
            \item Аутентификация клиенстких подключений 
            \item Управление запросами и отправка результатов клиенстким приложениям 
            \item Выполнение внутренних задач (служебные процессы)
        \end{itemize}
    \end{itemize}
\end{nota}

\begin{nota}{Процесс взаимодействия с БД}
    \begin{enumerate}
        \item Клиент (FrontEnd)
        
        \begin{enumerate}
            \item Используя язык БД формулирует требования к результату
            \item Опирается на знание логической структуры БД
        \end{enumerate}

        \item СУБД (postmaster и BackEnd)
        
        \begin{enumerate}
            \item Получает запрос от клиента 
            \item Анализирует разрешения
            \item Анализирует и оптимизирует запрос 
            \item Создает план выполнения запроса, опираясь на знание физической структуры данных
            \item Выполняет запрос 
        \end{enumerate}
    \end{enumerate}
\end{nota}

\begin{nota}{Взаимодействие с БД}
    Для работы с реляционной СУБД существует два основных подхода:

    \begin{itemize}
        \item Работа с библиотекой, которая соответствует конкретной СУБД и позволяет использовать для работы с БД язык БД 
        \item Работа с ORM, которая использует объектно-ориентированный подход для работы с БД и автоматически генерирует код на языке БД 
    \end{itemize}
\end{nota}

\begin{nota}{Подключение к СУБД с использованием клиентской библиотеки}
    Строка подключения вклюает:

    \begin{itemize}
        \item Имя сервера БД (или IP адрес и порт)
        \item Имя базы данных
        \item Учетную запись пользователям
        \item И другие параметры, необходимые для установки исходного подключения 
    \end{itemize}
\end{nota}

\newpage

\subsection{SQL и NoSQL}

\begin{nota}{Модели данных}
    \begin{itemize}
        \item Иерархическая (файловая система)
        \item Сетевая (социальные сети)
        \item Документ-ориентированная (системах управления содержимым)
        \item Реляционная (банковские системы)
        \item Объектно-ориентированная (естественное отображение ООП кода на БД, уменьшающее impedance mismatch)
        \item Многомерная (аналитические системы)
    \end{itemize}
\end{nota}

\begin{nota}{Преимущества РБД}
    \begin{itemize}
        \item Совместное использование данных
        
        \begin{itemize}
            \item Улучшенное управление паралелльной работой
            \item Повышенная безопасность 
            \item Контроль доступа к данным 
        \end{itemize}

        \item Поддержка целостности данных 
        
        \begin{itemize}
            \item Контроль за избыточностью данных и их непротиворечивостью
            \item Обеспечение поддержки бизнес-правил 
        \end{itemize}

        \item Эффективное управление 
        
        \begin{itemize}
            \item Упрощение сопровождения системы за счет неазависимости от данных 
            \item Эффективное резервное копирование и восстановление данных
        \end{itemize}

        \item Применение стандартов 
    \end{itemize}
\end{nota}

\begin{nota}{Недостатки РБД}
    \begin{itemize}
        \item Сложность
        
        Затраты на преобразование данных на входе и выходе

        \item Уязвимость
        
        Централизация ресурсов повышает уязвимость системы 

        \item Высокие финансовые затраты 
        
        \begin{itemize}
            \item Стоимость СУБД 
            \item Стоимость сопровождения 
            \item Дополнительные затраты на аппаратное обеспечение 
        \end{itemize}
    \end{itemize}
\end{nota}

\begin{defin}{Базы данных NoSQL}
    Базы данных NoSQL хорошо подходят для приложений, которые должны быстро, с низкой временной задержкой (low latency) обрабатывать большой объем данных с разной структурой 

    \begin{itemize}
        \item Гибкость. Благодаря использованию гибких моделей данных БД NoSQL хорошо подходят для частично структурированных и неструктурированных данных. Эффективность работы с разреженными данными 
        \item Масштабируемость. БД NoSQL рассчитаны на масштабирование с использованием распределенных кластеров аппаратного обеспечения. Широко используются в облачных решениях в качестве полностью управляемых сервисов
        \item Высокая производительность. БД NoSQL оптмизированы для конкретных моделей данных и шаблонов доступа, что позволяет достичь более высокой производительности по сравнению с реляционными базами данных 
        \item Широкие функциональные возможности. БД NoSQL предоставляют API и типы данных с широкой функциональностью, которые специально разработаны для соответствующих моделей данных 
    \end{itemize}
\end{defin}

\begin{defin}{Нереляционные БД}
    \begin{itemize}
        \item Хранилища ключей и значений 
        
        \begin{itemize}
            \item Поддерживают высокую разделяемость и обеспечивают беспрецендентное горизонтальное масштабирование 
            \item Игровые, рекламные прилоежния и приложения IoT (Amazon DynamoDB, Redis, Riak)
        \end{itemize}
        
        \item Колоночные
        
        \begin{itemize}
            \item Данные хранятся не по строкам, а по столбцам 
            \item Хорошо подходят для BigData (Hbase, Clickhouse, Vertica)
        \end{itemize}

        \item Документоориентированные 
        
        \begin{itemize}
            \item Хранение коллекций документов с произвольным набором атрибутов (полей)
            \item Каталоги, пользовательские профили и системы управления контентом, где каждый документ уникален и изменяется со временем (CouchDB, Couchbase, MongoDB)
        \end{itemize}

        \item Графовые
        
        \begin{itemize}
            \item Упор на установление произвольных связей между данными 
            \item Социальные сети, сервисы рекомендаций, системы выявления мошенничества и графы знаний (OrientDB, Neo4j)
        \end{itemize}
    \end{itemize}
\end{defin}

\begin{center}
    \begin{tabular}{|m{7.5em}|m{16em}|m{16em}|}
        \hline
        Параметр & Реляционные (SQL) & NoSQL \\
        \hline
        Подходящие рабочие нагрузки & OLTP и OLAP & Приложения с низкой задержкой доступа к данным \\
        \hline
        Модель данных & Нормализованная реляционная модель обеспечивает целостность ссылочных данных в отношениях между таблицами & Предоставляют разнообразные модели данных, оптимизированные для высокой производительности и масштабируемости \\ 
        \hline
        Струткура & Жесткая схема: таблицы (строки, столбцы) & Гибкие модели: документы, ключ-значение, графы, колоночные \\
        \hline
        Изменение схемы & Требует ALTER TABLE, миграции & Гибкость (документы без фиксированной схемы) \\
        \hline
        Типы данных & Строгая типизация & Диинамические (JSON, BLOB и другие) \\
        \hline
        Связи & JOIN, внешние ключи, ACID-транзакции & Часто денормализация, ссылки или вложенные данные \\
        \hline
        Производительность & Зависит от дисковой подсистемы. Требуется оптимизация запросов, индексов и струткур таблицы & Зависит от размера кластера базового аппаратного обеспечения, задержки сети и вызывающего приложения \\ 
        \hline
        Чтение/запись & Быстрые сложные запросы (OLTP), но JOIN могут замедлять & Высокая скорость для простых операция (ключ-значение) \\
        \hline
        Оптимизация & Индексы, нормализация & Денормализация, распределенные вычисления \\
        \hline
        Масштабирование & Масштабируются путем увеличения вычислительных возможностей аппаратного обеспечения или добавления отдельных копий для рабочих нагрузок чтения & Поддерживают высокую разделяемость благодаря шаблонам доступа с возможностью масштабирования на основе распределенной архитектуры \\
        \hline
        Горизонтальное & Сложно (шардинг требует усилий) & Оптмиизировано (например, Cassandra, DynamoDB) \\
        \hline
        Вертикальное & Стандартный подход (увеличение сервера) & Возможно, но реже используется \\
        \hline
    \end{tabular}
\end{center}

\newpage

\subsection{Классификация баз данных}

\begin{nota}{Классификация БД}
    \begin{itemize}
        \item Классификация БД по характеру организации данных 
        
        \begin{itemize}
            \item Неструктурированные 
            
            БД, хранят данные в виде обычного текста или гипертекстовой разметки 

            \begin{itemize}
                \item рпоще зафиксировать (как есть)
                \item Очень трудно искать конкретные данные, поскольку они не структурированы 
                \item Очень трудно анализировать, поскольку данных как правило качественные (семантические)
            \end{itemize}

            \item Структурированные 
            
            БД, хранящие данные в организованном виде в отформатированном хранилище

            \begin{itemize}
                \item Требуют предварительного проектирования и описания структуры БД
                \item Только после этого БД такого типа могут быть заполнены данными 
                \item Очень простой поиск и нахождение данных в базе данных или наборе данных 
                \item Очень легко анализировать данные, поскольку они как правило количественные
            \end{itemize}
        \end{itemize}

        \item Классификация БД по характеру хранимой информации 
        
        \begin{itemize}
            \item Документальные
            
            \begin{itemize}
                \item Предназначены для хранения слабо структурированных данных. Единицей хранения является документ, заданный конечным (но не фиксированным) набором полей в общем случае произвольной длины. Значение поля может иметь сложную структуру и зависеть от контекста использования 
                \item Пользователю в ответ на его запрос выдается либо ссылка на документ, либо сам документ, в котором он может найти интересующую информацию
                \item Использование: гипертекстовые документы в сети Интернет
                \item Информационно-справочные или информационно-поисковые системы 
            \end{itemize}
            \item Фактографические
            
            \begin{itemize}
                \item Ориентированы на хранение хорошо структурированных данных. Единицей информации служит описание факта конечным, четко определенным множеством свойств. Каждое свойство факта (объекта) имеет атомарное значение, которое не зависит от контекста использования
                \item Использование: БД оперативной обработки транзакций (OLTP) -- операционные БД, БД оперативной аналитической обработки (OLAP) -- хранилища данных (Data Warehouse)
            \end{itemize}
        \end{itemize}

        \item Классификация БД и СУБД по структуре организации данных 
        
        Структурированные БД различаются по типу используемой модели представления данных 

        \begin{itemize}
            \item Сетевые
            \item Иерархические
            \item Реляционные
            \item Многомерные 
            \item Объектно-ориентированные 
        \end{itemize}
    \end{itemize}
\end{nota}

\begin{defin}{Модель представления данных}
    Модель данных -- интегрированный набор понятий для описания и обработки данных, связей между ними и ограничений, накладываемых на данные в рамках предметной области 

    Модель данных можно рассматривать как сочетание трех компонентов:

    \begin{itemize}
        \item Структурная часть -- набор правил, по которым может быть построена БД 
        \item Управляющая часть -- определяет типы допустимых операций с данными: для обновления и извллечения данных, для изменения структуры данных 
        \item Набор ограничений (необязательный) для поддержки целостности данных, гарантирующих корректность используемых данных (полноту, непротиворечивость и адекватное отражение предметной области)
    \end{itemize}
\end{defin}

\begin{defin}{Иерархическая модель данных}
    Иерархическая модель данных -- это модель данных, где используется представление БД в виде древовидной (иерархической) структуры, состоящей из объектов (данных) различных уровней -- родителей-потомков 

    В иерархической модели узел может иметь только одного родителя

    \begin{itemize}
        \item Самый верхний узел называется корневым узлом 
        \item Все узлы дерева, за исключением корневого, должны иметь родительский узел 
        \item Связи между отдельными узлами дерева отражаются с помощью направленных ребер графа -- от родителя к ребенку
    \end{itemize}
\end{defin}

\begin{defin}{Сетевая модель данных}
    Для описания сетевой модели данных используют понятия "запись"\ и "связь"\ 

    Связь определяется для двух записей: предка и потомка 

    В сетевой модели данных запись-потомок может иметь произвольное число записей-предков 

    В сетевой структуре каждый элемент может быть связан с любым другим элементом 

    Сетевые базы данных подобны иерархическим, за исключением того, что в них имеются указатели в обоих направлениях, которые соединяют родственную информацию 

    Несмотря на то, что эта модель решает некоторые проблемы, связанные с иерархической моделью, выполнение простых запросов остается достаточно сложным процессом 

    Также, поскольку логика процедуры выборки данных зависит от физической организации этих данных, то эта модель не является полностью независимой от приложения. Другими словаи, если необходимо изменить структуру данных, то нужно изменить и приложение 
\end{defin}

\begin{defin}{Реляционная модель данных}
    Эта модель данных основана на понятии математических отошений (relation)

    В реляционной модели данные представлены в виде плоских таблиц, связанных между собой. Необходимо помнить, что таблица есть понятие нестрогое и часто означает не отношение как абстрактное понятие, а визуальное представление отношения на бумаге или экране. В частности -- таблицы обычно предполагают упорядоченное хранение данных, в то время как отношения -- не обладают этой характеристикой 

    Между отношениями поддерживаются связи один-к-одному или один-ко-многим 
\end{defin}

\begin{defin}{Многомерная модель данных}
    Данные представлены в виде многомерного куба (массива). Измерение (атрибут в реляционной модели) -- размерность куба. Факт (агрегированная числовая характеристика) -- содержимое ячейки 

    Агрегаты по всем срезам куба высчитываются один раз и хранятся в базе 
\end{defin}

\begin{defin}{Объектно-ориентированная модель данных}
    Данные представлены в виде классов и относящихся к ним объектов 

    \begin{itemize}
        \item Класс -- тип объекта 
        \item Атрибут -- свойство объекта 
        \item Метод -- операция над объектом 
    \end{itemize}

    Инкапсуляция структурного и функционального описания объектов 

    Наследуемость внешних свойств объектов на основе соотношения "класс-подкласс"\
\end{defin}

\newpage 

\subsection{Классификация СУБД}

\begin{defin}{Словарь данных}
    Словарь данных -- набор доступных для выборки всем пользователям базы данных системных таблиц, в которых хранятся метаданные (данные о данных)
\end{defin}

\begin{nota}{Классификация СУБД}
    \begin{itemize}
        \item Классификация по количеству пользователей 
        
        \begin{itemize}
            \item Однопользовательские 
            
            \begin{itemize}
                \item Реализуются на автономном ПК без использования сетей связи 
                \item Рассчитаны на работу одного пользователя или группы пользователей, разделяющих по времени одно рабочее место 
                \item Настольные или локальные СУБД 
            \end{itemize}

            \item Многопользовательские 
            
            \begin{itemize}
                \item Ориентированы на коллективное использование информации 
                \item Строятся на базе локальной вычислительной сети 
                \item Могут быть распределены по нескольким узлам (хостам)
            \end{itemize}
        \end{itemize}

        \item Классификация по степени распределенности
        
        \begin{itemize}
            \item Локальные СУБД -- все части размещаются на одном компьютере 
            \item Распределенные СУБД -- части СУБД могут размещаться не только на одном, но на двух и более компьютерах 
            
            \begin{itemize}
                \item Файл-серверные
                \item Клиент-серверные 
                
                \begin{itemize}
                    \item Двухзвенные (СУБД и БД, клиентские приложения)
                    \item Многозвенные (СУБД и БД, сервер приложений, клиентские приложения)
                \end{itemize}
            \end{itemize}
        \end{itemize}
        \item Классификация по способу доступа к БД 
    \end{itemize}
\end{nota}

\begin{nota}{Недостатки файл-серверной архитектуры}
    СУБД не располагает информацией о том, что происходит на компьютере где хранятся данные:

    \begin{itemize}
        \item Невозможно считать из БД только ту часть данных, которые запрашивает пользователь -- считывается файл целиком (блокировка файла) 
        \item Большой объем сетевого трафика (передача по сети множества блоков и файлов, необходимых приложению)
        \item Узкий спект операций манипулирования с данными, определяемый только файловыми командами 
        \item Отсутствие адекватных средств безопасности доступа к данным (защита только на уровне файловой системы)
        \item Недостаточно развитый аппарат транзакций служит потенциальным источником ошибок в плане нарушения смысловой и ссылочной целостности информации при одновременном внесении изменений в одну и ту же запись 
    \end{itemize}
\end{nota}

\begin{defin}{Архитектура клиент-сервер (двухзвенная)}
    На сервере: база данных, серверная часть СУБД -- взаимодействует с БД, обеспечивая выполнение запросов клиентской части 

    На клиенте: прикладные программы, клиентская часть СУБД -- обеспечивает взаимодействие с пользователем и формирование запросов к БД и передача их на сервер

    Преимущества:

    \begin{itemize}
        \item СУБД располагает информацией о наборе файлов БД
        \item Обеспечение разграничения доступа к данным нескольких пользователей 
        \item Считывание только необходимой пользователю информации из файла (блокировка блока данных)
        \item Обеспечивает корректную параллельную раоту всех пользователей с единой БД 
    \end{itemize}

    Недостатки: 

    \begin{itemize}
        \item Очень большая загрузка на сервер, так как он обслуживает множество клиентов и выполняет всю основную обработку данных 
        \item Нагрузка с обработкой полученных данных дублируется на клиентские хосты 
    \end{itemize}
\end{defin}

\begin{defin}{Архитектура клиент-сервер (трехзвенная)}
    Схема: тонкий клиент $\to$ сервер приложений $\to$ сервер базы данных 

    В функции клиентской части (тонкий клиент) входи только интерактивное взаимодействие с пользователем 

    Вся логика обработки данных (прикладные программы) вынесена на сервер приложений, который и обеспечивает формирование запросов к БД, передаваемых на выполнение серверу БД 

    Сервер приложений может являться специализированной программой или обычным web-сервером 

    Преимущества: 

    \begin{itemize}
        \item Снижается нагрузка на сервер БД -- он занимается исключительно функциями СУБД 
        \item При изменении бизнес-логики нет необходимости изменять клиенсткие приложения 
        \item Максимально снижаются требования к аппаратуре пользователей 
        \item Данная модель обладает большей гибкостью, чем двухуровневые модели 
    \end{itemize}

    Недостатки:

    \begin{itemize}
        \item Более высокие затраты ресурсов компьютеров на обмен информацией между компонентами приложений по сравнению с двухуровневыми моделями 
    \end{itemize}
\end{defin}

\begin{defin}{Встраиваемые СУБД}
    Встаиваемая СУБД -- поставляется как составная часть некоторого программного продукта, не требующая процедуры самостоятельной установки

    Предназначена для локального хранения данных своего приложения и не рассчитана на коллективное использование в сети 

    Физически чаще всего реализуется в виде подключаемой библиотеки 

    Доступ к данным со стороны приложения может происходить через язык запросов либо через специальные программные интерфейсы 
\end{defin}

\newpage

\subsection{Аспект обработки реляционной модели}

\begin{nota}{Математические аппараты для манипулирования данными}
    Виды:

    \begin{itemize}
        \item Реляционная алгебра -- основана на теории множеств. Описывает порядок выполнения операций, позволяющих из исходных выражений получить результат 
        \item Реляционное исчисление -- основано на логике предикатор первого порядка. Описывает результат в терминах исходных отношений 
    \end{itemize}

    Свойство замкнутости операций на множестве отношений. Выражения реляционной алгебры и формулы реляционного исчисления определяются над отношениями реляционных БД и результатом вычисления также являются отношения 

    В современных РСУБД не используется в чистом виде ни реляционная алгебра, ни реляционное исчисление. Фактическим стандартом доступа к реляционным данным стал язык SQL (Structured Query Language), который представляет собой смесь операторов реляционной алгебры и выражений реляционного исчисления, использующий синтакси, близкий к фразам английского языка и расширенный лополнительными отсутствующими в упомянутых аппаратах
\end{nota}

\begin{defin}{Реляционная алгебра (РА)}
    Реляционная алгебра -- это формальный язык операций над отношениями (таблицами), включающий SQL -- декларативный язык запросов, который включает не только операции РА, но и дополнительные конструкции (агрегацию, рекурсию, модификацию данных и др.)

    Вывод: классическая реляционная алгебра и базовый SQL (без агрегации, рекурсии, оконных функци итд) эквивалентны по выразительной силе в рамках запросов к базе данных. Однако SQL строго мощнее, если учитывать все его возможности (например, рекурсивные запросы, агрегацию, модификацию данных)

    Операции реляционной алгебры:

    \begin{itemize}
        \item Теоретико-множественные
        
        \begin{itemize}
            \item Объединение отношений 
            \item Пересечение отношений
            \item Вычитание отношений 
            \item Декартово произведение отношений 
        \end{itemize}

        \item Специальный 
        
        \begin{itemize}
            \item Выборка (ограничение) отношений 
            \item Проекция отношения
            \item Соединение отношений 
            \item Деление отношения 
        \end{itemize}

        \item Дополнительные 
        
        \begin{itemize}
            \item Присваивание (сохранение результатов вычисления)
            \item Переименование атрибутов отношения 
        \end{itemize}
    \end{itemize}
\end{defin}

\begin{nota}{Совместимость по типу}
    Некоторые реляционные операции требуют, чтобы отношения были совместимы по типу 

    Отношения являются совместимыми по типу, если их схемы идентичны 

    Отношения имеют одно и то же множество имен атрибутов, т.е. для любого атрибута в одном отношении найдется атрибут с таким же именем в другом отношении 

    Атрибуты с одинаковыми именами определены на одних и тех же доменах 

    Степени схем отношений (количество атрибутов) совпадают 
\end{nota}

\begin{defin}{Объединение отношений}
    Объединением двух совместимых по типу отношений $A$ и $B$ называется отношение $S$ с той же схемой, что и у отношений $A$ и $B$, и состоящее из кортежей, принадлежащих или $A$, или $B$, или обоим отношениями

    Синтаксис: A UNION B или A $\cup$ B

    \begin{Remark}{}
        Объединение, как и любое отношение, не может содержать одинаковых кортежей 

        Если некоторый кортеж входит и в отношение A, и в отношение B, то в объединение он входит один раз
    \end{Remark}
\end{defin}

\begin{defin}{Вычитание отношений}
    Вычитанием двух совместимых по типу отношений A и B называется отношение S с той же схемой, что и у отношений A и B, и состоящее из кортежей, принадлежащих отношению A и не принадлежащих отношению B 

    Синтаксис: A EXCEPT B или A $\setminus$ B
\end{defin}

\begin{defin}{Пересечение отношений}
    Пересечением двух совместимых по типу отношений A и B называется отношение S с той же схемой, что и у отношений A и B, и состоящее из кортежей, принадлежащих одновременно обоим отношениям 

    Синтаксис: A INTERSECT B или A $\cap$ B 

    \begin{Remark}{}
        Пересечение может быть выражено через операцию вычитания: $A \cap B = A \setminus (A \setminus B)$
    \end{Remark}
\end{defin}

\begin{defin}{Декартово произведение отношений}
    Декартовым произведением двух отношений $A = (A_1, A_2, \ldots A_n)$ и $B = (B_1, B_2 \ldots B_m)$ называется отношение S, со схемой, состоящей из атрибутов отношений $A$ и $B$: $(A_1, A_2 \ldots A_n, B_1, B_2 \ldots B_m)$ и являющееся результатом конкатенации (сцепления) каждого кортежа из отношения $A$ с каждый кортежем из отношения $B$. В результате получаем набор кортежей $(a_1, a_2 \ldots a_n, b_1, b_2 \ldots b_m)$, таких, что $(a_1 \ldots a_n) \in A$, а $(b_1 \ldots b_m) \in B$

    Синтаксис: A CROSS JOIN B или $A * B$

    \begin{Remark}{}
        Мощность произведения равен произведению мощностей отношений A и B 

        Если в отношениях A и B имеются атрибуты с одинаковыми наименованиями, то перед выполнением операции декартового произвдеения такие атрибуты необходимо переименовать 
    \end{Remark}
\end{defin}

\begin{defin}{Выборка (ограничение) отношений}
    Выборкой (ограничением) называется подмножество кортежей отношения R, удовлетворяющих определенному условию (предикату)

    Результат выборки -- горизонтальный срез отношения по некоторому условию

    Предикат -- логическое выражение, в которое могут входить атрибуты отношения R и/или скалярные выражения 

    Синтаксис: R WHERE или $\sigma$ R
\end{defin}

\begin{defin}{Проекция отношения}
    Проекцией называется вертикальное подмножество кортежей отношения R, создаваемое посредством извлечения значений указанных атрибутов $A_1 \ldots A_n$ отношения 

    Результат проекции -- вертикальный срез отношения, в котором удалены все возникшие при этом дубликаты кортежей 

    Синтаксис: $R[A_1 \ldots A_n]$ или $\prod_{A_1 \ldots A_n} R$
\end{defin}

\begin{defin}{Соединение отношений}
    $\theta$-соединение (тэта-соединение) -- определяет отношение S, которое содержит кортежи из декартового произведения отношений A и B, удовлетворяющих предикату $\theta$

    Синтаксис: (A JOIN B) ON $\theta$

    \begin{Remark}{Частные случаи}
        \begin{itemize}
            \item Экви-соединение -- предикат содержит только оператор равенства 
            \item Естественное соединение -- эквисоединение отношений A и B, выполненное по всем общим атрибутам, из результатов которого исключается по одному экземпляру каждого общего атрибута 
            \item Левое внешнее соединение -- соединение, при котором кортежи отношения A, не имеющие совпадающих значений в общих атрибутах отношения B, также включаются в общее отношение 
        \end{itemize}
    \end{Remark}
\end{defin}

\begin{defin}{Деление}
    Пусть даны отношения $A(X_1 \ldots X_n, Y_1 \ldots Y_p)$ и $B(Y_1 \ldots Y_p)$, причем атрибуты $(Y_1 \ldots Y_p)$ -- общие для двух отношений 

    Результатом деления отношения A на B является отношение со схемой $S(X_1 \ldots X_n)$, содержащее множество кортежей $(x_1 \ldots x_n)$, таких, что для всех кортежей $(y_1 \ldots y_p) \in B$ в отношении A найдется кортеж $(x_1 \ldots x_n, y_1 \ldots y_p)$

    Отношение A выступает в роли делимого, отношение B выступает в роли делителя 

    Все атрибуты отношения B должны входить в состав схемы отношения A 

    Синтаксис: A DIVIDE BY B или A $\div$ B

    \begin{Remark}{}
        Деление может быть выражено через операции декартова произведения и вычитания 

        Типичные запросы, реализуемые с помощью операции деления, обычно в своей формулировке имеют слово все 
    \end{Remark}
\end{defin}

\begin{Example}{}
    \begin{enumerate}
        \item Получить имена поставщиков, поставляющих деталь номер 2:
        
        ((DP JOIN P) WHERE DNUM=2)[PNAME]

        \item Получить имена поставщиков, поставляющих по крайней мере одну гайку 
        
        (((D JOIN DP) JOIN P) WHERE DNAME=Гайка)[PNAME]
        (((D WHERE DNAME=Гайка) JOIN DP) JOIN P)[PNAME]

        \item Получить имена поставщиков, поставляющих все детали 
        
        ((DP[PNUM,DNUM] DIVIDE BY D[DNUM]) JOIN P)[PNAME]
    \end{enumerate}
\end{Example}

\newpage

\subsection{Типы данных}

\begin{defin}{PostgreSQL и типы данных}
    SQL -- язык со строгой типизацией. Каждый элемент данных имеет некоторый тип, определяющий его поведение и допустимое использование 

    PostgreSQL наделен расширяемой системой типов, более универсальной и гибкой по сранвению с другими реализациями SQL 
\end{defin}

\begin{nota}{Типы данных}
    \begin{itemize}
        \item Символьные 
        \item Числовые 
        \item Дата и время 
        \item Логические 
        \item Двоичные 
        \item Специальные 
    \end{itemize}
\end{nota}

\begin{defin}{Символьные данные}
    varchar(n), char(n), text 

    Константные зачения. Последовательность символов, заключенная в апострофы. Две строковые константы, разделенные пробельными символами и минимум одним переводом строки, объединяются в одну 

    \begin{itemize}
        \item Константы со спецпоследовательностями в стиле С 
        
        Начинаются с буквы Е (заглавной или строчной)

        \item Строковые константы со спецпоследовательностями Unicode 
        
        Позволяют включать в строки символы Unicode по их кодам 

        Начинается с U\& (строчная или заглавная U и амперсанд)

        Символы Unicode можно записывать двумя способами:

        \begin{itemize}
            \item $\backslash$ и код символа из четырех шестнадцатеричных цифр 
            \item $\backslash+$ и код символа из шести шестнадцатеричных цифр
        \end{itemize}

        \item Строковые константы, заключенные в доллары 
        
        Используются для работы со строками, содержащими много апострофов или обратных косых черт. Позволяют избежать необходимости зеркалирования служебных символов. Делают строки более читабельными. Обрамляются \$[тэг]\$
    \end{itemize}
\end{defin}

\begin{defin}{Точные числовые данные}
    Целочисленные типы -- smallint (int2), integer (int4), bigint (int8)

    Числа фиксированной точности -- numeric (precision, scale) и decimal (precision, scale)
\end{defin}

\begin{defin}{Числовые данные с плавающей точкой}
    real, double precision и float(p)

    Поддерживают специальные значения Infinity, -Infinity и NaN

    Если точность вводимого числа выше допустимой -- будет выполняться округление значения. При вводе слишком большого или очень маленького значения будет генерироваться ошибка 

    Внимание: сравнение двух чисел с плавающей точкой на предмет равенства их значений может привести к неожиданным результатам 
\end{defin}

\begin{defin}{опследовательные типы}
    serial (int4), bigserial (int8) и msallserial (int2)

    Реализованы как удобная замена целой группы SQL-команд: создание объекта SEQUENCE -- генератор уникальных целых чисел, генерация и получение значений последовательности 

    Часто используются в качестве значений суррогатного первичного ключа (Primary Key)

    Нет неоюходимости указывать явное значение для вставки в поле РК 
\end{defin}

\begin{nota}{Функции для работы с последовательностями}
    \begin{center}
        \begin{tabular}{|m{7em}|m{4em}|m{25em}|}
            \hline
            Функция & Тип результата & Описание \\ 
            \hline
            currval('name') & bigint & Возвращает последнее сгенерированное значение указанной последовательности (которое было возвращено при последнем вызове функции nextval) \\
            \hline
            lastval() & bigint & Возвращает последнее сгенерированное значение любой последовательности (которое было возвращено при последнем вызове функции nextval) \\
            \hline 
            nextval('name') & bigint & Генерит и возвращает новое значение последовательности \\ 
            \hline
            setval('name', bigint) & bigint & Устанавливает текущее значение последовательности \\
            \hline
            setval('name', bigint, boolean) & bigint & Устанавливает текущее значение последовательности и флаг is-called, указывающий на то, что это значение уже использовалось \\
            \hline
        \end{tabular}
    \end{center}
\end{nota}

\begin{defin}{Дата и время}
    date, time и time with time zone (timetz)

    Даты обрабатываются в соответствии с григорианским календарем

    time хранит время внутри суток. time with time zone хранит время с учетом смещения, соответствующего часовому поясу

    При вводе значений их нужно заключать в одинарные кавычки, как и текстовые строки
\end{defin}

\begin{defin}{Временная метка (интегральный тип)}
    timestamp, timestamp with time zone (timestamptz)

    Получается в результате объединения типов даты и времени 

    Оба типа занимают 8 байтов 

    Значения типа timestamptz хранятся приведенными к нулевому часовому поясу (UTC), а перед выводом приводятся к часовому поясу пользователя 
\end{defin}

\begin{defin}{Тип interval}
    Представляет продолжительность отрезка времени 

    Формат: quantity unit [quantity unit ...] direction

    Стандарт ISO 8601: P[yyyy-mm-dd][Thh:mm:ss]

    Значение типа interval можно получить при вычитании одной временной метки из другой 
\end{defin}

\begin{nota}{Операторы даты/времени}
    \begin{itemize}
        \item date +/- integer -- добавляет/вычитает к дате заданное число дней 
        \item date +/- interval -- добавляет/вычитает к дате интервал 
        \item date +/- time -- добавляет/вычитает к дате время 
        \item interval +/- interval -- складывает/вычисляет интервалы 
        \item timestamp +/- interval -- добавляет/вычитает к метке времени интервал 
        \item date - date -- возвращает разницу между датами в днях 
        \item timestamp - timestamp -- вычитает из одной отметки времени другую (преобразуя 24-часовые интервалы в дни)
    \end{itemize}
\end{nota}

\begin{defin}{Логический тип}
    boolean

    Может иметь три состояния: true, false, NULL. Реализует трехзначную логику 
\end{defin}

\begin{defin}{Двоичные типы данных}
    bytea

    Позволяют хранить байты с кодом 0 и другими непечатаемыми значениями (значения вне десятичного диапазона 32..126)

    В операциях с двоичными строками обрабатываются байты в чистом виде 

    Поддерживает два формата ввода и вывода (параметр bytea-output):

    \begin{itemize}
        \item hex (шестнадцатеричный) -- '$\backslash x$ коды символов в 16-ой системе'
        \item escape (спецпоследовательностей) -- '$\backslash$коды символов в 8-ой системе'
    \end{itemize}
\end{defin}

\begin{nota}{Приведение типов}
    Приведение типов в PostgreSQL -- это осуществление преобразования одного типа информации в другой

    Для приведения типов данных в PostgreSQL используется: функция CAST, выражение::тип, тип выражения 

    Неявные преобразования, производимые PostgreSQL, могут влиять на результат запроса
\end{nota}

\newpage

\section{Лекция 2. Введение в язык}

\subsection{Язык SQL}

\begin{defin}{Язык SQL}
    SQL (Structured Query Language) -- язык структурированных запросов 

    Разработан IBM в 1970-х годах. Принят органами стандартизации ANSI и ISO. Первоначальное название -- SEQUEL (Structured English QUEry Language). Широко используется в промышленности (диалекты)

    Язык запросов SQL:

    \begin{itemize}
        \item Является декларативным 
        \item Определяет требования к результату, а не алгоритм выполнения 
        \item Регистронезависим
    \end{itemize}
\end{defin}

\begin{nota}{История версий стандарта SQL}
    \begin{center}
        \begin{tabular}{| m{5em} | m{33em} |}
            \hline
            Название & Изменения \\ 
            \hline
            SQL-86 & Первый вариант стандарта, принятый институтом ANSI и одобренный ISO в 1987 году \\
            \hline
            SQL-89 & Немного доработанный вариант предыдущего стандарта \\ 
            \hline
            SQL-92 & Значительные изменения (ISO 9075); уровень Entry Level стандарта SQL-92 был принят как стандарт FIPS 127-2 \\
            \hline
            SQL:1999 & Добавлена поддержка регулярных выражений, рекурсивных запросов, поддержка триггеров, базовые процедурные расширения, не скалярные типы данных и некоторое объектно-ориентированные возможности \\
            \hline
            SQL:2003 & Введены расширения для работы с XML-данными, оконные функции, генераторы последовательностей и основанные на них типы данных \\
            \hline
            SQL:2006 & Функциональность работы с XML-данными значительно расширена. Появилась возможность совместно использовать в запросах SQL и XQuery \\
            \hline
            SQL:2008 & Улучшены возможности оконных функций, устранены некоторое неоднозначности стандарта SQL:2003 \\
            \hline
            SQL:2011 & Добавлена поддержка temporal баз данных. Расширены возможности использования оконных функций и выражение FETCH \\
            \hline
            SQL:2016 & Добавлен поиск на основе шаблона строк, полиморфические табличные функции, JSON \\
            \hline
            SQL:2019 & Добавлена часть 15, многомерные массивы (MDarray type and operatorrs) \\
            \hline
        \end{tabular}
    \end{center}
\end{nota}

\begin{nota}{Команды языка SQL}
    SQL command:
    \begin{itemize}
        \item DDL 
        
        \begin{itemize}
            \item Create 
            \item Alter 
            \item Drop 
            \item \textbf{Truncate Table}
        \end{itemize}

        \item DCL 
        
        \begin{itemize}
            \item Grant
            \item Revoke 
        \end{itemize}

        \item DML 
        
        \begin{itemize}
            \item Insert
            \item Update 
            \item Delete
        \end{itemize}

        \item TCL 
        
        \begin{itemize}
            \item \textbf{Begin}
            \item Commit 
            \item Rollback 
            \item Savepoint
        \end{itemize}

        \item DQL
        
        \begin{itemize}
            \item Select
        \end{itemize}
    \end{itemize}
\end{nota}

\begin{Remark}{DDL -- Data Definition Language}
    Используются для определения структур базы данных 

    \begin{itemize}
        \item CREATE -- создание объектов 
        \item ALTER -- модификация структуры объектов 
        \item DROP -- удаление объектов
        \item TRUNCATE TABLE -- пересоздание таблицы с удалением всех записей и освобождением места
    \end{itemize}
\end{Remark}

\begin{Remark}{DCL -- Data Control Language}
    Используются для управления привилегиями пользователей на доступ к объектам в базе данных
    
    \begin{itemize}
        \item GRANT -- предоставление привилегии 
        \item REVOKE -- отзыв ранее предоставленной привилегии (неявный запрет)
    \end{itemize}
\end{Remark}

\begin{Remark}{DML -- Data Manipulation Language}
    Команды языка манипулирования данными используются для выполнения всех типов модификации данных в базе данных 

    \begin{itemize}
        \item INSERT -- добавление записей в таблицу
        \item UPDATE -- изменение значений в полях таблицы
        \item DELETE -- удаление записей из таблицы
    \end{itemize}
\end{Remark}

\begin{Remark}{TCL -- Transaction Control Language}
    Используются для управления выполнением транзакций

    \begin{itemize}
        \item BEGIN -- открытие явной транзакции 
        \item COMMIT -- сохранение (фиксация) изменений, выполненных транзакцией
        \item ROLLBACK -- отмена (откат) изменений, выполненных транзакцией
        \item SAVEPOINT -- задание точки сохранения
    \end{itemize}
\end{Remark}

\begin{Remark}{DQL -- Data Query Language}
    Используется для извлечения данных из таблиц базы данных
\end{Remark}

\newpage 

\subsection{Написание простых запросов}

\begin{nota}{Синтаксис оператора SELECT}
    \begin{center}
        \begin{tabular}{|m{5em}|m{10em}|m{23em}|}
            \hline
            Элемент & Выражение & Описание \\
            \hline
            SELECT & Список столбцов через запятую & Определяет, какие столбцы должна содержать результирующая таблица \\
            \hline
            FROM & Определение таблиц-источников строк & Определяет таблицы-источники для извлечения данных \\
            \hline
            WHERE & Условие отбора исходных строк & Фильтрует данные из таблиц-источников с помощью предиката \\
            \hline
            GROUP BY & Группировка по списку столбцов & Упорядочивает строки по группам \\
            \hline 
            HAVING & Условие отбора групп & Фильтрует группы с помощью предиката \\ 
            \hline
            ORDER BY & Сортировка по списку столбцов & Сортирует строки результирующей таблицы \\
            \hline
        \end{tabular}
    \end{center}
\end{nota}

\begin{Remark}{Логическая последовательность выполнения оператора SELECT}
    Порядок, в котором запрос записывается отличается от порядка в котором запрос выполняется сервером БД 

    \begin{tabular}{m{2em} m{6em} m{15em}}
        5. & SELECT & <select list> \\
        7. & [INTO & new\_table\_name] \\
        1. & FROM & <table source> \\
        2. & WHERE & <search condition> \\
        3. & GROUP BY & <group by list> \\
        4. & HAVING & <search condition> \\
        6. & ORDER BY & <order by list>[ASC|DESC] \\
    \end{tabular}
\end{Remark}

\begin{Example}{Применение логического порядка операций к написанию SELECT}
    \begin{lstlisting}
        SELECT empid,
            extract('year' from orderdate) AS OrderYear
        FROM "Sales"."Orders"
        WHERE custid = 71
        GROUP BY empid, extract('year' from orderdate)
        HAVING COUNT(*) > 2
        ORDER BY empid, OrderYear;
    \end{lstlisting}
\end{Example}

\begin{Remark}{SELECT безо всего}
    Используется для:

    \begin{itemize}
        \item Инициализации переменных
        \item Возврата результата выражений и функций
    \end{itemize}
\end{Remark}

\begin{Example}{Извлечение данных из таблицы}
    Извлечение из всех столбцов таблицы 
    \begin{lstlisting}
SELECT *
FROM "Sales"."Customers";
    \end{lstlisting}

    Извлечение из отдельных столбцов таблицы 
    \begin{lstlisting}
SELECT companyname, country
FROM "Sales"."Customers";
    \end{lstlisting}
\end{Example}

\begin{nota}{Элементы языка}
    \begin{center}
        \begin{tabular}{|m{15em}|m{20em}|}
            \hline
            Элементы языка & Предикаты и операторы \\
            \hline
            Предикаты & BETWEEN, IN, LIKE, IS, ALL, ANY, SOME \\
            \hline
            Операторы сравнения & =, >, <, >=, <=, <> (!=) \\
            \hline
            Логические операторы & AND, OR, NOT \\
            \hline
            Арифметические операторы & *, /, \%, +, -, - (унарный) \\
            \hline
            Конкатенация (*зависит от диалекта языка) & ||, *(\&, +) \\
            \hline
        \end{tabular}
    \end{center}
\end{nota}

\begin{Example}{Вычисляемые столбцы и псевдонимы столбцов}
    Создание вычисляемых столбцов 
    \begin{lstlisting}
SELECT unitprice, qty, (qty * unitprice) 
FROM "Sales"."OrderDetails";
    \end{lstlisting}

    Псевдонимы заключаются в двойные качки, если содержат пробелы, специальные символы или необходимо различать регистры символов
    \begin{lstlisting}
SELECT unitprice, qty Quantity, (qty * unitprice) AS Total 
FROM "Sales"."OrderDetails";
    \end{lstlisting}
\end{Example}

\begin{Example}{Псевдонимы таблиц}
    Создаются в предложении FROM. Полезны при выборке данных из нескольких таблиц 
    \begin{lstlisting}
SELECT custid, orderdate 
FROM "Sales"."Orders" AS SO;
    \end{lstlisting}

    Ссылка на столбцы таблицы с использованием псевдонима таблицы 
    \begin{lstlisting}
SELECT SO.custid, SO.orderdate
FROM "Sales"."Orders" AS SO;
    \end{lstlisting}
\end{Example}

\begin{nota}{Влияние логического порядка выполнения запроса на псевдонимы}
    Предложения FROM, WHERE и HAVING обрабатываются до SELECT 

    Псевдонимы столбцов создаются в SELECT и видны только в ORDER BY 

    Выражения, для которых в предложении SELECT определены псевдонимы, должны быть повторно использованы в остальных предложениях запроса
\end{nota}

\begin{nota}{Использование выражения CASE в предложении SELECT}
    Выражение CASE возвращает скалярное значение 

    CASE может использоваться для:

    \begin{itemize}
        \item Создания вычисляемого столбца в SELECT 
        \item Формирования условия в WHERE или HAVING
        \item Задания порядка сортировки в ORDER BY
    \end{itemize}

    CASE возвращает результат вычисления выражения
\end{nota}

\begin{nota}{Формы выражений CASE}
    \begin{itemize}
        \item Simple CASE 
        
        \begin{itemize}
            \item Сравнивает одно выражение со списком возможных значений 
            \item Возвращает первое совпадение
            \item Если совпадений не обнаружено, возвращает значение, основываясь на выражении ELSE
            \item Если не найдено совпадений и не определено выражение ELSE, возвращает NULL
        \end{itemize}
        
        \item Searched CASE 
        
        \begin{itemize}
            \item Проверяет набор предикатов или логических выражений 
            \item Возвращает значение указанное в выражении THEN первого выражения, которое возвращает TRUE
        \end{itemize}
    \end{itemize}
\end{nota}

\begin{Example}{Simple CASE}
    \begin{lstlisting}
SELECT contactname,
    CASE contacttitle
        WHEN 'Owner' THEN 'Yes'
        ELSE 'No'
    END AS Owner
FROM "Sales"."Customers"
    \end{lstlisting}
\end{Example}

\begin{Example}{Searched CASE}
    \begin{lstlisting}
SELECT productname, unitprice,
    CASE 
        WHEN discontinued = 1::bit THEN 'withdrawn from sale'
        WHEN unitprice < 25::money THEN 'low price'
        WHEN unitprice BETWEEN 25::money AND 30::money THEN 'medium-price'
        WHEN unitprice BETWEEN 31::money AND 50::money THEN 'high-price'
    ELSE 'VIP-price'
END AS "Price category"
FROM "Production"."Products"
    \end{lstlisting}
\end{Example}

\begin{nota}{Использование функций}
    \begin{center}
        \begin{tabular}{|m{9em}|m{12em}|m{15em}|}
            \hline
            Функции форматирования и преобразования & Поддержка приведения и преобразования типов данных & CAST, TO\_CHAR, TO\_DATE, TO\_NUMBER, TO\_TIMESTAMP \\
            \hline
            Логические функции & Выполнение логических операций & NULLIF, GREATEST, LEAST \\
            \hline
            Функции даты и времени & Выполняют операции над значениями даты и времени & AGE, NOW, CURRENT\_DATE, CURRENT\_TIME, LOCALTIME, DATE\_PART, DATE\_TRUNC, MAKE\_DATE, EXTRACT \\
            \hline
            Строковые функции & Выполняют операции со строковыми (char и varchar) значениями & CONCAT, CONCAT\_WS, FORMAT, LEFT, LENGTH, LOWER, LTRIM, REPLACE, REGEXP\_REPLACE, REVERSE, RIGHT, RTRIM, SUBSTRING, TRIM, UPPER \\
            \hline
            Математические функции & Выполняют вычисления, основанные на числовых значениях & ABS, CEILING, FLOOR, POWER, ROUND, SQRT, TRUNC \\
            \hline
            Функции для перечислений & Используются для работы с типами перечислений (ENUM) & ENUM\_FIRST, ENUM\_LAST, ENUM\_RANGE \\
            \hline
        \end{tabular}
    \end{center}
\end{nota}

\newpage

\subsection{Сортировка данных}

\begin{nota}{Использование ORDER BY}
    ORDER BY сортирует записи в результирующем наборе. Без ORDER BY порядок записей результирующей выборки не гарантируется. Сортирует все NULL значения вместе 

    ORDER BY может ссылаться на:

    \begin{itemize}
        \item Имя столбца, псевдоним или позицию столбца в результирующей выборке (не рекоммендуется)
        \item Результат выражения 
        \item Столбцы, не используемые в результирующей выборке (если не используется DISTINCT)
    \end{itemize}

    ORDER BY не поддерживается в инструкциях SELECT/INTO 
\end{nota}

\begin{Example}{Пример использования ORDER BY}
\begin{lstlisting}
SELECT companyname, contactname 
FROM "Sales"."Customers" c 
ORDER BY country ASC, city desc;

SELECT custid, orderdate 
FROM "Sales"."Orders" o 
ORDER BY DATE_PART('year', orderdate) DESC;
\end{lstlisting}
\end{Example}

\begin{nota}{Фильтрация с помощью LIMIT*}
    Ограничивает число строк, возвращаемых в результирующем наборе 

    \begin{itemize}
        \item integer\_expression -- число или числовое выражение, определяющее количество возвращаемых строк 
        \item ALL -- равносильно отсутствию указания LIMIT
        \item OFFSET -- указывает число строк, которые необходимо пропустить, прежде чем начать выдавать строки 
        \item Для получения предсказуемого и согласованного результата необходимо использовать фильтрацию отсортированого набора ORDER BY
    \end{itemize}
\end{nota}

\begin{Example}{Фильтрация с помощью LIMIT}
\begin{lstlisting}
SELECT productname, unitprice
FROM "Production"."Products"
WHERE unitprice <= 40::money 
ORDER BY unitprice DESC
limit 3;
\end{lstlisting}
\end{Example}

\begin{nota}{Фильтрация в ORDER BY с помощью OFFSET-FETCH}
    OFFSET-FETCH -- это расширение ORDER BY. Позволяет отфильтровать требуемый диапазон строк. Предоставляет механизм для разбиения результирующего набора на страницы 

    Определяет количество строк, которые необходимо 

    \begin{itemize}
        \item Пропустить -- OFFSET (может быть ноль, если не нужно пропускать строки)
        \item Вернуть -- FETCH (должно быть больше или равно единице)
    \end{itemize}

    Если FETCH опущено -- возвращаются все записи до конца набора 

    WITH TIES -- вернуть дополнительные строки, с точки зрения ORDER BY совпадающие с последней строкой набора результатов
\end{nota}

\begin{Example}{Фильтрация с помощью OFFSET-FETCH}
\begin{lstlisting}
SELECT orderid, custid, orderdate 
FROM "Sales"."Orders" o 
ORDER BY orderdate DESC 
OFFSET 50 ROWS FETCH FIRST 50 ROWS ONLY;
\end{lstlisting}
\end{Example}

\begin{nota}{Фильтрация дубликатов}
    SELECT DISTINCT используется для возврата только уникальных записей: удаляет дубликаты, базируясь на результирующем списке столбцов (не на основе таблицы-источника); работает с записями уже обработанными в выражениях WHERE, HAVING и GROUP BY; NULL значения уникальны 
\end{nota}

\begin{defin}{DISTINCT ON}
    DISTINCT ON отличается от DISTINCT тем, что определяет уникальность записей не по всем полям, а только указанным. Строки с одинаковыми значениями выражений считаются дублирующимися и возвращается только первая строка. Обработка DISTINCT ON производится после сортировки ORDER BY 
\end{defin}

\newpage

\subsection{Фильтрация записей}

\begin{defin}{Фильтрация исходных записей -- WHERE}
    Содержит логическое условие: записи, для которых условие возвращает TRUE -- попадают в результрующую выборку; FALSE и UNKNOWN -- отфильтровываются

    В предложении WHERE не доступны псевдонимы столбцов 

    Данные фильтруются на стороне сервера. Оптмизиация за счет использования индексов, снижение нагрузки на сеть и использование памяти на клиенте 
\end{defin}

\begin{nota}{Операторы сравнения}
    \begin{center}
        \begin{tabular}{|m{8em}|m{19em}|m{10em}|}
            \hline
            Оператор & Описание & Пример \\
            \hline
            < > = <= >= <> !< !> != & Операторы сравнения & Name != 'Vasia' или Name <> 'Vasia' \\ 
            \hline 
            $\sim$ и !$\sim$ & Проверка соответствия строки регулярному выражению POSIX с учетом регистра & 'Thomas' $\sim$ '.*thomas.*' $\to$ False \\
            \hline 
            $\sim$* и !$\sim$* & Проверка соответствия строки регулярному выражению POSIX без учета регистра & 'Thomas' $\sim$* '.*thomas' $\to$ True \\
            \hline
        \end{tabular}
    \end{center}
\end{nota}

\begin{nota}{Предикативные операторы}
    \begin{center}
        \begin{tabular}{|m{10em}|m{17em}|m{10em}|}
            \hline
            Оператор & Описание & Пример \\
            \hline
            BETWEEN/NOT BETWEEN & Проверка по диапазону & orderdate BETWEEN '2006-07-05' AND '2006-07-25' \\
            \hline
            IN/NOT IN & Проверка на основе списка & Price IN (50, 125, 253, 264) \\
            \hline
            LIKE/NOT LIKE & Сравнение строк по маске с учетом регистра & City LIKE 'London' \\
            \hline
            ILIKE/NOT ILIKE & Сравнение строк по маске без учета регистра & City ILIKE 'london' \\
            \hline
            SIMILAR TO/NOT SIMILAR TO & Сравнение строк по шаблону на основе регулярных выражений в стандарте SQL & 'abc' SIMILAR TO '\%(b|d)\%' \\
            \hline
            IS NULL/IS NOT NULL & Проверка на наличие/отсутствие NULL значений & region IS NOT NULL \\
            \hline
            IS DISTINCT FROM/IS NOT DISTINCT FROM & Проверка на неравенство/равенство заданному значению. При этом NULL воспринимается как обычное значение & region IS DISTINCT FROM 'WA' \\
            \hline
        \end{tabular}
    \end{center}
\end{nota}

\begin{Example}{Использование операторов сравнения}
\begin{lstlisting}
SELECT productname, unitprice
FROM "Production"."Products" p 
WHERE discontinued != 1::bit;
\end{lstlisting}
\end{Example}

\begin{Example}{Фильтрация с использованием логических операторов}
    Приоритет логических операторов -- NOT, AND, OR 

    Если два оператора в выражении имеют один и тот же уровень приоритета, они вычисляются в порядке слева направо по мере их появления в выражении 

    Чтобы изменить приоритет операторов в выражении, следует использовать скобки

\begin{lstlisting}
SELECT * 
FROM "Production"."Products" p
WHERE categoryid = 1 OR categoryid = 2 AND unitprice >= 40::money;
\end{lstlisting}
\end{Example}

\begin{Example}{Фильтрация NULL значений}
    NULL значения используются для маркировки отсутствующих значений (missing values)

    Для корректно обработки необходимо использовать предикаты:

    \begin{itemize}
        \item IS NULL (ISNULL) или IS NOT NULL (NOTNULL)
        \item IS DISTINCT FROM (!=) или IS NOT DISTINCT FROM (=)
    \end{itemize}

\begin{lstlisting}
SELECT companyname, region
FROM "Sales"."Customers" c
WHERE region IS NULL;

SELECT companyname, region
FROM "Sales"."Customers" c
WHERE region IS DISTINCT FROM 'WA';
\end{lstlisting}
\end{Example}

\begin{Example}{Проверка на принадлежность диапазону}
    Границы диапазона включены. Для задания исключающего диапазона используйте операторы больше (>) и меньше (<)

    Если любой параметр предиката BETWEEN или NOT BETWEEN имеет значение NULL, результат не определен (UNKNOWN)

\begin{lstlisting}
SELECT productname, unitprice
FROM "Production"."Products" p
WHERE unitprice BETWEEN 30::money AND 38::money;
\end{lstlisting}
\end{Example}

\begin{Example}{Проверка на принадлежность множеству}
    Определеяет, совпадает ли указанное значение с одним из значений, содержащихся во вложенном запросе или списке

    Использование значений NULL с предикатами IN/NOT IN может привести к непредвиденным результатам

\begin{lstlisting}
SELECT productname, unitprice
FROM "Production"."Products" p
WHERE unitprice IN (22::money, 30::money, 32::money, 38::money);
\end{lstlisting}
\end{Example}

\begin{Example}{Проверка на соответствие шаблону}
\begin{lstlisting}
match_expression [NOT] LIKE pattern [ESCAPE escape_character]
match_expression [NOT] ILIKE pattern [ESCAPE escape_character]
\end{lstlisting}
\end{Example}

\begin{Example}{Фильтрация по шаблону}
\begin{lstlisting}
SELECT custid, contactname, contacttitle
FROM "Sales"."Customers" c
WHERE contacttitle LIKE '%Manager';

SELECT custid, contactname, contacttitle
FROM "Sales"."Customers" c
WHERE contactname LIKE 'C%' OR contactname LIKE 'L%';
\end{lstlisting}
\end{Example}

\begin{Example}{Сопоставление с началом строки}
\begin{lstlisting}
SELECT custid, contactname, contacttitle
FROM "Sales"."Customers" c
WHERE start_with(contactname, 'L');

SELECT custid, contactname, contacttitle
FROM "Sales"."Customers" c
WHERE contactname ^@ 'C' OR contactname ^@ 'L';
\end{lstlisting}
\end{Example}

\begin{nota}{Символы шаблона POSIX}
    \begin{center}
        \begin{tabular}{|m{3em}|m{30em}|}
            \hline
            . & любой один символ \\ 
            \hline
            [...] & любой один символ в диапазоне или наборе \\
            \hline
            [\^\ ...] & любой один символ, не входящий в диапазон или набор \\
            \hline
            * & повторение предыдущего элемента 0 и более раз \\
            \hline
            + & повторение предыдущего элемента 1 и более раз \\
            \hline
            ? & вхождение предыдущего элемента 0 или 1 раз \\
            \hline
            $\{m\}$ & ровно m вхождений предыдущего элемента \\
            \hline
            $\{m,\}$ & m и более вхождений предыдущего элемента \\
            \hline
            $\{m,n\}$ & от m до n вхождений предыдущего элемента \\
            \hline
            () & объединение нескольких элементов в одну логическую группу \\
            \hline
            | & выбор (одного из двух вариантов) \\
            \hline
             & привязывает шаблон к началу строки \\
            \hline
            \$ & привязывает шаблон к концу строки \\
            \hline
        \end{tabular}
    \end{center}
\end{nota}

\begin{nota}{Проверка на соответствие шаблону POSIX}
    Возвращает true или false в зависимости от того, соответствует ли данная строка шаблону или нет. Шаблоны соответствуют определению регулярных выражений в стандарте SQL. Регулярные выражения SQL представляют собой гибрид синтаксиса LIKE с синтаксисом обычных регулярных выражений POSIX 

    Условие SIMILAR TO истинно, только если шаблон соответствует всей строке. Это отличается от условий с регулярными выражениями, в которых шаблон может соответствовать любой части строки
\end{nota}

\begin{Example}{Фильтрация с помощью SIMILAR TO}
\begin{lstlisting}
SELECT custid, contactname, contacttitle
FROM "Sales"."Customers" c
WHERE contactname SIMILAR to 'S(i|m)%';

SELECT custid, contactname, contacttitle
FROM "Sales"."Customers" c
WHERE contactname NOT SIMILAR to '[^B-R]%';
\end{lstlisting}
\end{Example}

\begin{nota}{Операторы регуярных выражений POSIX}
    \begin{center}
        \begin{tabular}{|m{3em}|m{20em}|m{10em}|}
            \hline
            Оператор & Описание & Пример \\
            \hline 
            $\sim$ & Проверка соответствия строки регулярному выражению с учетом регистра & 'thomas' $\sim$ 't.*ma' \\
            \hline
            $\sim$* & Проверка соответствия строки регулярному выражению без учета регистра & 'thomas' $\sim$* 'T.*ma' \\
            \hline
            !$\sim$ & Проверка несоответствия строки регулярному выражению с учетом регистра & 'thomas' !$\sim$ 't.*max' \\
            \hline
            !$\sim$* & Проверка несоответствия строки регулярному выражению без учета регистра & 'thomas' !$\sim$* 'T.*ma' \\
            \hline
        \end{tabular}
    \end{center}
\end{nota}

\begin{Example}{Фильтрация с использованием операторов регулярных выражений}
\begin{lstlisting}
SELECT region 
FROM "Sales"."Customers" c 
WHERE region ~ '.*ra$';

SELECT companyname, contactname, city 
FROM "Sales"."Customers" c 
WHERE contactname ~ '^(B|K|S).*(e|k)$';
\end{lstlisting}
\end{Example}

\newpage

\subsection{Массивы}

\begin{defin}{Массивы}
    Многомерные массивы переменной длины 

    Элементами массивов могут быть: 

    \begin{itemize}
        \item Любые встроенные или определенные пользователями базовые типы
        \item Перечисления, составные типы, типы-диапазоны или домены 
    \end{itemize}

    Для объявления типа массива 

    \begin{itemize}
        \item К названию типа элементов добавляются квадратные скобки 
        \item Запись с ключевым словом ARRAY
    \end{itemize}
\end{defin}

\begin{Example}{}
\begin{lstlisting}
integer[3]
integer ARRAY[3]
integer ARRAY 
\end{lstlisting}
\end{Example}

\begin{Example}{Определение массива}
\begin{lstlisting}
SELECT '{1,2,3,4,5}'::integer[], ARRAY[1,2,3]::integer[];

SELECT '{{1,2},{3,4}}'::integer[], ARRAY[[1,2],[3,4]]::integer[];
\end{lstlisting}
\end{Example}

\begin{Example}{Добавление элементов в массив}
    Добавление элементов в массив:

    \begin{itemize}
        \item Оператор || (конкатенация)
        \item Функция array\_append(массив, элемент)
        \item Функция array\_prepend(элемент, массив)
    \end{itemize}
\begin{lstlisting}
SELECT '{1,2,3,4}'::integer[] || 5,
    array_append('{1,2,3,4}'::integer[],5),
    array_prepend(5,'{1,2,3,4}'::integer[]);
\end{lstlisting}
\end{Example}

\begin{Example}{Удаление и изменение элементов массива}
    Удаление элементов из массива: функция array\_remove(массив, значение элемента)

    Изменение элемента массива: функция array\_replace(массив, старое значение, новое значение)

\begin{lstlisting}
SELECT array_remove('{1,2,3,4}::integer[],3),
    array_replace('{1,2,3,4}'::integer[],2,5);
\end{lstlisting}
\end{Example}

\begin{Example}{Извлечение элементов массива}
    Индексация элементов массива начинается с 1 

    Для извлечения одного элемента массива -- необходимо указать его номер в []

    Для извлечения нескольких элементов из массива -- необходимо в [] указать номер первого элемента и номер последнего извлекаемого элемента разделенные символом двоеточие

\begin{lstlisting}
select ('{"(921)-745-8965","(908)-567-78234",
        "(911)-745-8512","(812)-750-8965"}'::text[])[2];
\end{lstlisting}
\end{Example}

\begin{Example}{Проверка на вхождение в массив}
    Для проверки вложенности элементов одного массива в состав элементов другого массива используются операторы вложенности массивов (<@, @>)

    Один массив считается вложенным в другой, если каждый элемент первого встречается во втором. Повторяющиеся элементы рассматриваются на общих основаниях

\begin{lstlisting}
select '{(408)-567-78234}'::text[] <@ '{(408)-745-8965","(408)-567-78234"}'::text[];
\end{lstlisting}

    Для проверки вхождения литерала в массив используется оператор ANY (SOME)

\begin{lstlisting}
SELECT 10 = SOME (ARRAY[192, 168, 10, 10]);
\end{lstlisting}
\end{Example}

\begin{Example}{Разворачивание массива в набор записей}
    Чтобы представить элементы массива в виде значений некоторого столбца необходимо воспользоваться функцией UNNEST (ANYARRAY)

\begin{lstlisting}
SELECT UNNEST(ARRAY[100, 110, 153, 500]) as prodid,
        50000::money as price,
        '2022-10-20' as change_date;
\end{lstlisting}
\end{Example}

\begin{Example}{Пример использования массива}
\begin{lstlisting}
select contactname,
        split_part(contactname,',',1) as "Lname",
        trim((string_to_array(contactname,','))[2]) as "Fname"
from "Sales"."Customers";
\end{lstlisting}
\end{Example}

\newpage 

\subsection{Типы JSON}

\begin{defin}{JSON}
    JSON (JavaScript Object Notation) -- текстовый формат обмена данным, основанный на JavaScript. Как и многие другие текстовые форматы, JSON легко читается людьми. ФОрмат JSON был разработан Дугласом Крокфордом 

    Несмотря на происхождение от JavaScript (точнее, от подмножества языка стандарта ECMA-262 1999 года), формат считается независимым от яызка и может использоваться практически с любым языком программирования 

    Для многих языков существует готовый код для создания и обработки данных в формате JSON 
\end{defin}

\begin{nota}{Структура JSON-данных}
    JSON -- текст, имеющий одну из двух структур: 

    \begin{itemize}
        \item Ключ -- может быть только строка (регистрозависимость не регулируется стандартом, это остается на усмотрение программного обеспечения)
        \item Значение -- любая допустимая форма
    \end{itemize}

    Упорядоченный набор значений. Во многих языках это реализовано как массив, вектор, список или последовательность
\end{nota}


\begin{nota}{Значения JSON}
    В качестве json значений могут выступать:

    \begin{itemize}
        \item Запись -- неупорядоченное множество пар ключ:значение, заключенное в фигурные скобки. Пары ключ-значение отделяются друг от друга запятыми
        \item Массив (одномерный) -- это упорядоченное множество значений. Массив заключается в квадратные скобки. Значения разделяются запятыми. Массив может быть пустым. Значение в пределах одного массива могут иметь разный тип 
        \item Число (целое или вещественное)
        \item Литералы (в нижнем регистре) true, false и null 
        \item Строка -- это упорядоченное множество из нуля или более символов юникода, заключенное в двойные кавычки. Поддерживаются строковые константы со спецпоследовательностями в стиле C и строковые константы со спецпоследовательностями Unicode 
    \end{itemize}
\end{nota}

\begin{nota}{Типы данных JSON}
    Предназначены для сохранения и обработки данных в формате JSON в БД PostgreSQL

    Существует два типа данных для работы с JSON, которые отличаются способом хранения данных и способом работы с ними: json и jsonb 
\end{nota}

\begin{Remark}{json}
    Использует текстовый формат хранения JSON-данных, который позволяет хранить только простые типы данных JSON: строки, числа, логические значения, null и массивы или объекты, состоящие только из этих типов

    При хранении данных типа json не происходит никакой оптимизации -- высокая скорость записи 

    \begin{itemize}
        \item Сохраняет порядок следования ключей и повторяющиеся значения ключей, при этом функции обработки будут считать действительной последнюю пару 
        \item Любые изменения в данных приводят к перезаписи всей строки JSON 
        \item При использовании выполняется полный разбор -- низкая скорость обработки 
    \end{itemize}
\end{Remark}

\begin{Remark}{jsonb}
    Использует бинарный формат хранения JSON-данных, который позволяет хранить все типы данных JSON, включая вложенные объекты и массивы, а также дополнительные типы данных, такие как булевы значения, даты и времена итд 

    Бинарный формат данных jsonb позволяет эффективно хранить, индексировать и быстро выполнять запросы к данным в формате JSON:

    \begin{itemize}
        \item Разбор производится однократно при сохранении -- низкая скорость сохранения 
        \item Ключи не дублируются 
        \item Отсортированы по длине и ключу 
        \item При изменении данных не требует перезаписи всей строки JSON, а лишь тех частей, которые изменились 
        \item При использовании разбор не выполняется -- высокая скорость обработки 
    \end{itemize}
\end{Remark}

\begin{Remark}{ВАЖНО!}
    PostgreSQL позволяет использовать только одну кодировку символов в базе данных. Если кодировка базы данных не UTF-8:

    \begin{itemize}
        \item Данные JSON не будут полностью соответствовать спецификации
        \item Нельзя будет вставить символы, непредставимые в кодировке сервера 
        \item Допустимыми будут символы, представимые в кодировке сервера, но не в UTF-8
    \end{itemize}
\end{Remark}

\begin{Example}{Примеры json данных}
    \begin{itemize}
        \item Числа, строки в двойных кавычках, true и false (в нижнем регистре) или null 
        
        \begin{lstlisting}
SELECT '5'::json, '"Post"'::json, 'true'::json, 'null'::json;
        \end{lstlisting}

        \item Массив из нуля и более элементов (элементы могут быть разных типов)
        
        \begin{lstlisting}
SELECT '[1, 2, "foo", null]'::json;
        \end{lstlisting}

        \item Объект, содержащий пары ключей и значений (ключи объектов -- всегда строки в двойных кавычках)
        
        \begin{lstlisting}
SELECT '{"cheef":"Ivan", "Empl":["Svetlana","Eugen"]}'::jsonb;
        \end{lstlisting}
    \end{itemize}
\end{Example}

\begin{defin}{Функции-конструкторы}
    Для формирования json можно использовать специализированные функции:

    \begin{itemize}
        \item to\_json(anyelement) и to\_jsonb(anyelement) 
        \item jsonb\_build\_object(VARIADIC "any"\ ) и jsonb\_build\_array(VARIADIC "any"\ )
        \item array\_to\_json(anyarray [, pretty\_bool ]) 
        \item row\_to\_json(record [, pretty\_bool ])
        \item json\_object(keys text[], values text[]) и jsonb\_object(keys text[], values text[])
    \end{itemize}
\end{defin}

\begin{Example}{Извлечение значений по индексу и имени ключа}
    Получение элементов массива по индексу (индексация элементов начинается с 0. Отрицательные числа задают позиции с конца)

\begin{lstlisting}
SELECT '[{"a":"foo"},{"b":"bar"}]'::json -> 2;
SELECT '[{"a":"foo"},{"b":"bar"}]'::jsonb ->> -1;
\end{lstlisting}

    Получение значения по имени ключа 

\begin{lstlisting}
SELECT '{"cheef":"Ivan", "Empl":["Svetlana","Eugen"]}'::json -> 'cheef';
SELECT '{"cheef":"Ivan", "Empl":["Svetlana","Eugen"]}'::jsonb ->> 'Empl';
\end{lstlisting}
\end{Example}

\begin{Example}{Проверка наличия ключа верхний уровень (jsonb)}
    Типы данных json или jsonb не требуют задавать структуру объектов, т.е. конкретные имена ключей и типы значений. Может потребоваться выполнить проверку наличия соответствующего ключа. Сделать это можно только для типа данных jsonb

\begin{lstlisting}
SELECT '[{"a":"foo"},{"b":"bar"}]'::jsonb ? 'b';
\end{lstlisting}
\end{Example}

\begin{Example}{Извлечение элементов по пути}
    Для извлечения элементов можно использовать указание пути 

    \begin{itemize}
        \item \#> -- результат json/jsonb 
        \item \#>> -- результат текст
    \end{itemize}
\end{Example}

\begin{Example}{Проверка вхождения по пути (jsonb)}
    Для проверки наличия пути/значения используется оператор @> (<@)

\begin{lstlisting}
SELECT '{"a":1, "b":2}'::jsonb @> '{"b":2}'; --true
\end{lstlisting}
\end{Example}

\begin{nota}{Функции}
    \begin{itemize}
        \item json\_extract\_path -- возвращает значение JSON по пути, заданному элементами пути (\#>)
        \item json\_extract\_path\_text -- возвращает значение JSON по пути, заданному элементами пути, как text (\#>>)
        \item jsonb\_path\_exists -- выполняет поиск ключа как на заданном уровне, так и на произвольном 
        \item jsonb\_path\_match -- выполняет проверку предиката пути JSON для заданного значения JSON
        \item jsonb\_strip\_nulls -- удаления ключей с NULL-значениями
    \end{itemize}
\end{nota}

\begin{nota}{Изменение json и jsonb}
    \begin{itemize}
        \item Добавление/изменение элементов (jsonb\_set)
        \item Удаление элементов (-)
    \end{itemize}
\end{nota}

\newpage

\subsection{Встроенные функции}

\begin{nota}{Типы функций}
    \begin{itemize}
        \item Обзор встроенных функций 
        \item Функции для работы с текстом 
        \item Функции для работы с датой/временем 
        \item Функции для работы с числами 
        \item Функции преобразования и форматирования 
        \item Функции для работы с NULL 
        \item Системные информаицонные функции
    \end{itemize}
\end{nota}

\begin{nota}{Обзор встроенных функций}
    PostgreSQL предоставляет широкий набор встроенных функций, работающих со встроенными типами данных

    Все встроенные функции разделяются на стандартные функции SQL92 и функции в стиле PostgreSQL

    \begin{itemize}
        \item В функциях SQL92 аргументы разделяются специальными ключевыми словами SQL (такими, как FROM, FOR, USING)
        \item Функции в стиле PostgreSQL получают аргументы, разделенные запятыми
    \end{itemize}

    \textbf{Внимание:} круглые скобки не обязательны только для ряда функци SQL92
\end{nota}

\begin{nota}{Использование вложенных функций}
    Вызовы функций могут быть вложенными: тип данных, возвращаемый внутренней функцией должен быть совместим с типом соответствующего аргумента внешней функции

    Допускается вложение вызовов на произвольную глубину
\end{nota}

\begin{defin}{Строковые функции}
    В PostgreSQL существует множество разнообразных строковых функций, предназначенных для форматирования, анализа и сравнения строк. Под строками в данном контексте подразумеваются значения типов character, character varying и text
\end{defin}

\begin{nota}{Строковые функции}
    \begin{itemize}
        \item char\_length('string')
        \item character\_length('string')
        \item length('string')
        \item lower('string')
        \item upper('string')
        \item strpos('string', 'substring')
        \item position('substring' in 'string')
        \item subst('string', from\_int[, count\_int])
        \item substring('string' [from int] [for int])
        \item substring('string' from 'шаблон POSIX')
        \item substring('string' from 'шаблон SQL' for 'спецсимвол')
        \item regexp\_matches('string', 'шаблон POSIX')
        \item repeat('string', count\_int)
        \item reverse('string')
        \item trim([leading|trailing|both]['characters'] from 'string')
        \item ltrim('string'[, 'characters'])
        \item rtrim('string'[, 'characters'])
        \item right('string', count\_int)
        \item left('string', count\_int)
        \item concat(arg1 [,arg2[,...]])
        \item concat\_ws('separator',arg1[,arg2[,...]])
        \item replace('string','old text','new text')
        \item translate('string,'old text','new text')
        \item overlay('string' placing 'substring' from int [for int])
        \item regexp\_replace('string','шаблон POSIX','replacement')
        \item split\_part('string' text, 'delimiter', item\_int)
        \item regexp\_split\_to\_array('string','шаблон POSIX')
    \end{itemize}
\end{nota}

\begin{nota}{Использование шаблонов}
    Для определения шаблонов в PostgreSQL поддерживается два типа регулярных выражений:

    \begin{itemize}
        \item Регулярные выражения в стиле SQL 
        \item Регулярные выражения POSIX
    \end{itemize}
\end{nota}

\begin{nota}{Регулярные выражения в стиле SQL}
    Для определения шаблона в стиле SQL используются:

    \begin{itemize}
        \item \_ -- любой один символ -- '\_етров' => 'Ветров', 'Петров' и т.д.
        \item \% -- любая строка, содержащая ноль или более символов -- 'компьютер\%' => 'компьютер', 'компьютеры', 'компьютерный' и т.д.
    \end{itemize}
\end{nota}

\begin{defin}{Функция format}
    Функция format выдает текст, отформатированный в соответствии со строкой формата 

\begin{lstlisting}
format(formatstr text [, formatarg "any" [, ...]])
\end{lstlisting}

    formatstr -- спецификатор формата 

    \begin{itemize}
        \item позиция -- строка вида n\$, где n -- индекс выводимого аргумента. Если позиция опускается, по умолчанию используется следующий аргумент по поярдку
        \item Флаги -- поддерживается только знак минус, который выравнивает результат спецификатора по левому краю если определена ширина
        \item Ширина -- минимальное число символов, которое будет занимать результат данного спецификатора
        \item Тип спецификатора -- определяет преобразование соответствующего выводимого значения
        
        \begin{itemize}
            \item S -- строка
            \item I -- SQL-идентификатор, при необходимости заключается в кавычки 
            \item L -- значение аргумента заключается в апострофы, как строка SQL
        \end{itemize}
    \end{itemize}
\end{defin}

\begin{nota}{Функции даты/времени}
    \begin{itemize}
        \item age(timestamp)
        \item age(timestamp, timestamp)
        \item current\_date
        \item current\_time 
        \item current\_time(integer)
        \item current\_timestamp
        \item current\_timestamp(integer)
        \item clock\_timestamp()
        \item now()
        \item localtime 
        \item localtimestamp
        \item date\_trunc('part', timestamp)
        \item date\_trunc(text, interval)
        \item date\_trunc('part', timestamp with time zone, 'time\_zone\_name')
        \item date\_part('part', timestamp)
        \item date\_part('part', interval)
        \item extract(part from timestamp)
        \item extract (part from interval)
        \item make\_date(year int, month int, day int)
        \item make\_time(hour int, min int, sec double precision)
        \item make\_timestamp(year int, month int, day int, hour int, min int, sec double precision)
    \end{itemize}
\end{nota}

\begin{Example}{Часовые пояса (timezone names)}
\begin{lstlisting}
select name, abbrev, uct_offset
from pg_timezone_names;
\end{lstlisting}

\begin{lstlisting}
SELECT TIMESTAMP '2022-02-16 20:38:40' AT 
    TIME ZONE 'America/Denver';
\end{lstlisting}

\begin{lstlisting}
select date_trunc('day', timestamptz '2022-10-16 20:38:40+00', 'Australia/Sydney'),
    date_trunc('day', timestamptz '2022-10-16 20:38:40+00', 'US/Samoa');
\end{lstlisting}
\end{Example}

\begin{Example}{Функции даты/времени}
\begin{lstlisting}
SELECT age('2022-06-25 12:34'::timestamp),
    clock_timestamp( ),
    clock_timestamp( );
\end{lstlisting}

\begin{lstlisting}
SELECT extract(hour from timestamp '2001-02-16 20:38:40'),
    date_part('hour', timestamp '2001-02-16 20:38:40');
\end{lstlisting}
\end{Example}

\begin{nota}{Математические функции}
    \begin{itemize}
        \item random()
        \item ceil(dp/numeric)
        \item ceiling(dp/numeric)
        \item floor(dp/numeric)
        \item round(dp/numeric)
        \item round(v numeric, s integer)
        \item trunc(dp/numeric)
        \item trunc(v numeric, s integer)
        \item power(a dp, b dp)
        \item power(a numeric, b numeric)
        \item abs(x)
        \item div(y numeric, x numeric)
        \item mod(y, x)
        \item sqrt(dp/numeric)
        \item cbrt(dp)
    \end{itemize}
\end{nota}

\begin{defin}{Преобразование типов}
    Для явного преобразования типов используется 

    \begin{itemize}
        \item Функция CAST (стандарт SQL) -- CAST(выражение AS type)
        \item Конструкция :: (PostgreSQL) -- выражение::type
        \item Синтаксис функций приведения к типу -- typename(выражение). Будет работать только для типов, имена которых являются допустимыми именами функций!
    \end{itemize}
\end{defin}

\begin{Remark}{Внимание}
    Приведение будет успешным, только если определен подходящий оператор преобразования типов 

    Явно приведение типа можно опустить, если возможно однозначно определить, какой тип должно иметь выражение (неявное преобразование)

    Запись typename 'string' можно использовать только для указания типа простой текстовой константы; она не работает для массивов 
\end{Remark}

\begin{nota}{Функции форматирования}
    \begin{center}
        \begin{tabular}{|m{9em}|m{12em}|m{15em}|}
            \hline
            Функция & Описание & Пример \\
            \hline
            to\_char(timestamp, text) & Преобразует время в текст & to\_char(current\_timestamp, 'HH12:MI:SS') \\
            \hline
            to\_char(interval, text) & Преобразует интервал в текст & to\_char(interval '15h 2m 12s', 'HH24:MI:SS') \\
            \hline
            to\_char(int, text) & Преобразует целое число в текст & to\_char(125, '999') \\
            \hline
            to\_char(double precision, text) & Преобразует плавающее одинарной/двойной точности в текст & to\_char(125.8::real, '999D9') \\
            \hline
            to\_char(numeric, text) & Преобразует числовое значение в текст & to\_char(-125.8, '999D99S') \\
            \hline 
            to\_date(text, text) & Преобразует текст в дату & to\_date('05 Dec 2000', 'DD Mon YYYY') \\
            \hline
            to\_number(text, text) & Преобразует текст в число & to\_number('12,454.8-', '99G999D9S') \\
            \hline
            to\_timestamp(text, text) & Преобразует строку во время & to\_timestamp('05 Dec 2000', 'DD Mon YYYY') \\
            \hline
        \end{tabular}
    \end{center}
\end{nota}

\begin{defin}{Функции для работы с NULL}
    Функция COALESCE возвращает первый попавшийся аргумент, отличный от NULL. Если же все аргументы равны NULL, результатом тоже будет NULL 

    Функция NULLIF выдает значение NULL, если занчение1 равно значение2; в противном случае она возвращает значение1. Это может быть полезно для реализации обратной операции к COALESCE
\end{defin}

\begin{nota}{Функции получения информации о сеансе}
    \begin{center}
        \begin{tabular}{|m{10em}|m{4em}|m{20em}|}
            \hline 
            Имя & Тип рез. & Описание \\
            \hline 
            current\_catalog current\_database() & name & Имя текущей базы данных (в стандарте SQL она называется каталогом) \\
            \hline 
            current\_user current\_role & name & Имя пользователя в текущем контексте выполнения \\
            \hline 
            session\_user & name & Имя пользователя сеанса \\
            \hline 
            current\_schema[()] & name & Имя текущей схемы \\
            \hline 
            pg\_backend\_pid() & int & Код серверного процесса, обслуживающего текущий сеанс \\
            \hline 
            pg\_blocking\_pids(int) & int[] & Идентификаторы процессов, не дающих серверному процессу с определенным ID получить блокировку \\
            \hline 
            version() & text & Информация о версии PostgreSQL \\
            \hline
        \end{tabular}
    \end{center}
\end{nota}

\newpage 

\subsection{Физическое хранение БД. Низкий уровень}

\begin{nota}{Физическое хранение базы данных}
    Для каждой БД существует подкаталог внутри каталога ТП по умолчанию (PGData/base) и каталогов ТП, в которых размещены объекты БД: име подкаталога = OID БД (pg\_database). Этот подкаталог -- по умолчанию место хранения файлов БД 

    Все файлы объектов одной БД, принадлежащих одному табличному пространству, буудт помещены в один каталог
\end{nota}

\begin{nota}{Идентификация файлов связанных с таблицами и индексами}
    Каждый объект БД, хранящий данные (таблица, индекс, последовательность, материализованное представление), представляет собой набор файлов, расположенных в каталоге БД 

    Каждый объект имеет уникальный идентификатор объекта БД -- OID
    
    Файлы идентифицируются с помощью relfilenode. Значение relfilenode таблиц и индексов изначально совпадают с соответствующими OID. Выполнение команд TRUNCATE, REINDEX, CLUSTER -- изменяет значения relfilenode таблиц и индексов
\end{nota}

\begin{nota}{Типы файлов (слои)}
    Каждой объекту БД, хранящему данные, соответствует несколько типов файлов (слоев):

    \begin{itemize}
        \item Основной слой (main) -- данные 
        \item Слой инициализации (init)
        \item Карта свободного пространства (fsm -- free space map)
        \item Карта видимости (vm -- visibility map)
    \end{itemize}

    Каждый тип файла содержат определенный вид данных 

    Каждый слой состоит из одного или нескольких файлов-сегментов размером до 1Гб. Когда размер файла превышает 1Гб, PostgreSQL создает новый файл с именем refilenode.1. Изменение размера сегмета (--with-segsize) -- только при сборке 
\end{nota}

\begin{nota}{Слои данных}
    Основной слой (main) -- это данные: версии строк таблиц или строки индексов. Существует для всех объектов, хранящих данные. Имена файлов состоят только из идентификатора -- refilenode, refilenode.1 \dots 

    Слой инициализации (init) -- существует только для нежурналируемых таблиц (UNLOGGED) и их индексов:

    \begin{itemize}
        \item Действия над такими таблицами не записываются в WAL-log 
        \item При восстановлении (recovery) PostgreSQL удаляет все слои таких объектов и записывает слой инициализации на место основного слоя (получается пустая таблица)
        \item Имена файлов имеют окончание \_init -- refilenode\_init
    \end{itemize}
\end{nota}

\begin{nota}{Организация данных в куче}
    Файлы разделены на страницы (блоки). Страница по умолчанию имеет размер 8Кб. Изменение размера блока (--with-blocksize) -- только при сборке (16Кб или 32Кб). Собранный и запущенный кластер может работать со страницами только одного размера 

    Табличные данные на страницах файла хранятся неупорядоченно -- куча (HEAP). Записи (Tuple) кучи идентифицируются с помощью TID -- tuple id. TID состоит из номера файла, номера блока в файле и позиции строки внутри блока 

    Для получения доступа к записям используется система указателей, размещаемых в начале страниц. Указатели имеют фиксированный размер (4 байта). Наличие указателей позволяет перемещать строку внутри страницы, не ломая индексные ссылки.

    Кортеж идентифицируется внутренним идентификатором кортежа (TID): номер страницы, номер указателя строки 
\end{nota}

\begin{nota}{Структура страницы}
    Страница разделена на области. Границы областей страницы записаны в ее заголовке:

    \begin{itemize}
        \item 0 -- начало заголовка страницы 
        \item 24 -- начало указателей на версии строк 
        \item lower -- начало свободного места 
        \item upper -- начало данных (версий строк)
        \item special -- начало специальных данных (только для индексов)
        \item pagesize -- конец страницы
    \end{itemize}
\end{nota}

\begin{nota}{Структура версии строки}
    Все версии строк таблицы имеют одинаковую структуру: 

    \begin{itemize}
        \item Заголовок фиксированного размера -- 23 байта 
        \item Необязательная битовая карта пустых (NULL) значений 
        \item Необязательное поле идентификатора объекта 
        \item Пользовательские данные 
    \end{itemize}

    Заголовок содержит служебну информация:

    \begin{itemize}
        \item t\_xmin -- идентификатор транзакции (XID), создавшей кортеж 
        \item t\_xmax -- идентификатор транзакции, удалившей кортеж
        \item t\_cid -- идентификатор команды внутри транзакции (CID), создавшей и/или удалившей кортеж 
        \item infomask -- набор служебных битов (флагов), определяющих свойства версии 
        \item ctid -- внутренний казатель на более новую версию кортежа. У самой новой (актуальной) версии строки citd ссылается на саму эту версию 
    \end{itemize}
\end{nota}

\begin{nota}{Инспектирование страиц}
    Для получения информаици о структуре и содержании страниц используется стандартное расширение pageinspect

    При установке расширения становятся доступны функции, позволяющие исследовать страницы баз данных на низком уровне:

    \begin{itemize}
        \item get\_raw\_page(relname text, blkno int) -- возвращает содержимое указанной страницы из основного слоя в bytea 
        \item page\_header(page bytea) -- возвращает набор полей заголовка указанной страницы 
        \item heap\_page\_items(page bytea) -- возвращает кортежи, их заголовки и содержимое ItemIdData указанной страницы 
        \item page\_checksum(page bytea, blkno int4) -- возвращает контрольную сумму указанной страницы 
    \end{itemize}
\end{nota}

\begin{nota}{Просмотр содержимого заголовка}
    Получение информации из заголовка нулевой страницы из таблицы pg\_class 

    Получение контрольной суммы 0-й страницы, которая должна была бы находиться в заданном блоке 
\end{nota}

\begin{nota}{Служебные слои}
    Карта свободного пространства (fsm) -- free space map 

    \begin{itemize}
        \item Хранит информацию об объеме свободного места на страницах после очистки 
        \item Используется при вставке новых версий строк 
        \item Имена файлов имеют окончание \_fsm -- relfilenode\_fsm, relfilenode\_fsm.1
        \item Существует для всех объектов
    \end{itemize}
\end{nota}

\begin{nota}{Служебные слои}
    Карта видимости (vm) -- битовая карта видимости. Появляется только после выполнения очистки. Отмечает чистые страницы, на которых все версии строк видны во всех снимках. Существует только для таблиц 

    Используется для оптимизации работы процесса очисти (отмеченные страницы не нуждаются в очистке); ускорения индексного доступа 

    Имена файлов имеют окончание \_vm -- relfilenode\_vm. Начиная с версии 9.6 в этом же слое хранится и карта заморозки
\end{nota}

\newpage 

\subsection{Хранение больших данных}

\begin{nota}{Хранение длинных строк}
    Физический размер одной записи не может занимать больше одной страницы данных 

    Для длинных версий строк, размер которых превышает 2Кб, автоматически применяется технология TOAST -- The Oversize Attributes Storage Technique: PostgreSQL сжимает и/или разбивает на несколько физических строк и выносит значения поля за пределы таблицы. Это происходит незаметно для пользователя и на большую часть кода сервера влияет незначительно 

    Для каждой таблицы с потенциально большими полями автоматически создается отдельная TOAST-таблица (и к ней специальный индекс)
\end{nota}

\begin{nota}{TOAST-таблица}
    Каждая TOAST-таблица содержит разделенные на части (chunk) длинные атрибуты записи основной таблицы. Запись в основной таблице будет содержать указатель (chunk\_id), указывающий на нужный фрагмент в TOAST-таблице. Одному chunk\_id может соответствовать несколько строк TOAST-таблице 

    TOAST-таблица состоит из 3 столбцов:

    \begin{itemize}
        \item chunk\_id -- номер чанка, на который ссылается куча 
        \item chunk\_seq -- номер кжадого сегмента чанка 
        \item chunk\_data -- часть данных каждого сегмента 
    \end{itemize}

    TOAST-таблица читается только при обращении к длинному атрибуту. Собственная версионность: если обновление данных не затрагивает длинное значение, новая версия строки будет ссылаться на то же самое значение в TOAST-таблице

    TOAST-таблица для базовой таблицы -- в схеме pg\_toast, для временной -- в схеме pg\_toast\_temp
\end{nota}

\begin{nota}{Параметры TOAST}
    КОд обработки TOAST срабатывает, когда размер записи превышает toast\_tuple\_threshold байт (по умолчанию 2Кб)

    Параметр toast\_tuple\_target указывает до какого размера в байтах TOAST должен пытаться сжать запись (по умолчанию 2Кб). Значение данного параметра можно переопределить на уровне таблицы 

    Ни toast\_tuple\_threshold, ни toast\_tuple\_target не являются жестким ограничением на максимальный размер кортежа 
\end{nota}

\begin{nota}{Стратегия обработки больших данных}
    Атрибут STORAGE столбца таблицы определяет стратегию обработки:

    \begin{itemize}
        \item plain -- TOAST не применяется (тип имеет фиксированную длину)
        \item main -- приоритет сжатия. Отдельное хранение -- как крайняя мера 
        \item extended -- допускается как сжатие, так и отдельное хранение 
        \item external -- только отдельное хранение без сжатия. Этот режим можно использовать для повышения производительности (избегая сжатия/распаковки) за счет более высокого потребления дискового пространства
    \end{itemize}
\end{nota}

\begin{nota}{TOAST-able типы данных}
    Стратегия хранения конкретного типа данных определяет стратегию обработки 

    Информаиця о типе данных и его характеристики хранится в таблице pg\_catalog.pg\_type 

    Стратегии хранения:

    \begin{itemize}
        \item p = PLAIN 
        \item x = EXTENDED 
        \item e = EXTERNAL (по умолчанию эта стратегия не используется ни для каких типов данных)
        \item m = MAIN
    \end{itemize}
\end{nota}

\begin{nota}{TOAST}
    PostgreSQL стремится к тому, чтобы на странице помещалось хотя бы 4 строки 

    Если размер строки превышает $\frac{1}{4}$ страницы с учетом заголовка, к части значений необходимо применить TOAST: 

    \begin{enumerate}
        \item Анализ атрибутов со стратегиями external и extended 
        
        \begin{itemize}
            \item Extended-атрибуты пытается сжать и, если занчение превосходит $\frac{1}{4}$ страницы, оно отправляется в TOAST-таблицу 
            \item External-атрибуты обрабатываются так же, но не сжимаются 
        \end{itemize}

        \item Если это не помогло, осуществляется попытка сжать атрибуты со стратегией main, оставив их на табличной странице 
        \item Если строка все равно недостаточно коротка, main-атрибуты отправляются в TOAST-таблицу
    \end{enumerate}
\end{nota}

\begin{Remark}{Особенность}
    Если при определении столбцов таблицы PostgreSQL видит, что размер строки не может превысить TOAST\_TUPLE\_THRESHOLD, TOAST-таблица не создается 

    Если вы смените тип какого-либо столбца, в результате чего размер записи увеличится -- будет создана TOAST-таблица 

    Если снова сменить тип -- СУБД удалит TOAST-таблицу 
\end{Remark}

\begin{nota}{Алгоритмы сжатия}
    Для сжатия строк поддерживается два алгоритма:

    \begin{itemize}
        \item PGLZ -- используется по умолчанию 
        \item LZ4 -- доступен, если PostgreSQL был собран с флагом --with-lz4
    \end{itemize}

    LZ4 сжимает данные хуже других алгоритмов, но он очень быстрый 

    Особенность PGLZ -- если ему не удается сжать первые 1024 байта входных даннхы, алгоритм сдается и гвоорит, что эти данные несжимаемые. Если у вас какие-то особые данные, первые байты которых плохо сжимаются, иметь смысл дописать к ним в начале нулевых байт 
\end{nota}

\newpage

\subsection{Планировщик запросов}

\begin{defin}{Планировщик запросов}
    В PostgreSQL используется планировщик запросов, основанный на стоимости 

    Основная задача -- построение плана выполнения запроса с наименьшей оценочной стоимостью выполнения 

    \begin{itemize}
        \item Объем ресурсов ОП 
        \item Объем ресурсов ЦП
        \item Для приложений работающих с OLTP БД скорость выполнения запроса не должна превышать десятки миллисекунд (в худшем случае сотни миллисекунд)
    \end{itemize}

    Планировщик при построении плана выполнения запроса:

    \begin{itemize}
        \item Использу статистические данные оценивает селективность предикатов 
        \item Выполняет анализ различных методов доступа к данным 
        \item Для многотабличных запросов выполняет анализ способов соединений наборов записей 
    \end{itemize}
\end{defin}

\begin{nota}{Селективность предикатов}
    Предикаты -- выражения, которые оцениваются как истинные или ложные. Используются в предложениях JOIN, WHERE, HAVING 

    Избирательность (селективность) предикатов 

    \begin{itemize}
        \item Процент строк таблицы, соответствующих предикату 
        \item Высокая избирательность = низкий процент возвращаемых строк 
        \item Низкая избирательность = высокий процент возвращаемых строк
    \end{itemize}

    Селективность при оптимизации запросов используется для выбора метода доступа к данным и операций соединения в многотабличных запросах 
\end{nota}

\begin{defin}{EXPLAIN}
    Чтобы узнать, какой план был выбран планировщиком для запроса, используется команда EXPLAIN 

    EXLAIN query 

    \begin{itemize}
        \item Позволяет посмотреть на план выполнения без фактического выполнения запроса (оценочный план)
        \item cost -- сумма затрат на работу с диском (чтение/запись) и оценка CPU: первое значение -- затраты на получение первой строки; второе -- затраты на получение всех строк
        \item rows -- приблизительное количество возвращаемых строк 
        \item width -- средний размер одной строки в байтах 
    \end{itemize}

    EXPLAIN (ANALYZE) query 

    \begin{itemize}
        \item Фактически выполняет запрос и отображает результат, полученный на реальных данных 
        \item actual time -- реальное время в миллисекундах, затраченное для получения первой строки и всех строк соответственно 
        \item rows -- реальное количество полученных строк 
        \item loops -- сколько раз пришлось выполнить операцию 
        \item Execution Time -- общее время выполнения запроса 
    \end{itemize}

    EXPLAIN (ANALYZE, BUFFERS) query 

    \begin{itemize}
        \item Позволяет посмотреть что происходит на физическом уровне при выполнении запроса 
        \item Buffers: shared read -- количество блоков, считанное с диска 
        \item Buffers: shared hit -- количество блоков, считанных из кэша PostgreSQL
        \item Объем кэша определяется параметром shared\_buffers
        \item Sort Method: external merge Disk -- при сортировке используется временный файл на диске 
        \item Sort Method: quicksort memory -- сортировка целиков проведена в оперативной памяти 
    \end{itemize}

    EXPLAIN (SETTINGS) query 

    \begin{itemize}
        \item Добавляет в выходные данные EXPLAIN параметры конфигурации, отличные от параметров по умолчанию (которые плияют на планирование запросов)
        \item Добавлен в PostgreSQL v12 (2019) и по умолчанию отключен 
    \end{itemize}
\end{defin}

\newpage 

\subsection{Методы доступа к данным}

\begin{nota}{Методы доступа к данным}
    Метод доступа характеризует способ, используемый для прсомотра таблиц с целью извлечения только тех записей, которые соответствуют условиям запроса 

    \begin{itemize}
        \item Последовательное сканирование (Seq Scan) (без использования индекса)
        \item Индексное сканирование (Index Scan)
        \item Сканирование битовой карты (Bitmap Scan)
        \item Исключительно индексное сканирование (Index Only Scan)
    \end{itemize}
\end{nota}

\begin{nota}{Доступ к данным в куче}
    При выполнении запроса к данным в куче выполняется последовательное сканирование таблицы целиков. Полностью читаются файлы основного слоя таблицы. На каждой прочитанной странице: 

    \begin{itemize}
        \item Проверяется видимость каждой версии строки
        \item Версии, не удовлетворяющие условиям запроса, отбрасывается
    \end{itemize}

    Чтение происходит через буферный кеш. При последовательном сканировании больших таблиц используется буферное кольцо небольшого размера:

    \begin{itemize}
        \item Несколько процессов, одновременно сканирующих таблицу, могут присоединяться к кольцу и тем самым экономить дисковые чтения 
        \item Поэтому в общем случае сканирование может начаться не с начала файла 
    \end{itemize}
\end{nota}

\begin{defin}{Последовательное сканирование}
    Последовательное сканирование -- самый эффективный способ прочитать всю таблицу или значительную ее часть. Хорошо работает при низкой селективности запроса. Последовательное чтение выполняется быстрее, чем чтение страниц вразнобой. Это особенно верно для жестких дисков, где механическая операция подведения головки к дорожке занимает существенно больше времени, чем само чтение данных; в случае дисков SSD этот эффект менее выражен 

    Для поиска поднабора записей данный метод малоэффективен 

    Решение: нужно создать индекс
\end{defin}

\begin{defin}{Что такое индексы?}
    Индексы в PostgreSQL -- специальные объекты базы данных, предназначенные в основном для ускорения доступа к данным. Это вспомогательные структуры, сохраняемые в отдельных файлах. Их можно удалить и восстановить заново по информации в таблице. Индексы также служат для поддержки некоторых ограничений целостности

    Индекс устанавливает соответствие между ключом индекса (значением проиндексированного столбца) и TID записей, в которых это значение встречается. С помощью ключа можно быстро найти интересующие нас строки, без необходимости полного сканирования всей таблицы. Индекс, созданный по столбцу, участвующему в соединении двух таблиц, может позволить ускорить процесс выборки записей из таблиц
\end{defin}

\begin{Remark}{Издержки}
    Замедление операций модификации данных в таблицах
    
    \begin{itemize}
        \item При выполнении операций модификации над проиндексированными данными индексы должны быть перестроены в рамках той же транзакции
        \item Обновление полей таблицы, не входящих в состав ключа индекса, не приводит к перестроению индексов -- HOT (Heap-Only Tuple)
        \item Чем больше смещение профиля нагрузки в сторону увеличения записей по отношению к чтению, тем это более критично 
    \end{itemize} 

    Дополнительные объемы дискового пространства

    \begin{itemize}
        \item Размер совокупных индексных данных не должен превышать 0,5 размера таблицы 
    \end{itemize}

    Усложненное техническое обслуживание 

    \begin{itemize}
        \item Добавление новых версий строк при модификации данных -- Vacuum решает задачу для основных записей, но не для индексных 
        \item Индексы могут распухать (BLOAD) на часто изменяемых данных и их необходимо пересоздавать. Это требует тонкой работы, чтобы не устроить даун-тайм для всего сервиса 
    \end{itemize}

    Поддержкой индексов в актуальном состоянии занимается СУБД -- тратя ресурсы 
\end{Remark}

\begin{defin}{Индексное сканирование (Index scan)}
    Индексное сканирование (Index Scan) 

    \begin{itemize}
        \item На основе ключа индекса определяется TID 
        \item Происходит обращение к странице таблицы, на которую указывает TID, для получения версии строки 
        \item Проверяется ее видимость в соответствии с правилами многоверсионности, и возвращаются полученные данные 
        \item Процесс повторяется для каждого TID 
    \end{itemize}

    Индексное сканирование хорошо работает, если версии строк в таблице коррелированы с порядком, в котором метод доступа выдает идентификаторы 

    Используется:

    \begin{itemize}
        \item Для быстрого поиска по ключу 
        \item Для выдачи остортированного результата в том случае, когда порядок сортировки запроса совпдаает с порядком сортировки индексных записей 
        \item Для получения данных, которые присутствуют в индексе без обращения к таблице 
    \end{itemize}
\end{defin}

\begin{defin}{Bitmap Scan}
    При увеличении выборки возрастают шансы, что придется возвращаться к одной и той же табличной странице несколько раз 

    Сканирование битовой карты 

    \begin{itemize}
        \item Возвращаются все TID, соответствующие условию (узел Bitmap Index Scan)
        \item По ним строится битовая карта версий строк (exact)
        \item Затем версии строк читаются из таблицы (узел Bitmap Heap Scan) -- при этом каждая страница будет прочитана только один раз 
    \end{itemize}

    Размер битовой карты не может превышать размер work\_mem. Если выборка слишком велика -- строится грубая битовая карта страниц (lossy), содержащих хотя бы одну подходящую версию строки. Для создания более точной битовой карты -- увеличить размер work\_mem. При чтении страницы приходится перепроверять условия для каждой хранящеймя там строки (узел Recheck Cond)

    При выполнении фильтрации по нескольким проиндексированным полям таблицы, сканирование битовой карты позволяет (если оптимизатор сочтет это выгодным) использовать несколько индексов одновременно:

    \begin{itemize}
        \item Для каждого индекса строятся битовые карты версий строк 
        \item Если выражения соединены условием AND -- битовые карты логически побитово умножаются 
        \item Если выражения соединены условием OR -- битовые карты логически побитово складываются
    \end{itemize}
\end{defin}

\begin{defin}{Index Only Scan}
    Если все необходимые для запроса данныые находятся на индексных страницах, такой индекс называется покрывающим (covering). В этом случае оптимизатор может применить исключительно индексное сканирование (Index Only Scan)

    Для прокешированных данных результаты практически не отличаются от Index Scan 

    Индексы в PostgreSQL не содержат информации, позволяющей судить о видимости строк 

    \begin{itemize}
        \item Метод доступа возвращает все версии строк, попадающие под условие поиска, независимо от того, видны они текущей транзакции или нет 
        \item Если страница, на которую указывает TID отмечена в карте видимости -- видимость не проверяется 
        \item Если страница, на которую указывает TID, не отмечена в карте видимости выполняется проверка видимости строки на основании табличных данных 
    \end{itemize}

    Требуется регулярное выполнение очистки VACUUM. Оптимизатор учитывает число мертвых строк и может отказаться от использования исключительно индексного сканирования. Число вынужденных обращений к таблице (Heap Fetches) можно узнать, используя команду explain analyze 
\end{defin}

\begin{defin}{Parallel Index Scan}
    Индексный доступ может выполняться в параллельном режиме:

    \begin{itemize}
        \item Сначала ведущий процесс (gather) спускается от корня дерева к листовой странице 
        \item Затем рабочие процессы (parallel\_workers) выполняют параллельное чтение листовых страниц индекса, двигаясь по указателям 
    \end{itemize}

    Издержки:

    \begin{itemize}
        \item Процесс, прочитавший индексную страницу, выполняет и чтение необходимых табличных страниц 
        \item Если несколько индексных страниц, прочитанных разными процессами, содержат ссылку на одну и ту же табличную страницу -- ее прочитают несколько процессов (страница будет находиться в буферном кеше в одном экземпляре)
    \end{itemize}
\end{defin}

\begin{nota}{Число рабочих процессов}
    Равно нулю (параллельный план не строится), если размер выборки < min\_parallel\_index\_scan\_size (=512kB)

    Фиксировано, если для таблицы указан параметр хранения parallel\_workers

    Вычисляется по формуле 1 + [log 3 (размер выборки / min\_parallel\_index\_scan\_size)], но не больше, чем max\_parallel\_workers\_per\_gather
\end{nota}

\begin{nota}{Сранвения стоимости методов доступа}
    Каждый из методов доступа имеет свои преимущества и недостатки:

    \begin{itemize}
        \item Индексное сканирование зависит от корреляции между физически расположением версий строк и порядком, в котором индексный метод доступа выдает идентификаторы
        \item Сканирование только индекса сильно зависит от карты видимости 
        \item Сканирование по битовой карте при слабой корреляции существенно превосходит индексное сканирование 
        \item Последовательное сканирование не зависит от селективности и, начиная с некоторой доли выбираемых строк, обычно работает лучше остальных методов 
    \end{itemize}

    Планировщик выполняет серьезную работу по оценке эффективности каждого из методов в каждом конкретном случае. Чтобы эти оценки были близки к реальности, очень важна актуальная статистика 
\end{nota}

\begin{nota}{Параметры сервера}
    \begin{itemize}
        \item seq\_page\_cost (floating point) -- стоимость получения страницы при последовательном чтении. По умолчанию 1.0
        \item random\_page\_cost -- стоимость получения случайной страницы. По умолчанию 4.0
        \item Оба параметра могут быть изменены для tablespace (SSD) или когда данные целиком умещаются в памяти. Таким образом, можно для активной части базы в памяти иметь random\_page\_cost близкий к единице, а для архивных данных -- оставить значение по умолчанию 
        \item cpu\_tuple\_cost -- стоимость получения страницы данных из памяти. По умолчанию 0.01
        \item cpu\_index\_tuple\_cost -- то же самое, только для индекса. По умолчанию 0.005
        \item cpu\_operator\_cost -- стоимость обработки оператора или функции. По умолчанию 0.0025
    \end{itemize}

    Значение параметра effective\_cache\_size не влияет на выделение памяти, но подсказывает PostgreSQL, на какой общий размер кэша рассчитывать, включая кэш операционной системы. Чем выше это значение, тем большее предпочтение отдается индексам. Начать можно с 50-75\% от объема ОЗУ

    Параметры, включающие или отключающие использование планировщиком запросов соответствующих методов доступа:

    \begin{itemize}
        \item enable\_seqscan 
        \item enable\_indexscan
        \item enable\_indexonlyscan
        \item enable\_bitmapscan
    \end{itemize}

    Значение по умолчанию -- on. Если off -- препятствует планировщику использовать соответствующий метод доступа, если есть другие доступные методы 
\end{nota}

\newpage 

\subsection{Способы соединения}

\begin{nota}{Соединения}
    Очень часто запросы обращаются к данным из нескольких таблиц:

    \begin{itemize}
        \item Недостаточно получать данные с помощью соответствующих методов доступа 
        \item Необходимо соединять два и более наборов строк 
        \item Проверять наличие связных записей в соединяемых наборах 
    \end{itemize}

    При написании запроса используются логические операции соединения таблиц (JOIN и их производные). Выбор типа логической операции зависит от решаемой задачи. Порядок соединения таблиц не важен с точки зрения логики запроса

    Для реализации соединения таблиц PostgreSQL использует способы соединения наборов записей, учитывающие вопросы производительности. Наборы записей всегда соединяются попарно. Порядок соединения наборов записей может влиять на производительность 
\end{nota}

\begin{nota}{Типы соединений наборов записей}
    \begin{itemize}
        \item Соединение вложенными циклами (Nested Loop)
        \item Соединение хешированием (Hash Join)
        \item Соединение слиянием (Merge Join)
    \end{itemize}
\end{nota}

\begin{defin}{Nested Loop}
    Реализован в виде двух вложенных циклов. Для каждой записи первого (внешнего -- outer) набора проверяется условие соединения во втором (внутреннем -- inner) наборе. Процесс повторяется до тех пор, пока внешний набор не исчерпает все строки. Обращение к записям второго (внутреннего) набора осуществляется столько раз, сколько записей в первом (внешнем) наборе. Если отсутствует эффективный метод доступа для поиска соответствующих записей во втором наборе (отсуттсвует индекс) эффективность сильно снизится, так как придется просматривать большое количество ненужных записей 

    Данный тип объединения оптимизатор обычно предпочитает для небольших выборок 

    Единственный способ для соединений не по =

    Подходит для OUTER JOIN, EXISTS, NOT EXISTS. задает порядок соединения 

    \begin{enumerate}
        \item Nested Loop Left Join -- возвращает строки, даже если для левого набора записей не нашлось соответствия в правом наборе записей (LEFT JOIN)
        \item Nested Loop Anti Join -- возвращает записи одного набора в том случае, если для них не нашлось соответствия в другом наборе (NOT EXISTS, LEFT|RIGHT JOIN ... WHERE поле IS NULL)
        \item Nested Loop Semi Join -- возвращает строки одного набора, если для них нашлось хотя бы одно соответствие в другом наборе (EXISTS) (т.е. достаточно получить всего одну строку)
    \end{enumerate}

    Модификаций алгоритма вложенного цикла для правого (RIGHT) и полного (FULL) соединений не существует. Это связано с тем, что полный проход по второму набору строк может не выполняться 

    Соединение вложенным циклом может использоваться вв параллельных планах
\end{defin}

\begin{defin}{Соединение с индексированным вложенным циклом}
    Если для внутренней таблицы существует индекс, который может ускорить поиск записей, удовлетворяющих условию соединения, планировщик рассматривает возможность использования этого индекса для прямого поиска записей внутренней таблицы вместо последовательного сканирования -- indexed nested loop join 

    Если есть индекс внешней таблицы и его атрибуты участвуют в условии соединения, то его можно использовать для сканирования индекса вместо последовательного сканирования внешней таблицы. В частности, при наличии индекса, атрибутом которого может быть предикат доступа в предложении WHERE, диапазон поиска во внешней таблице сужается; следовательно, стоимость соединения с вложенным циклом может быть значительно снижена 
\end{defin}

\begin{defin}{Hash join}
    Реализация:

    \begin{itemize}
        \item По одному набору записей строится хеш-таблица на ключах соединения (узел Hash). Функция хеширования равномерно распределяет значения по ограниченному числу корзин хеш-таблицы -- по значению хеш-функции определяется номер корзины. Если равномерности не будет -- в одной корзине может образоваться список значений, что приведет к снижению производительности 
        \item Затем Postgres выполняет итерацию по второму набору записей: 
        
        \begin{itemize}
            \item Вычисляет хеш-функцию от значения полей, участвующих в условии соединения 
            \item Проверяет наличие соответствующего хеш-значения в хеш-таблице hash(table1.val)=hash(table2.val)
            \item Дополнительно проверяет значения полей, подходящие под условие соединения 
        \end{itemize}
    \end{itemize}

    Используется для соединений по =

    Для большой выборки оптимизатор предпочитает соединение хешированием. Зависит от порядка соединения -- внутренний набор должен быть меньше внешнего, чтобы минимизировать хеш-таблицу 

    Размер хеш-таблицы в памяти ограничен значением work\_mem x hash\_mem\_multiplier (начиная с 13 версии). В корзину помещаются хеш-код и все поля, которые входят в условие соединения или используются в запросе. Не следует использовать в запросе лишние поля, в том числе звездочку

    Если таблица не умещается в памяти:

    \begin{enumerate}
        \item Разбивает наборы записей на пакеты (Batches)
        \item Строит хеш-таблицу для одного пакета (work\_mem x hash\_mem\_multiplier)
        \item Остальные пакеты сохраняет во временные файлы (temp written)
        \item Выполняет сопоставление с записями второго набора 
        \item Если запись соответствует данному пакету -- она возвращается. Если строка принадлежит другому пакету, она сбрасывается на диск -- в свой временный файл
        \item Процедура повторяется для всех пакетов 
    \end{enumerate}
\end{defin}

\begin{nota}{Группировка и уникальные значения}
    Для выполнения группировки (GROUP BY) и устранения дубликатов (DISTINCT и операции со множествами без ALL) используются методы, схожие с методами соединения: один из способов выполнения состоит в том, чтобы построить хеш-таблицу по нужным полям и получить из нее уникальные значения
\end{nota}

\begin{defin}{Merge join}
    Для использования данного способа основным условием является соединение упорядоченных наборов записей

    \begin{itemize}
        \item Если наборы записей не отсортированы -- выполняет сортировку (дорогая операция)
        \item Сначала берет первые записи обоих наборов и сравнивает их между собой 
        \item Если значения совпадают -- читает следующую строку второго набора 
        \item Если значения не совпадают -- читает следующую строку того набора, для которого значение поля, по которому происходит соединение, меньше (один набор догоняет другой)
        \item Главное отличие -- нет правого и левого набора записей 
    \end{itemize}

    Алгоритм слияния возвращает результат соединения в отсортированном виде. ПОлученный набор записей может быть использован для соединения слиянием со следующим набором записей без дополнительной сортировки

    Подходит для outer join-ов. Не определяет жестко порядок соединения таблиц. Чуть ли не единственный способ реализовать full outer join 

    Если соединяемые наборы записей уже остортированы (например определны индексы) PostgreSQL может предпочесть данный способ соединению хешированием. Не требуются накладные расходы на простроение хеш-таблицы 

    Если требуется выполнение сортировки, то в зависимости от количества записей и объема work\_mem 

    \begin{itemize}
        \item Может быть выполнена быстрая сортировка (quick sort)
        \item Может быть применена частичная пирамидальная сортировка (top-N heapsort) если нужно отсортировать не весь набор данных (LIMIT)
        \item Если данные уже отсортированы, но не по всем ключам, может быть использована инкрементальная сортировка 
        \item Либо может быть отдано предпочтение соединению хешированием 
    \end{itemize}
\end{defin}

\begin{Remark}{Другие варианты}
    Подобно объединению с вложенным циклом, соединение слиянием в PostgreSQL fnкже имеет варианты, на основе которых может выполняться сканирование индекса внешней таблицы 
\end{Remark}

\begin{nota}{Параметры сервера связанные со способами объединения}
    Параметры, включающие или отключающие использование планировщиком запросов соответствующих способов объединения:

    \begin{itemize}
        \item enable\_nestloop
        \item enable\_hashjoin
        \item enable\_mergejoin
    \end{itemize}

    Значение по умолчанию -- on. Если off -- препятствует планировщику использовать соответствующий способ объединения, если есть другие доступные способы
\end{nota}

\newpage

\section{Лекция 3. Запросы к нескольким таблицам}

\subsection{Запросы к нескольким таблицам}

\begin{defin}{Предложение FROM}
    В предложении FROM перечисляются один или несколько источников данных, используемых для формирования результирующей выборки 

    При использовании нескольких источников необходимо указать тип их соединения:

    \begin{itemize}
        \item CROSS JOIN 
        \item\ [ INNER ] JOIN 
        \item LEFT [ OUTER ] JOIN
        \item RIGHT [ OUTER ] JOIN
        \item FULL [ OUTER ] JOIN
        \item NATURAL JOIN 
        \item USING
    \end{itemize}
\end{defin}

\begin{defin}{CROSS JOIN -- перекрестное соединение}
    CROSS JOIN -- возвращает декартово произведение таблиц. Может быть заменено списком таблиц через запятую в разделе FROM

\begin{lstlisting}
FROM tableA CROSS JOIN tableB
\end{lstlisting}
\end{defin}

\begin{nota}{Соединение посредством предиката}
\begin{lstlisting}
FROM tableA [type_of_join] JOIN tableB ON predicate
\end{lstlisting}

    \begin{center}
        \begin{tabular}{|m{9em}|m{29em}|}
            \hline 
            Тип соединения & Описание \\ 
            \hline
            INNER & Используется для соединения строк из обеих таблиц на основе заданного предиката. Используется по умолчанию, когда тип соединения явно не задан \\
            \hline 
            LEFT [ OUTER ] & "Левое (внешнее)"\ Включает в себя все строки из левой таблицы A и те строки из правой таблицы B, для которых выполняется условие предиката. Для строк из таблицы A, для которых не найдено соответствия в таблице B, в столбцы, извлекаемые из таблицы B, заносятся значения NULL \\
            \hline 
            RIGHT [ OUTER ] & "Правое (внешнее)"\ Включает в себя все строки из правой таблицы B и те строки из левой таблицы A, для которых выполняется условие предиката. Для строк из таблицы B, для которых не найдено соответствия в таблице A, в столбцы, извлекаемые из таблицы A, заносятся значения NULL \\
            \hline
            FULL [ OUTER ] & "Полное (внешнее)"\ Это комбинация левого и правого соединений. В полное соединение включаются все строки из обеих таблиц. Для совпадающих строк поля заполняются реальными значениями, для несовпадающих строк поля заполняются в соответствии с правилами левого и правого соединений \\
            \hline
        \end{tabular}
    \end{center}
\end{nota}

\begin{Remark}{}
    Вместо ON можно использовать USING при условии совпадения названий столбцов, используемых для соединения
\end{Remark}

\begin{defin}{SELF JOIN}
    Для объединения записей внутри одной таблицы необходимо использовать объединение таблицы со своей копией. Для создания копии используются псевдонимы таблиц
\end{defin}

\newpage 

\subsection{Использование операторов наборов записей}

\begin{nota}{Требования к наборам записей}
    Оба набора должны иметь одинаковое количество столбцов, совместивых по типу данных 

    ORDER BY не допускается во входных запросах, но может использоваться для сортировки результирующего набора 

    NULL значения считаются равными при сравнении наборов
\end{nota}

\begin{defin}{UNION и UNION ALL}
    UNION возвращает результирующий набор уникальных строк, объединенных из двух входных наборов. Дубликаты удаляются при обработке запроса (влияет на производительность) 

    UNION ALL возвращает результирующий набор со всеми строками из двух входных наборов. Чтобы избежать потери производительности, вызванной фильтрацией дубликатов, используйте UNION ALL вместо UNION всякий раз, когда это позволяют требования
\end{defin}

\begin{defin}{INTERSECT}
    INTERSECT возвращает уникальный результирующий набор строк, которые присутствуют в обоих входных наборах
\end{defin}

\begin{defin}{EXCEPT (MINUS)}
    EXCEPT возвращает только уникальные строки, которые присутствуют в левом наборе, но нет в правом. Порядок, в котором указаны наборы, имеет значение
\end{defin}

\newpage 

\section{Лекция 4.}

\subsection{Запросы с группировкой}

\begin{defin}{Агрегатные функции}
    Работают с набором значений столбца, возвращают скалярное значение (без имени столбца), игнорируют NULL-значения, кроме COUNT(*)

    Могут использоваться в:

    \begin{enumerate}
        \item Предложениях SELECT, HAVING и ORDER BY
        \item Часто используются с предложением GROUP BY
    \end{enumerate}
\end{defin}

\begin{nota}{Категории агрегатных функций}
    \begin{itemize}
        \item Общие 
        
        \begin{itemize}
            \item sum 
            \item min 
            \item max 
            \item avg 
            \item count 
            \item string\_agg
        \end{itemize}

        \item Статистические 
        
        \begin{itemize}
            \item corr 
            \item covar\_ 
            \item regr\_ 
            \item stddev\_ 
            \item var\_ 
        \end{itemize}

        \item Дополнительные 
        
        \begin{itemize}
            \item grouping
            \item array\_agg
            \item bit\_and 
            \item bit\_or
            \item bool\_and
            \item bool\_or
            \item json\_agg
            \item json\_object\_agg
        \end{itemize}
    \end{itemize}
\end{nota}

\begin{defin}{Агрегатные выражения}
    Агрегатное выражение представляет собой применение агрегатной функции к строкам, выбранным запросом 

    Агрегатное выражение может записываться следующим образом:

\begin{lstlisting}
aggr ([ALL] expr [, ...] [order_by]) [FILTER (WHERE predicate)]
aggr (DISTINCT expr [, ...] [order_by]) [FILTER (WHERE predicate)]
aggr (*) [FILTER (WHERE predicate)]
\end{lstlisting}
\end{defin}

\begin{nota}{Использование DISTINCT в агрегатных функциях}
    Используйте DISTINCT с агрегатными функциями, чтобы агрегировать только уникальные значения. Агрегаты с DISTINCT исключают повторяющиеся значения, а не строки (в отличие от SELECT DISTINCT)
\end{nota}

\begin{nota}{Обработка NULL-значений}
    Большинство агрегатных функций игнорирует NULL

    \begin{itemize}
        \item COUNT(<column>) -- игнорирует NULL-значения
        \item COUNT(*) -- подсчитывает все строки 
    \end{itemize}

    NULL может давать неправильные результаты (например, при использовании AVG). Используйте COALESCE для замены NULL-значений перед агрегированием
\end{nota}

\begin{defin}{Предложение FILTER}
    Если добавлено предложение FILTER, агрегатной функции подаются только те входные строки, для которых условие фильтра вычисляется как истинное; другие строки отбрасываются
\end{defin}

\begin{defin}{Предложение ORDER\_BY}
    Результат выполнения некоторых агрегатных функций (таких как array\_agg и string\_agg) зависит от порядка данных 

    Для задания нужного порядка необходимо добавить предложение order\_by. Данное предложение выполняет сортировку на основе исходных столбцов. Нельзя использовать имена результирующих столбцов или их числовые индексы 
\end{defin}

\begin{nota}{Использование GROUP BY}
    GROUP BY создает группы из исходных записей в соответствии с уникальной комбинацией значений, указанных в предложении GROUP BY. Детальные строки теряются после обработки предложения GROUP BY. Если запрос использует GROUP BY, все последующие этапы работают с группами, а не с исходными данными

    HAVING, SELECT и ORDER BY должны возвращать одно значение для каждой группы. Все столбцы в SELECT, HAVING и ORDER BY должны появляться в предложении GROUP BY или быть входными данными для агрегатных выражений 
\end{nota}

\begin{defin}{GROUPING SETS}
    Оператор GROUPING SETS -- это расширение предложения GROUP BY 

    GROUPING SETS группирует записи на основе задаваемых пользователем наборов для группировки. Наборы для группировки -- должны включать в себя столбцы, по которым вы группируете с помощью предложения GROUP BY. Набор для группировки обозначается списком столбцов, разделенных запятыми, заключенных в круглые скобки
\end{defin}

\begin{defin}{CUBE}
    CUBE -- это расширение предложения GROUP BY 
    
    CUBE позволяет создавать все возможные группы на основе указанных столбцов измерений 
\end{defin}

\begin{defin}{ROLLUP}
    В отличие от CUBE, ROLLUP не генерирует все возможные группы на основе указанных столбцов 

    ROLLUP предполагает иерархию входных столбцов и генерирует все группы, которые имеют смысл с учетом иерархии. По этой причине ROLLUP часто используется для создания промежуточных и общих итогов отчетов 
\end{defin}

\begin{defin}{Функция GROUPING}
    Функция GROUPING возвращает целочисленную битовую маску, показывающую, какие аргументы не вошли в текущий набор группирования: бит равен 0 -- если аргумент является членом текущего набора группирования, и 1 -- если аргумент не является членом текущего набора группирования

    Аргументы функции GROUPING должны в точности соответствовать выражениям, заданным в предложении GROUP BY 
\end{defin}

\newpage 

\subsection{Использование оконных функций}

\begin{Remark}{Наборы или курсоры?}
    Часто решения для запроса данных на основе SQL делят на два вида: основанные на наборах записей и основанные на курсорах с итеративным проходом по записям 

    Наиболее эффективно -- обрабатывать наборы записей: таблица представляет собой набор неупорядоченных данных, сохраняются реляционные принципы обработки 

    Язык SQL никак не связан с конкретной физической реализацией в ядре СУБД. Задача физического уровня -- определить, как выполнить логический запрос, и максимально быстро вернуть правильный результат 
\end{Remark}

\begin{nota}{Зачем нужны оконные функции}
    Оконные функции -- это мощнейший инструмент для анализа данных, который с легкостью помогает решать множество задач 

    Отличие от агрегатных функций:

    \begin{itemize}
        \item Групповые запросы формируют информацию в виде агрегатов, но при этом теряются детали (уменьшают количество строк)
        \item Оконные функции позволяют использование как детальных данных, так и агрегатов (не уменьшают количество строк)
        \item Результаты работы оконных функций просто добавляются к результирующей выборке в виде нового столбца
    \end{itemize}

    Этот функционал очень полезен для построения аналитических отчетов, расчета скользящего среднего и нарастающих итогов, а также для расчетов различных моделей атрибуции 
\end{nota}

\begin{nota}{Задачи решаемые с помощью оконных функций}
    \begin{itemize}
        \item Ранжирование (всевозможные рейтинги)
        \item Сравнение со смещением (соседние элементы и границы)
        \item Агрегация (сумма и среднее)
        \item Скользящие агрегаты (сумма и среднее в динамике)
    \end{itemize}
\end{nota}

\begin{defin}{OVER}
    При использовании инструкции OVER() без предложений окном будет весь набор данных 
\end{defin}

\begin{defin}{Предложение PARTITION BY}
    Предложение PARTITION BY делит строки на несколько групп или разделов, к которым применяется оконная функция. Определяет столбец (столбцы), по которому будет производиться разделение набора строк на окна 

    Предложение PARTITION BY является необязательным 

    Если вы пропустите предложение PARTITION BY, оконная функция будет рассматривать весь результирующий набор как один раздел 
\end{defin}

\begin{defin}{Предложение ORDER BY}
    Предложение ORDER BY указывает порядок строк в каждом разделе, к которому применяется оконная функция. Сортирует строки внутри окна для вычисления нарастающего итога 

    Предложение ORDER BY использует параметр NULLS FIRST или NULLS LAST, чтобы указать, должны ли значения, допускающие значение NULL, быть первыми или последними в результирующем наборе. По умолчанию используется опция NULLS LAST

    Предложение ORDER BY является обязательным для некоторых функций 
\end{defin}

\begin{defin}{FILTER}
    Предложение FILTER определяет какие строки будут подаваться на вход оконной функции. Подаются только те входные строки, для которых условие фильтра вычисляется как истинное; другие строки отбрасываются. Предложение FILTER допускается только для агрегирующих оконных функций 
\end{defin}

\begin{defin}{Именованное окно}
    Предложение WINDOW определяет подмножество строк в текущем разделе, к которому применяется оконная функция. Это подмножество тсрок называется именованное окно
\end{defin}

\begin{nota}{Определение фрэйма (рамки)}
    Фрэйм определяет рамку окна, ограничивающую подмножество строк текущего раздела. Оконная функция работает с рамкой, а не со всем разделом

    Определение фрэйма (режимы):

    \begin{itemize}
        \item ROWS позволяет ограничить строки в окне, указывая фиксированное количество строк, предшествующих или следующих за текущей 
        \item RANGE работает с набором строк имеющих одинаковый ранг в инструкции ORDER BY
    \end{itemize}

    Необходимо наличие ORDER BY 
\end{nota}

\begin{nota}{Задание границ фрэйма}
    Для ограничения строк ROWS или RANGE можно использовать следующие ключевые слова: 

    \begin{itemize}
        \item UNBOUNDED PRECEDING -- указывает, что фрэйм начинается с первой строки группы 
        \item UNBOUNDED FOLLOWING -- с помощью данной инструкции можно указать, что фрэйм заканчивается на последней строке группы
        \item CURRENT ROW -- инструкция указывает, что фрэйм начинается или заканчивается на текущей строке
        \item ЧИСЛО PRECEDING -- определяет число строк перед текущей строкой 
        \item ЧИСЛО FOLLOWING -- определяет число строк после текущей строки
    \end{itemize}

    Если конец рамки не задан, подразумевается CURRENT ROW 
\end{nota}

\begin{nota}{Исключение рамки}
    Исключение рамки позволяет исключить из рамки строки, которые окружают текущую строку, даже если они должны быть включены согласно указаниям, определяющим начало и конец рамки 

    Исключение рамки может быть следующим:

    \begin{itemize}
        \item EXCLUDE CURRENT ROW -- исключает из рамки текущую строку
        \item EXCLUDE GROUP -- исключает из рамки текущую строку и родственные ей согласно порядку сортировки 
        \item EXCLUDE TIES -- исключает из рамки все родственные строки для текущей, но не собственно текущую строку
        \item EXCLUDE NO OTHERS -- явно выражает поведение по умолчанию -- не исключает ни текущую строку, ни родственные ей 
    \end{itemize}
\end{nota}

\begin{nota}{Обработка оконных функций}
    Если запрос содержит оконные функции, эти функции вычисляются после каждой группировки, агрегатных выражений и фильтрации HAVING: оконные функции видят не исходные строки, полученные из FROM/WHERE, а сгруппированные 

    При использовании нескольких оконных функций с одинаковым определением окна (PARTITION BY и ORDER BY) все функции обрабатывают данные за один проход. Они увидят один порядок сортировки, даже если ORDER BY не определяет порядок однозначно 

    Оконные функции требуют предварительно отсортированных данных, так что результат запроса будет отсортирован согласно тому или иному предложению PARTITION BY/ORDER BY оконных фукнций. Чтобы результаты сортировались определенным образом, необходимо явно добавить предложение ORDER BY на верхнем уровне запроса 
\end{nota}

\begin{nota}{Порядок выполнения запроса}
    \begin{enumerate}
        \item Взять нужные таблицы (FROM) и соединить их при необходимости (JOIN)
        \item Отфильтровать строки (WHERE)
        \item Сгруппировать строки (GROUP BY)
        \item Отфильтровать результат группировки (HAVING)
        \item Сформировать конкретные столбцы результата (SELECT)
        \item Рассчитать значения оконных функций (FUNCTION() OVER WINDOW)
        \item Отсортировать то, что получилось (ORDER BY)
    \end{enumerate}
\end{nota}

\newpage 

\subsection{Оконные функции}

\begin{nota}{Типы оконных функций}
    \begin{itemize}
        \item Агрегатные функции
        
        \begin{itemize}
            \item SUM -- возвращает сумму значений в столбце 
            \item COUNT -- возвращает количество значений в столбце
            \item AVG -- возвращает среднее значение в столбце
            \item MAX -- возвращает максимальное значение в столбце
            \item MIN -- возвращает минимальное значение в столбце
        \end{itemize}

        Значения NULL не учитываются. Использование ключевого слова DISTINCT не допускается с предложением OVER 
        \item Ранжирующие функции 
        
        \begin{itemize}
            \item ROW\_NUMBER -- возвращает номер строки в окне 
            \item RANK() -- возвращает ранг каждой строки. Строки которые имеют одинаковые значения в столбцах, по которым выполняется сортировка, получают одинаковый ранг с пропуском следующего значения 
            \item DENSE\_RANK() -- возвращает ранг каждой строки. В отличии от функции RANK, она для одинаковых значений возвращает ранг, не пропуская следующий 
            \item NTILE(n) -- позволяет разделить упорядоченные строки в секции на заданное количество ранжированных групп. Возвращает для каждой строки номер группы 
        \end{itemize}

        Наличие ORDER BY обязательно
        \item Функции смещения
        
        \begin{itemize}
            \item LAG или LEAD -- функция LAG обращается к данным из предыдущей строки окна, а LEAD -- к данным из следующей строки. Имеют трип параметра: столбце, значение которого необходимо вернуть; количество строк для смещения (по умолчанию 1); значение, которое необходимо вернуть если после смещения возвращается значение NULL
            \item FIRST\_VALUE или LAST\_VALUE -- позволяют получить превое и последнее значение в окне. В качестве параметра принимают столбец, значение которого необходимо вернуть 
            \item NTH\_VALUE -- возвращает значение из $n$-й строки указанного столбца в упорядоченном разделе результирующего набора 
        \end{itemize}
        \item Аналитические функции 
        
        Возвращают ифнормацию о распределении данных и используются для статистического анализа 

        \begin{itemize}
            \item CUME\_DIST -- возвращает относительный ранг текущей строки в окне 
            \item PERCENT\_RANK -- возвращает относительный ранг текущей строки в окне 
        \end{itemize}

        Функции распределения рангов вычисляют относительный ранг текущей строки в секции окна, который выражается числом от 0 до 1 (процент)
    \end{itemize}
\end{nota}

\begin{defin}{ROW\_NUMBER}
    Позволяет: 

    \begin{itemize}
        \item Задать нумерацию, которая будет отличаться от порядка сортировки строк результирующего набора 
        \item Создать несквозную нумерацию, т.е. выделить группы из общего множества строк и пронумеровать их отдельно для каждой группы 
        \item Использовать одновременно несколько способов нумерации, так как нумерация не зависит от сортировки строк основного запроса 
    \end{itemize}
\end{defin}

\newpage

\subsection{Использование подзапросов}

\begin{nota}{Запросы по типу возвращаемого результата}
    \begin{itemize}
        \item Скалярные (Scalar Subqueries) -- возвращают одно значение 
        \item Многозначные (Multi-Valued Subqueries) -- возвращают список значений 
        \item Табличные (Table-Valued Subqueries) -- возвращают таблицу 
    \end{itemize}
\end{nota}

\begin{nota}{Использование подзапросов}
    \begin{center}
        \begin{tabular}{|m{6.5em}|m{8.5em}|m{10em}|m{10em}|}
            \hline 
            Предложение & Scalar Subquery & Multi-Valued Subquery & Table-Valued Subquery \\
            \hline
            SELECT & Вычисляемый столбец & - & - \\
            \hline
            FROM & - & Derived Table (именованная таблица из одного столбца) & Derived Table (именованная таблица), CTE (временное представление) \\
            \hline
            WHERE & Фильтрация записей на основе сравнения со скалярной величиной & Фильтрация записей с использованием предикатов [NOT] IN, SOME, ALL, ANY, [NOT] EXISTS* & Фильтрация записей с использованием предиката [NOT] EXISTS* \\
            \hline
            GROUP BY & - & - & - \\
            \hline
            HAVING & Фильтрация групп на основе сравнения со скалярной величиной & - & - \\
            \hline
            ORDER BY & - & - & - \\
            \hline
        \end{tabular}
    \end{center}
\end{nota}

\begin{Example}{Использование скалярного вложенного подзапроса}
\begin{lstlisting}
SELECT orderid, productid, unitprice, qty
FROM "Sales"."OrderDetails"
WHERE orderid = 
    (SELECT MAX(orderid) FROM "Sales"."Orders");
\end{lstlisting}

    Если вложенный подзапрос возвращает пустую выборку (empty set), реузультат конвертируется в NULL
\end{Example}

\begin{Example}{Использование многозначного вложенного запроса с одним столбцом}
    Список заказов, сделанных клиентами из 'Mexico':
\begin{lstlisting}
SELECT custid, orderid 
FROM "Sales"."Orders"
WHERE custid IN (SELECT custid
                 FROM "Sales"."Customers"
                 WHERE country = 'Mexico');
\end{lstlisting}
\end{Example}

\begin{Example}{Использование многозначного вложенного запроса с несколькими столбцами}
    Вы можете использовать IN (ANY, ALL, SOME) для сравнения по нескольким столбцам. В предложении WHERE необходимо сгруппировать имена стоолбцов в скобках. Количество сгруппированных столбцов должно соответствовать целевому списку подзапроса, и иметь те же типы данных 

\begin{lstlisting}
SELECT custid, orderid, shipcity
FROM "Sales"."Orders"
WHERE (custid, shipcity) != ALL (SELECT custid, city
                                 FROM "Sales"."Customers")
AND custid = 76;
\end{lstlisting}
\end{Example}

\begin{Example}{Использование скалярного коррелированного запроса}
    Список заказов с общей суммой каждого заказа 

\begin{lstlisting}
SELECT orderid, o.custid,
         (SELECT SUM(unitprice * qty)
          FROM "Sales"."OrderDetails" od
          WHERE od.orderid = o.orderid) AS OrderTotal
FROM "Sales"."Orders" o;
\end{lstlisting}
\end{Example}

\begin{Example}{Использование предиката EXISTS}
    Если вложенный запрос возвращает хотя бы одну запись -- EXISTS возвращает TRUE, иначе FALSE

\begin{lstlisting}
SELECT custid, companyname
FROM "Sales"."Customers" AS c 
WHERE [NOT] EXISTS (
    SELECT 1 
    FROM "Sales"."Orders" AS o 
    WHERE o.custid = c.custid);
\end{lstlisting}
\end{Example}

\newpage 

\subsection{Использование табличных выражений}

\begin{defin}{Производные таблицы (Derived Tables)}
    Производные таблицы -- именованные выражения запроса, созданные во внешнем операторе SELECT. Не хранится в БД -- представляет собой виртуальную реляционную таблицу. Область видимости -- запрос, в котором она определена 

    Производная таблица должна: 

    \begin{itemize}
        \item Иметь псевдоним
        \item Иметь уникальные имена для всех столбцов 
        \item Не ссылаться несколько раз в одном запросе 
    \end{itemize}

    Производная таблица может: 

    \begin{itemize}
        \item Использовать внутренние или внешние псевдонимы столбцов 
        \item Быть вложенной в другие производные таблицы 
    \end{itemize}
\end{defin}

\begin{defin}{Общие табличные выражения (CTE)}
    CTE (Common Table Expression) -- именованные табличные выражения, используемые для разбиения сложных запросов на простые части. Можно представить как определения временных таблиц, существующих только для одного запроса 

    CTE определяется в предложении WITH. Все возвращаемые столбцы должны иметь уникальные имена. CTE поддерживают несколько определений. На CTE допустимо ссылаться несколько раз только в одном запросе 
\end{defin}

\begin{defin}{Рекурсивный запрос WITH}
    Для определния рекурсивного запроса WITH используется указание RECURSIVE

    Рекурсивный запрос WITH включает: 

    \begin{itemize}
        \item Не рекурсивную часть 
        \item Оператор UNION или UNION ALL
        \item Рекурсивную часть
    \end{itemize}

    Только в рекурсивной части можно обратиться к результату запроса
\end{defin}

\begin{defin}{Подзапросы LATERAL}
    При необходимости объединить записи исходной таблицы с записями, которые возвращает коррелированный табличный подзапрос или табличная функция необходимо использовать операторы LATERAL. CROSS JOIN LATERAL -- аналог INNER JOIN, а LEFT JOIN LATERAL -- LEFT JOIN

    Коррелированный табличный подзапрос должен быть указан справа от оператора LATERAL
\end{defin}

\newpage 

\section{Лекция 5. Проектирование}

\subsection{Основные подходы к проектированию ИС}

\begin{nota}{Основные этапы жизненного цикла ИС}
    \begin{itemize}
        \item Определение требований (анализ). Концептуальные модели данных и бизнес проектов. Определение качественных характеристик
        \item Проектирование. Логические модели приложений и баз данных для реализации требований. Определение архитектуры 
        \item Реализация. Физические модели приложений и баз данных 
        \item Тестирование и внедрение. Установка технических средств, настройка системы, обучение персонала, пробное использование итд 
        \item Функционирование. Обслуживание и администрирование, в т.ч. внесение изменений (доработка)
    \end{itemize}
\end{nota}

\begin{nota}{Использование моделей в процессе проектирования}
    Модель -- это по существу упрощенное абстрактное представление сложного реального объекта (процесса, явления или системы), призванное ответить на вопросы относительно него 

    Охватить сложный объект целиком -- представить его с помощью единой модели -- вряд ли получится, поэтому каждая модель фокусируется на отдельных, важных для конкретной задачи, свойствах исследуемого объекта 
\end{nota}

\begin{nota}{Этапы и модели}
    Проектирование системы на всех этапах разработки должно быть привязано к процессам предметной области (технологическому, бизнес-процессу), особенно на этапе разработки концептуальной модели 

    \begin{center}
        \begin{tabular}{>{\centering\arraybackslash}m{7em} >{\centering\arraybackslash}m{10em} >{\centering\arraybackslash}m{8em} >{\centering\arraybackslash}m{10em}}
            Концептуальная модель & Структурно-функциональное моделирование (IDEF0, IDEF3, DFD) & ${\centering \Leftrightarrow}$ & Объектно-ориентированное моделирование (UML) \\
            & & $\Updownarrow$ & \\
            Логическая модель & & Информационное моделирование (IDEF1X) & \\
            & & $\Updownarrow$ & \\
            Физическая модель & & Система управления БД & \\
        \end{tabular}
    \end{center}
\end{nota}

\begin{nota}{Основные этапы и методы}
    \begin{center}
        \begin{tabular}{|m{15em}|m{20em}|}
            \hline
            Этап & Методы \\
            \hline
            Разработка концептуальной модели ИС & Структурно-функциональное и/или объектно-ориентированное моделирование \\
            \hline
            Разработка логической модели ИС & Информационное моделирование (создание диаграммы сущность-связь) \\
            \hline
            Разработка физической модели и программного обеспечения ИС & Реализация объектов логической модели, разработка программного кода \\
            \hline
            Тестировка и отладка ИС & Корректировка программного обеспечения \\
            \hline
            Эксплуатация ИС & Поддержка ИС после ввода в эксплуатацию \\
            \hline
        \end{tabular}
    \end{center}
\end{nota}

\begin{nota}{Подходы к проектированию}
    \begin{center}
        \begin{tabular}{|m{17.5em}|m{17.5em}|}
            \hline
            Функционально-ориентированный & Объектно-ориентированный \\
            \hline
            Функциональная декомпозиция системы с последующим уточнением структуры данных & Представление системы в терминах взаимодействия объектов (классов объектов) \\
            \hline
            Первичны -- процессы (функции). Менее стабильны & Первичны -- объекты (данные). Более стабильны \\
            \hline
            Связывание динамической и статической проекций системы затруднено & Изначально связанные динамическая и статическая проекции \\
            \hline
            Методы создания моделей (отсутствие свободной трактовки/интерпретации) & Рекомендации, лучшие практики итп \\ 
            \hline
            Восприятие экспертами предметной области -- лучше & Восприятие экспертами предметной области -- хуже \\
            \hline
        \end{tabular}
    \end{center}
\end{nota}

\newpage

\subsection{Основные этапы проектирования баз данных}

\begin{nota}{Важность}
    От того, насколько успешно будет спроектирована БД, зависит 

    \begin{itemize}
        \item Эффективность функционирования проектируемой информационной системы в целом 
        \item Ее жизнеспособность
        \item Возможность расширения и дальнейшего развития 
    \end{itemize}

    Поэтому вопрос проектирования баз данных выделяют как отдельное, самостоятельное направление работ при разработке информационных систем 
\end{nota}

\begin{defin}{Методология проектирования БД}
    Методология проектирования БД -- структурированный подход, предусматривающий использование специализированных процедур, технических приемов, инструментов, документации и ориентированный на поддержку и упрощение процесса проектирования 

    Методология проектирования предусматривает разбиение всего процесса на несколько стадий, каждая из которых, в свою очередь, состоит из нескольких этапов. На каждом этапе разработчику предлагается набор технических приемов, позволяющих решать задачи, стоящие перед ним на данной стадии разработки 
\end{defin}

\begin{defin}{Проектирование базы данных}
    Цель проектирования базы данных -- это корректное отображение выбранной для автоматизации предметной области 

    Выделяют два основных подхода к данному процессу: 

    \begin{itemize}
        \item Нисходящий (сверху вниз)
        
        Сначала происходит изучение целого, или описание предметной области, а затем уже осуществляется разделение целого на составные части, каждая из которых после этого также последовательно изучается

        \item Восходящий (снизу вверх)
        
        Сначала происходит описание составных частей, полсе чего собирается общая картина 
    \end{itemize}
\end{defin}

\begin{defin}{Нисходящее проектирование}
    \begin{itemize}
        \item Анализ предметной области. Описание внешнего уровня базы данных. Результат -- внешняя модель предметной области 
        \item Концептуальное (инфологическое) проектирование. Анализ требований к данным. Результат -- обобщенная концептуальная модель предметной области 
        \item Логическое проектирование. Преобразование требований к данным в СУБД ориентированную структуру БД. Реузльтат -- логическая модель данных 
        \item Нормализация. Корректировка логической модели для устранения возможных аномалий данных. Результат -- нормализованная логическая модель данных 
        \item Формирование физической (внутренней) модели базы данных. Определение особенностей хранения данных, методов доступа итд. Создание схемы БД для конкретной СУБД и программно-аппаратной платформы. Результат -- внутренняя модель БД 
    \end{itemize}
\end{defin}

\newpage 

\subsection{Анализ предметной области}

\begin{nota}{Анализ предметной области}
    Проводится анализ предметной области в целом с последующей декомпозицией на отдельные элементы 

    Результат -- описание внешнего уровня базы данных (внешняя модель) для пользователей, которое абстрагируется от особенностей реализации 

    \begin{itemize}
        \item Назначение ИС и границы проекта: абстрагирование от неважного, сосредоточение на важном 
        \item Определение основных пользователей системы (действующих лиц) и их целей 
        \item Определение бизнес-правил и ограничений (функциональные требования). Отношения между информационными объектами. Ограничения на значения определнных характеристик 
        \item Определение требований обработки данных (нефункциональные требования): защита, время отклика, темпы увеличения объема данных итд 
    \end{itemize}
\end{nota}

\begin{nota}{Анализ требований}
    Включает в себя три типа деятельности:

    \begin{itemize}
        \item Сбор требований: общение с клиентами и пользователями, чтобы определить, каковы их требования 
        \item Анализ требований: определение, являются ли собранные требования неясными, неполными, неоднозначными, или противоречащими, и затем решение этих проблем 
        \item Документирование требований: требования могут быть задокументированы в различных формах, таких как простое описание, сценарии использования, пользовательские истории, или спецификации процессов 
    \end{itemize}
\end{nota}

\begin{Example}{}
    \textbf{Пример начального описания предметной области:}

    Предприятие общественного питания предлагает своим посетителям набор блюд, изготавливаемых по авторским рецептам. Каждое блюдо имеет уникальное название, относится к единственному виду и приготавливается по единственному рецепту. Каждое блюдо состоит из набора продуктов, в соответствии с рецептом 

    Компания имеет широкую сеть организаций поставщиков продуктов, расположенных в различных городах
    
    \textbf{Пример определения действующих лиц:}

    \begin{center}
        \begin{tabular}{|m{13em}|m{22em}|}
            \hline
            Действующие лица & Бизнес-цели \\
            \hline
            Сотрудник кухни & Изготовление блюда: описание рецепта, информация о количестве порций, сведения о доступности продуктов \\
            \hline
            Сотрудник по работе с поставщиками & Взаимодействие с поставщиками продуктов: информация о наличии продуктов, информация о поставщиках конкретных продуктов \\
            \hline
            Сотрудник по реализации готовой продукции & Планирование и реализация готовых продукции (блюд): формирование заявки на порции согласно меню конкретного дня, реализация порций блюд в соответствии с заказом \\
            \hline
        \end{tabular}
    \end{center}

    \textbf{Определение бизнес-правил и ограничений:}
    
    \begin{itemize}
        \item Каждое блюдо должно быть изготовлено строго по одному рецепту 
        \item При изготовлении блюда в конкретный день каждый продукт может быть взят только из одной поставки 
        \item Поставки продукта могут использоваться в нескольких блюдах в разные дни 
        \item Поставщик может осуществлять в один и тот же день только одну поставку каждого продукта 
        \item Каждый поставщик осуществляет поставку только определенных продуктов 
        \item В одной поставке могут присутствовать продукты поставляемые разными поставщиками 
        \item ИТД
    \end{itemize}
\end{Example}

\newpage

\subsection{Концептуальное (инфологическое) проектирование}

\begin{defin}{Концептуальное проектирование}
    Концуптуальная модель -- это формализованное описание предметной области на самом высоком уровне абстракции (без привязки к физическому представлению и хранению данных), выполненное без жесктйо ориентации на программные и технические средства 

    Концептуальная модель отражает специфику предметной области, а не структуру БД 

    Чтобы БД адекватно отражала предметную область, проектировщик должен хорошо представлять себе все нюансы, присущие ей, и уметь отобразить их в БД 

    Цель -- построение независмой от СУБД информационной структуры путем объединения информационных требований пользователей 

    Результат -- концептуальная (инфологическая) модель (семантическая, ER-модель)
\end{defin}

\begin{nota}{Реализация}
    Обобщение полученных на этапе анализа предметной области сведений 

    Моделирование частных представлений пользователей с использованием диаграмм сущность-связь (Entity-Relationship Diagrams, ER-диаграмм):

    \begin{itemize}
        \item Определение сущностей 
        \item Определение атрибутов сущностей 
        \item Идентификация ключевых атрибутов сущностей 
        \item Определение связей между сущностями 
    \end{itemize}

    Интеграция частных представлений: концептуальные требования отдельных пользователей, определенные в стандартной форме (диграммы сущность-связь), сливаются в единое глобальное представление. При этом должны быть выявлены и ликвидированы противоречивые и избыточные данные 

    Уточнение требований: устранение противоречивости и избыточности данных. Принцип бритвы Оккама: не следует множить сущности без необходимости 
\end{nota}

\begin{nota}{Требования предъявляемые к инфологической модели}
    \begin{itemize}
        \item Адекватное отображение предметной области 
        \item Недопущение неоднозначной трактовки модели 
        \item Представление данных с минимальным дублированием 
        \item Легкая расширяемость, обеспечивающая ввод новых данных без изменения ранее определенных, то же относят и к удалению данных 
        \item Легкое восприятие различными категориями пользователей. Желательно чтобы инфологическую модель строил (или хотя бы участвовал в ее создании) специалист, работающий в данной предметной области, а не только проектировщик систем машинной обработки данных 
    \end{itemize}
\end{nota}

\newpage 

\subsection{Формирование даталогической модели базы данных}

\begin{defin}{Формирование даталогической модели базы данных}
    Даталогическая модель БД -- модель, отражающая логические взаимосвязи между элементами данных (отношениями) безотносительно их содержания и физической организации. Интегрированный набор понятий для описания и обработки данных, связей между ними и ограничений, накладываемых на данные в рамках предметной области 

    Даталогическая модель (модель данных) разрабатывается на основе концептуальной (информационно-логической) модели предметной области с учетом: конкретной реализации СУБД, специфики конкретной предметной области -- возможных запросов к БД на основе ранее выявленных потребностей пользователей системы 
\end{defin}

\newpage 

\subsection{Нормализация}

\begin{defin}{Нормализация}
    Нормализация -- формальная процедура, проверки и реорганизации отношений, в ходе которой создается оптимизированная структура БД, позволяющая избежать различных видов аномалий 

    Нормализация подразумевает декомпозицию (разделение) отношения на два или более, обладающих лучшими свойствами при добавлении, изменении и удалении данных
\end{defin}

\begin{nota}{Задачи нормализации}
    Исключение необходимости хранения повторяющейся информации 

    Создание структуры, в которой предусмотрена возможность ее будущих изменений и с минимальным влиянием на приложения. Реализация логической и физической независимости 
\end{nota}

\newpage 

\subsection{Физическое проектирование}

\begin{defin}{Физическое проектирование}
    Цель -- создание физической структуры БД (и ее объектов), а также набора реализуемых алгоритмов обработки данных с целью эффективного использования вычислительных ресурсов (дисковой памяти, времени центрального процессора)

    Физическая структура БД соответствует понятию внутренней модели и учитывает специфику конкретной СУБД: 

    \begin{itemize}
        \item Ограничения на именование объектов базы данных 
        \item Ограничения на поддерживаемые типы данных 
        \item Требования к индексным структурам 
        \item Выбор методов управления дисковой памятью 
        \item Разделение БД по файлам и устройствам 
        \item Методы доступа к данным 
    \end{itemize}

    Результат -- полностью готовая к внедрению структура базы данных и набор реализуемых алгоритмов по ее использованию 
\end{defin}

\begin{nota}{Показатели эффективности функционирования физической БД}
    \begin{itemize}
        \item время ввода-вывода -- время, затрачиваемое на выборку данных с внешней памяти в оперативную, включая время передачи данных 
        \item Время доступа -- промежуток времени между выдачей команды, содержащей обращение к некоторым данным, и фактически получением данных для обработки 
        \item Время отклика -- промежуток времени между вводом запроса к базе данных в компьютер и завершением обработки запроса с представлением результатов 
    \end{itemize}
\end{nota}

\begin{nota}{файловые струткуры для хранения информации в БД}
    В каждой СУБД по-разному организованы зранение и доступ к данным, однако существуют некоторые файловые структуры, которые имеют общепринятые способы организации и широко применяются праткически во всех СУБД 
\end{nota}

\begin{Remark}{Внутренние (физические) модели данных}
    Зависят от особенностей конкретной СУБД и определяют: 

    \begin{itemize}
        \item специальные струткур данных, поддерживаемые СУБД: индексно-организованные таблицы, кластеры, секционированные таблицы итд 
        \item Взаимосвязь между логическими и физическими структурами хранения данных: логические (например, табличное пространство, сегмент, экстент, блок данных БД) и физические (файл данных, страница данных)
        \item Способы распрпеделения данных на физических устройствах хранения: один/несколько независимых дисков, ленточные устройства, RAID-массивы итд
        \item Способы доступа к данным: полное чтене таблицы, чтение индекса с пропусками, чтение кластера 
    \end{itemize}
\end{Remark}

\begin{nota}{Файловая струткура БД}
    Таблица -- логический элемент БД, физически его нет 

    Все данные хранятся в файлах, а фалйы организуются в группы 

    Файлы подразделяются на файлы данных и файлы журнала транзакций. Файлы могут лежать на разных дисках при нехватке места или необходимости распределенного хранения 

    Файлы разделяются на блоки -- страницы. Размер блока зависит от СУБД. В блоке может быть одна или несколько записей. За распределение записей по файлам отвечает СУБД 
\end{nota}

\begin{nota}{Формирование реляционной БД из ER-диаграмм}
    \begin{enumerate}
        \item Каждая сущность превращается в таблицу. Имя сущности становится именем таблицы 
        \item Каждый атрибут становится столбцом с тем же именем 
        \item Компоненты уникального идентификатора сущности превращаются в первичный ключ таблицы 
        \item Связи многие-к-одному (и один-к-одному) становятся внешними ключами 
    \end{enumerate}
\end{nota}

\newpage 

\subsection{Автоматизация проектирования баз данных}

\begin{defin}{CASE-технология}
    CASE-технология (Computer-Aided Software/System Engineering) -- это инструментарий для системных аналитиков, разработчиков и программистов, позволяющий автоматизировать процесс проектирования и разработки ПО. Совокупность методологий анализа, проектирования, разработки и сопровождения сложных систем, поддерживаемая комплексом взаимосвязанных средств автоматизации 

    Современные CASE-средства охватывают обширную область поддержки многочисленнных технологий проектирования ИС: от простых средств анализа и документирования до полномасштабных средств автоматизации, покрывающих весь жизненный цикл ПО 
\end{defin}

\begin{defin}{CASE-средства}
    Современный рынок программных сресдтв насчитывает около 300 различных CASE-средств 

    CASE-средства можно классифицировать по: 

    \begin{itemize}
        \item Применяемым методологиям и моделям систем и БД 
        \item Степени интегрированности с СУБД 
        \item Доступным платформам 
    \end{itemize}
\end{defin}

\begin{nota}{Классификация по типа}
    \begin{itemize}
        \item Средства анализа -- предназначены для построения и анализа моделей предметной области 
        \item Средства анализа и проектирования -- поддерживают наиболее распространенные методологии проектирования и используются для создания проектных спецификаций на компоненты и интерфейсы системы, архитектуру системы, алгоритмы и структуры данных 
        \item Средства проектирования баз данных -- обеспечивают моделирование данных и генерацию схем баз данных (как правило, на языке SQL) для наиболее распространенных СУБД (прямое проеткирование)
        \item Средства разработки приложений -- средства реинжиниринга, обеспечивают анализ программных кодок и схем баз данных и формируют на их основе различные модели и проектные спецификации (обратное проектирование)
    \end{itemize}
\end{nota}

\begin{nota}{CASE-средства проектирования БД}
    \begin{itemize}
        \item Независимые от СУБД -- поддерживают различные платформы, позволяя генерировать структуру БД для различных СУБД 
        \item Встроенные -- специализированы и ориентированы на конкретную СУБД в состав которой входят 
    \end{itemize}
\end{nota}

\begin{nota}{Состав CASE-средств разработки БД}
    Графические средства создания и редактирования ER-модели

    Средства автоматического отображения ER-модели в реляционную

    Средства создания на основе полученной реляционной модели SQL-скриптов для создания СУБД-ориентированной БД: таблиц БД и связей между ними 

    Реальная БД может быть создана непосредственно системой -- целевая СУБД должна быть доступна для системы -- или с помощью сгенерированного сценария -- разработчик получает файл сценария на диалекте выбранной СУБД и выполняет этот сценарий на целевом сервере 
\end{nota}

\begin{Remark}{Преимущества и недостатки}
    Преимущества:

    \begin{itemize}
        \item CASE-средства незаменимы при создании больших проектов группой проектировщиков
        \item Использование CASE-средства позволяет сократить срок разработки 
        \item Использование CASE-средства позволяет снизить число возможных ошибок
    \end{itemize}

    Недостатки:

    \begin{itemize}
        \item Позволяют моделировать только бинарные связи между сущностями 
        \item Генерируют отношения по упрощенным правилам, не всегда учитывая класс принадлежности сущности связи 
    \end{itemize}
\end{Remark}

\newpage 

\subsection{Диаграммы сущность-связь}

\begin{defin}{ER-модель}
    Модель сущность-связь впервые была предложена в 1976 г. Питером Ченом 

    ER-модель представляет собой описание предметной области в терминах сущность (объект) -- атрибут (свойство) -- связь

    Для графического представления ER-модели используется ERD: детализация хранилищ данных проектируемой системы, документирование сущностей системы и способов их взаимодействия 
\end{defin}

\begin{nota}{Основные понятия ER-модели}
    \begin{itemize}
        \item Сущность 
        \item Экземпляр сущности 
        \item Атрибут 
        \item Ключ 
        \item Связь 
    \end{itemize}
\end{nota}

\newpage 

\subsection{Сущность}

\begin{defin}{Сущность и экземпляр сущности}
    Сущность -- именованное множество подобных уникальных экземпляров -- объектов, событий, концепций -- информация о которых должна сохраняться в базе данных. Имя сущности -- существительное в единственном числе 

    Экземпляр сущности -- конкретный представитель данной сущности 
\end{defin}

\begin{nota}{Выделение сущностей}
    Для формирования начального списка сущностей:

    \begin{itemize}
        \item В списке имен исходного материала выбираем все существительные 
        \item Отвечаем на вопросы, которые касаются каждой возможной сущности:
        
        \begin{itemize}
            \item Может ли она быть описана, т.е. обладает ли она набором характеристик?
            \item Существует ли более одного экземпляра этой сущности?
            \item Может ли один экземпляр этой сущности быть отделен от другого, т.е. идентифицирован?
            \item Называет или описает это что-либо? (Если этот ответ положительный, то это скорее атрибут, чем сущность)
        \end{itemize}
    \end{itemize}

    Анализ является субъективным процессом, поэтому различные разработчики могут создавать разные, но вполне допустимые интерпретации одного и того же факта 
\end{nota}

\begin{nota}{Типы сущностей}
    \begin{itemize}
        \item Независимая (сильная, родительская, основная). Каждый экземпляр сущности может быть однозначно идентифицирован без определения его отношений с другими сущностями. Уникальность экземпляра определяется только собственными атрибутами 
        \item Зависимая сущность (слабая, дочерняя, подчиненная). Однозначная идентификация экземпляра сущности зависит от его отношения к другой сущности. Существование экземпляра сущности зависит от существования экземпляра родительской сущности 
    \end{itemize}
\end{nota}

\newpage 

\subsection{Атрибуты}

\begin{defin}{Атрибут}
    Атрибут -- именованное и неотъемлемое свойство всех экземпляров сущности, предназначенное для классификации, идентификации, количественной характеристики и выражения состояния сущности 

    Атрибут выражает некоторое отдельное свойство сущности, которое характеризует ее экземпляр 
\end{defin}

\begin{nota}{Правила атрибутов}
    Атрибуты неотъемлемая бизнес-характеристика сущности 

    Сущность может обладать любым количеством атрибутов

    \begin{itemize}
        \item Каждый атрибут идентифицируется уникальным в пределах сущности именем 
        \item Для каждого экземпляра сущности должно существовать значение кжадого его обязательного атрибута 
        \item Ни один экземпляр сущности не может обладать более чем одним значением для связанного с ней атрибута 
        \item Значение атрибутов не должны слишком часто меняться 
    \end{itemize}
\end{nota}

\begin{nota}{Определение состава атрибутов}
    На первом этапе необходимо выделить только те атрибуты, которые изначально имеются у сущности (если ее рассматривать отдельно от всех остальных)

    Самый простой способ определения атрибутов -- после идентификации сущности или связи, задать себе вопрос: какую информацию требуется хранить о \dots? Если возникает необходимость добавить атрибут(ы) для связи, это указывает на тот факт, что связь является сущностью. После установки связей у сущности могут появиться атрибуты характеризующие связь 

    Существенно помоьч в определении атрибутов могут различные бумажные и электронные формы и документы, используемые в организации при решении задачи
\end{nota}

\begin{nota}{Виды атрибутов}
    \begin{itemize}
        \item Составные/простые (атомарные). Составной -- состоит из нескольких компонентов (ФИО, адрес), простой -- состоит из одного компонента с независимым существованием (цена, дата рождения). Степень атомарности атрибутов определяется разработчиком и зависит от характера работы с данными (задач)
        \item Обязательные/необязательные. Значение обязательного атрибута должно быть определено для любого возможного экземпляра сущности, необязательные атрибуты допускают отстуствие значения 
        \item Однозначные/многозначные. Однозначный -- содержит только одно значение для одного экземпляра сущности, многозначный -- может содержать несколько значений 
        \item Базовый/производный (вычисляемые). Значение атрибута может быть определено по значениям других атрибутов
        \item Ключевые/неключевые. Ключевой (идентфиицирующий) -- служит для уникальной идентфикации экземпляра сущности, не ключевой (описательный) -- используется для определения интересующих пользователя свойств 
        \item Изначально присущие сущности (бизнес атрибутов)/появившиеся в результате проектирования (суррогатные ключи, связи)
    \end{itemize}
\end{nota}

\begin{nota}{Типы данных и домены}
    Для каждого атрибута должны быть определены:

    \begin{itemize}
        \item Тип данных атрибута -- характеризует вид хранящихся данных (числовой, текстовый, логический, временной и др.)
        \item Домен -- множество допустимых значений атрибута, отвечающих бизнес-правилам предметной области 
    \end{itemize}
\end{nota}

\newpage

\subsection{Ключи}

\begin{defin}{Определение ключей}
    На основании выделенного множества атрибутов для сущности определяется набор ключей 

    Ключ -- один или несколько атрибутов сущности, служащих для однозначной идентификации ее экземпляров или для их быстрого поиска 

    Выдялеют следующие типы ключей:

    \begin{itemize}
        \item Потенциальный ключ (candidate key)
        \item Первичный ключ (primary key)
        \item Альтернативный ключ (alternate key)
        \item Суррогатный ключ (surrogate key)
    \end{itemize}
\end{defin}

\begin{defin}{Ключи}
    Потенциальный ключ -- минимальный набор атрибутов, по значениям которых можно однозначно найти требуемый экземпляр сущности. Минимальность означает, что исключение из набора любого атрибута не позволяет идентифицировать сущность по оставшимся. Значение ключа уникально для каждого экземпляра сущности. Сущность может иметь несколько потенциальных ключей. Если ключ состоит из нескольких атрибутов, то она называется составным ключом 

    Первичный ключ -- потенциальный ключ, который выбран в качестве основного идентфикатора, уникально идентифицирующего экземпляр сущности 

    Альтернативный ключ -- потенциальный ключ, не ставший первичным 

    Суррогатный ключ -- дополнительный служебный атрибут, добавленный к имеющимся бизнес-атрибутам, единственное предназначаение которого -- служить первичным ключом 
\end{defin}

\begin{nota}{Характеристики хорошего первичного ключа}
    \begin{itemize}
        \item Должен быть уникальным 
        \item Должен быть обязательным (иметь значения для всех возможных экземпляров сущности)
        \item Должен быть минимальным не только по количеству атрибутов, но и по размеру (суммарной длине значения)
        \item Должен быть постоянным -- значения такого атрибута не должны меняться в течение всего времени существования экземпляра сущности 
        \item Должен обеспечивать высокую скорость поиска нужного экземпляра сущности (не должен быть текстовым)
    \end{itemize}
\end{nota}

\begin{Remark}{Определение ключей}
    Каждая сущность должна обладать первичным ключом 

    Каждая сущность может обладать любым числом альтернативных ключей 

    Ключ может состоять из одого (простой ключ) или нескольких атрибутов (составной ключ)

    Отдельный атрибут может быть частью более чем одного ключа (первичного или альтернативного)
\end{Remark}

\newpage 

\subsection{Связь}

\begin{defin}{Связь}
    Связь -- ассоциирование экземпляров двух или более сущностей (или различных экземпляров одной и той же сущности). Одно из основных требований к организации базы данных -- это обеспечение возможности поиска экземпляров одних сущностей по значениям других, для чего необходимо установить между ними определенные связи 

    Типы связей:

    \begin{itemize}
        \item Связь 1:1. Один экземпляр сущности одного класса связан с одним экземпляром сущности другого класса
        \item Связь 1:М. Один экземпляр сущности одного класса связан со многими экземплярами сущности другого класса
        \item Связь М:N. Несколько экземпляров сущности одного класса связаны с несколькими экземплярами сущности другого класса
    \end{itemize}
\end{defin}

\begin{defin}{Внешний ключ}
    Внешние ключи (Foreign Key) -- это атрибуты, предназначенные для определения связи между сущностями. Сущность может обладать любым количеством внешних (наследуемых) атрибутов 

    Связь всегда реализуется между двумя сущностями. Одна сущность выступает в роли родительской, а другая в роли дочерней 

    Для поддержки связей обе сущности должны содержать наборы атрибутов, по которым они связаны: в родительской сущности -- первичный ключ или альтернативный ключ. В дочерней сущности -- внешний ключ. Внешний ключ должен по составу и типу атрибутов соответствовать первичному ключу, родительской сущности 
\end{defin}

\begin{nota}{Характеристики связи}
    \begin{itemize}
        \item Имя связи -- как правило определяется глагольной фразой. Определяет семантику связи и выражает некоторое бизнес правило. Связь может быть поименована от родителя (обязательно) и от потомка
        \item Мощность (кардинальность) связи -- служит для обозначения количества экземпляров (значений) дочерних сущностей связанных с соответствующим значением родительской сущности 
        \item Модальность связи -- описывает ее обязательность: может и должен. Может -- указывает, что экземпляр сущности может не связываться с экземпляром другой сущности. Должен -- обязан связаться минимум 1 раз 
        \item Мощность и модальность связи выражают существующие ограничения предметной области 
    \end{itemize}
\end{nota}

\begin{nota}{Тип связи}
    \begin{itemize}
        \item Идентифицирующая (сильная) связь. Определяет такое отношение между двумя сущностями, в котором для идентификации каждого экземпляра подчиненной сущности требуются значения атрибутов родительской сущности. Экземпляр подчиненной сущности не может существовать или не имеет смысла без экземпляра родительской сущности. Атрибуты, составляющие первичный ключ родительской сущности, входят в состав первичного ключа дочерней сущности 
        \item Не идентифицирущая (слабая) связь. Определяет такое отношение между двумя сущностями, в котором каждый экземпляр подчиненной сущности не зависит от значений атрибутов родительской сущности. Экземпляр подчиненной сущности может существовать (имеет смысл) без экземпляра родительской сущности. Атрибуты первичного ключа родительской сущности являются неключевыми атрибутами дочерней сущности
    \end{itemize}
\end{nota}

\begin{nota}{Категориальная связь}
    Если две и более сущностей имеют общие по смыслу атрибуты, либо когда сущности имеют общие по смыслу связи, можно применять в модели иерархию наследования (категорий), включающую в себя суперклассы и подклассы. Не существует в реляционной модели, поэтому в ходе дальнейшего проектирования должна быть разрешена 

    Суперкласс (родительская сущность, супертип) -- сущность, включающая в себя подклассы (категории, подтипы)

    В роидетльской сущности вводится атрибут-дискриминатор, позволяющий распределять ее экземпляры по категориям 
\end{nota}

\begin{nota}{Виды категорий}
    \begin{itemize}
        \item Эксклюзивная -- каждому родительскому экземпляру может соответствовать экземпляр только в одном из потомков 
        \item Не эксклюзивная -- каждому родительскому экземпляру могут соответствовать экземпляры нескольких потомков 
        \item Полная -- выделены все возможные подтипы: одному родительскому экземпляру обязательно соответствует экземпляр в каком-либо потомке 
        \item Неполная -- определены только некоторые из возможных подтипов: могут существовать родительские экземпляры, которые не имеют соответствия экземпляров в потомках 
    \end{itemize}
\end{nota}

\begin{defin}{Рекурсивная связь}
    Связь между различными экземплярами одной и той же сущности. Всегда не идентифицирующая. Атрибут внешнего ключа должен быть необязательным (может содержать NULL)
\end{defin}

\begin{Remark}{Требования предъявляемые к ИЛМ}
    \begin{itemize}
        \item Адекватное отображение предметной области 
        \item Недопущение неоднозначной трактовки модели 
        \item Представление данных с минимальным дублированием 
        \item Легкая расширяемость, обеспечивающая ввод новых данных без изменения ранее определенных, а также удаление одних элементов данных без потери других 
        \item Легкое восприятие различными категориями пользователей 
        \item Применимость языка описания модели как при ручном, так и при автоматизированном проектировании информационных систем 
    \end{itemize}
\end{Remark}

\begin{defin}{Концептуальное проектирование}
    Цель -- построение независимой от СУБД информационной структуры путем объединения информационных требований пользователей 

    Результат -- концептуальная (инфологическая) модель (семантическая, ER-модель)
\end{defin}

\newpage 

\subsection{Обеспечение корректности и целостности данных}

\begin{defin}{Обеспечение корректности и целостности данных}
    Корректность данных -- соответствие определенным ограничениям предметной области. Обеспечивается правилами валидации значений атрибутов (простые условия) или триггерами СУБД (сложные условия, нереализуемые в СУБД через заданные правила для атрибута, т.е. на уровне ограничения столбца таблицы)

    Полнота данных -- значение для всех обязательных атрибутов определены. Может обеспечиваться заданием значений атрибутов по умолчанию 

    Целостность данных -- согласованное представление информации для связанных сущностей. Значений одинаковых атрибутов связанных сущностей совпадают. Обеспечивается правилами ссылочной целостности или на уровне триггеров СУБД (для правил, неподдерживаемых СУБД на уровне ограничений внешнего ключа)
\end{defin}

\begin{nota}{Общий алгоритм разработки ER-модели}
    \begin{enumerate}
        \item Выделение сущностей 
        \item Определение атрибутов сущностей
        \item Определение первичных ключей 
        \item Определение связей между сущностями 
        \item Определение правил поддержки ссылочной целостности, правил проверки значений атрибутов и значений по умолчанию для атрибутов
    \end{enumerate}

    Данный алгоритм является итерационным (указанная последовательность шагов может выполняться несколько раз в процессе разработки, постепенно уточняя модель). Пункты 2-3 и 4 на практике можно поменять местами 
\end{nota}

\newpage

\subsection{Нормализация реляционной базы данных}

\begin{defin}{Нормализация}
    Нормализация -- формальная процедура, проверки и реорганизации отношений, в хоже которой создается оптимизированная структура БД, позволяющая избежать различных видов аномалий 

    Нормализация подразумевает декомпозицию (разделение) отношения на два или более, обладающих лучшими свойствами при добавлении, изменении и удалении данных
\end{defin}

\begin{nota}{Задачи нормализации}
    \begin{itemize}
        \item Исключение из таблиц повторяющейся информации 
        \item Создание структуры, в которой предусмотрена возможность ее будущих изменений и с минимальным влиянием на приложения. Реализация логической и физической независимости 
    \end{itemize}
\end{nota}

\begin{defin}{Дублирование данных}
    Дублирование заключается в хранении идентичных данных 

    \begin{itemize}
        \item Необходимое. Важен сам факт идентичности данных -- для поддержки ссылочной целостности (связей между сущностями) 
        \item Избыточное. Приводит к проблемам при обработке данных (аномалиям), которые не являются неразрешимыми в принципе, но существенно усложняют обработку. При избыточном дублировании могут возникать противоречия данных (возможность вывода двух взаимоисключающих утверждений на основе имеющихся данных)
    \end{itemize}
\end{defin}

\begin{defin}{Аномалии}
    Аномалия -- такая ситуация в БД, которая приводит к противоречиям в данных, либо существенно усложняет их обработку 

    \begin{itemize}
        \item Аномалия модификации данных. Необходимость изменения одного значения приводит к необходимости просмотра всей таблицы (для исключения противоречий)
        \item Аномалия удаления данных. Состоит в том, что удаление данных из таблицы приводит к удалению информации не связанной напрямую с удаляемыми данными 
        \item Аномалия вставки данных. Нельзя добавить одни данные без наличия других или же для вставки данных необходимо просмотреть всю таблицу (для исключения противоречий)
    \end{itemize}

    Основная причина аномалий -- хранение в одном отношении разнородной информации 
\end{defin}

\textbf{Тут важно посмотреть презентацию: лекция 5. Нормализация (до следующей лекции)}

\begin{Example}{Примеры избыточности и аномалий различных видов}
    \begin{itemize}
        \item Избыточность: для каждого сотрудника отдела повторяются данные об отделе и должности 
        \item Аномалия модификации: если какой-либо отдел решает переименовать необходимо изменить значение атрибута Наим\_отдела для многих экземпляров сущности сотрудник 
        \item Аномалия удаления: если все сотрудники какого-либо отдела будут уволены, информация об отделе также будет утеряна 
        \item Аномалия вставки: если при внесении данных о каком-либо сотруднике оператор совершит ошибку и внесет неверное наименование отдела (оставив верный номер), будет не ясно, какая из строк БД содержит правильную информацию (в базе будут содержаться противоречивые сведения). Вставка сведений о новом отделе компании невозможна без наличии сведений о хотя бы однои его сотруднике
    \end{itemize}
\end{Example}

\begin{nota}{Описание предметной области}
    Используется далее для иллюстрации проведения нормализации 

    \begin{itemize}
        \item Каждая группа на кафедре учится по определенной специальности 
        \item Нумерация групп -- сквозная: не может быть групп с одинаковыми номерами, обучающихся на разных специальностях 
        \item Учебный план специальности определяет дисциплины, изучаемые в группах этой специальности 
        \item Одна и та же дисциплина может встречаться в учебных планах групп разных специальностей 
        \item Каждую дисциплину может вести как один преподаватель, так и несколько (даже в рамках одной группы)
        \item Каждый преподаватель может вести несколько дисциплин, а также одну дисциплину у нескольких групп
    \end{itemize}
\end{nota}

\begin{nota}{Имеющиеся аномалии}
    \begin{itemize}
        \item Если уволить преподавателя, может быть потеряна информация о дисциплине и даже группе (аномалия удаления)
        \item При открытии новой специальности, информацию о ней невозможно будет добавить, не определив какие дисциплины на ней будут читаться и кто будет их вести (аномалия вставки)
        \item При необходимости изменения названия дисциплины придется просматривать все отношение (аномалия модификации)
        \item При добавлении новой группы необходимо будет измерять структуру таблицы -- добавлять новый столбец -- разреженность данных 
    \end{itemize}
\end{nota}

\newpage

\subsection{Первая, вторая и третья нормальные формы (1НФ, 2НФ и 3НФ)}

\begin{defin}{Определение 1НФ}
    Отношение находится в первой нормальной форме тогда и только тогда, когда 

    \begin{enumerate}
        \item Определен его первичный ключ 
        \item Все его атрибуты содержат атомарные значения
        \item Нет многозначных атрибутов (повторяющихся групп атрибутов)
    \end{enumerate}

    Для приведения отношения к 1НФ следует: 

    \begin{itemize}
        \item Разделить сложные атрибуты на атомарные 
        \item Повторяющиеся атрибуты совместить 
        \item Пересмотреть состав атрибутов РК 
    \end{itemize}
\end{defin}

\begin{defin}{Определение 2НФ}
    Отношение находится во второй нормальной форме (2НФ), тогда и только тогда, когда оно находится в 1НФ и каждый его неключевой атрибут функционально полно зависит от первичного ключа. Если первичный ключ отношения состоит из одного атрибута, оно автоматически находится во 2НФ 

    Для приведения отношения к 2НФ следует: выделить неключевые атрибуты, которые зависят только от части первичного ключа и перенести их в новое отошение вместе с той частью ключа, от которой они зависят
\end{defin}

\begin{defin}{Определение 3НФ}
    Отношение находится в тертьей нормальной форме (3НФ) тогда и только тогда, когда оно находится во 2НФ и не содержит транзитивных функциональных зависимостей между неключевыми атрибутами и первичным ключом. Ни один неключевой атрибут не должен функционально зависеть от другого неключевого атрибута

    Для приведения отношения к 3НФ следует: создать новое отношение и перенести в него атрибуты с одной и той же зависимостью от неключевого атрибута 
\end{defin}

\textbf{Тут есть примеры приведения к 2НФ и 3НФ, но для их понимания следует посмотреть презентацию}

\newpage

\section{Лекция 6. Создание БД и таблиц}

\subsection{Создание базы данных}

\begin{nota}{Кластер баз данных}
    При инициализации кластера БД создается три базы данных:

    \begin{itemize}
        \item postgres -- используется при подключении по умолчанию пользователем postgres. Не является обязательной, но некоторые утилиты предполагают ее наличие 
        \item template0 -- базовый шаблон. Не должен изменяться! Нужен как минимум в двух ситуациях 
        
        \begin{enumerate}
            \item Для восстановления БД из резервной копии (pg\_dump)
            \item При создании новой БД с кодировкой, отличной от указанной при инициализации кластера
        \end{enumerate}
        
        \item template1 -- шаблон для создания новых БД. Используется по умолчанию в команде CREATE DATABASE. Может быть удален и создан заново на основе template0 (необходимо сбросить флаг pg\_database.datistemplate=false)
    \end{itemize}
\end{nota}

\begin{Remark}{}
    template1, template0 -- служебные базы данных, которые служат шаблоном для создания новых баз 

    postgres -- пустая база данных, для подключения служебных утилит 
\end{Remark}

\begin{nota}{Размер баз данных}
    \begin{center}
        \begin{tabular}{|m{15em}|m{20em}|}
            \hline
            Максимальный размер БД & Неограничен* \\
            \hline
            Максимальный размер таблицы & 32 ТБ \\
            \hline
            Максимальный размер записи (строки) в таблице & 1,6 ТБ \\
            \hline
            Максимальный размер поля в записи (строке) & 1 ГБ \\
            \hline
            Максимальное количество записей (строк) в таблице & Не ограничено \\
            \hline
            Максимальное количество полей (колонок) в таблице & 250-1600 в зависимости от типа данных в колонке \\
            \hline
            Максимальное количество индексов на таблицу & Не ограничено \\
            \hline
        \end{tabular}
    \end{center}
\end{nota}

\begin{nota}{Создание БД}
\begin{lstlisting}
CREATE DATABASE name 
    [ [ WITH ] ] [ OWNER [=] user_name ]
                  [ TEMPLATE [=] template | DEFAULT ]
                  [ ENCODING [=] encoding ]
                  [ LC_COLLATE [=] sort_category ]
                  [ LC_CTYPE [=] char_type ]
                  [ TABLESPACE [=] tablespace | DEFAULT ]
                  [ ALLOW_CONNECTIONS [=] true | false ]
                  [ CONNECTION LIMIT [=] -1 | limit ]
                  [ IS_TEMPLATE [=] true | false ]
\end{lstlisting}

    Необходимо быть суперпользователем или иметь специальное право CREATEDB

    Чтобы шаблон можно было использовать для создания базы, к нему не должно быть активных подключений 

    Конфигурационные параметры уровня БД и разрешения уровня БД из шаблоне не копируются

    CREATE DATABASE нельзя выполнять внутри блока транзакции 
\end{nota}

\begin{Example}{Примеры создания БД}
\begin{lstlisting}
CREATE DATABASE TestDB;

CREATE DATABASE sales 
WITH
    OWNER salesapp
    TABLESPACE salesspace;

CREATE DATABASE hr 
WITH 
    ENCODING = 'UTF8'
    OWNER = hr 
    CONNECTION LIMIT = 100 
    TEMPLATE template0;
\end{lstlisting}
\end{Example}

\begin{nota}{Параметры БД}
    \begin{itemize}
        \item IS\_TEMPLATE (datistemplate)
        
        \begin{itemize}
            \item true -- пользователи с правом CREATEDB могут клонировать БД 
            \item false -- только суперпользователь и владелец БД могут ее клонировать 
        \end{itemize}

        \item ALLOW\_CONNECTIONS (datallowconn)
        
        \begin{itemize}
            \item true -- пользовательские подключения к БД разрешены 
            \item false -- новые подключения к этой БД не допустимы
        \end{itemize}

        БД template0 помечена как datallowconn = false для избежания любых модификаций 
    

        \item CONNECTION LIMIT (datconnlimit)
        
        \begin{itemize}
            \item -1 (по умолчанию) -- снимает ограничение 
            \item Не распространяется на суперпользователей и фоновые рабочие процессы 
        \end{itemize}
    \end{itemize}
\end{nota}

\begin{Remark}{Ошибки}
    \begin{itemize}
        \item Нет разрешения на выполнение CREATE DATABASE
        \item Недостаточно прав в каталоге данных 
        \item Недостаточно места на диске или другие проблемы в файловой системе 
        \item Есть активные подключения к шаблону 
    \end{itemize}
\end{Remark}

\begin{nota}{Изменение параметров БД}
\begin{lstlisting}
ALTER DATABASE name [ [ WITH ] params [...] ];
ALTER DATABASE name RENAME TO new_name;
ALTER DATABASE name OWNER TO {new_owner | CURRENT_USER | SESSION_USER};
ALTER DATABASE name SET TABLESPACE new_tablespace;
\end{lstlisting}

\begin{itemize}
    \item Изменение параметров на уровне базы данных: ALLOW\_CONNECTIONS, CONNECTION LIMIT, IS\_TEMPLATE
    \item Изменение имени БД. Текущую БД переименовывать нельзя (подключитесь к другой БД)
    \item Изменение владельца БД 
    \item Изменение табличного пространства по умолчанию для БД. Новое табличное пространство не должно содержать объекты этой БД
\end{itemize}
\end{nota}

\begin{nota}{Изменение конфигурационных переменных времени выполнения}
\begin{lstlisting}
ALTER DATABASE name SET config_parameter {TO|=} {value|DEFAULT};
ALTER DATABASE name SET config_parameter FROM CURRENT;
ALTER DATABASE name RESET config_parameter;
ALTER DATABASE name RESET ALL;
\end{lstlisting}

    Значение переменных (параметров), заданных для БД, переопределяют значения в postresql.conf иил полученные через командную строку postgres
\end{nota}

\begin{nota}{удаление базы данных}
\begin{lstlisting}
DROP DATABASE name
\end{lstlisting}

    При удалении БД удаляются все ее объекты 

    Удаление базы данных это необратимая операция 

    Невозможно выполнить команду DROP DATABASE пока существует хоть одно подключение к заданной базе. Нужно подключиться к любой другой БД, в том числе и template1 

    Нужно быть владельцем БД или суперпользователем 
\end{nota}

\begin{nota}{Размер базы данных}
    Размер базы данных можно узнать с помощью функции pg\_database\_size

    Вывести размер с указанием единиц измерения -- pg\_size\_pretty
\end{nota}

\newpage

\subsection{Схемы}

\begin{defin}{Базы данных и схемы}
    Кластер баз данных (экземпляр) состоит из баз данных 

    База данных содержит различные схемы 

    Схемы содержат объекты. В каждой БД есть набор стандартных схем: pg\_catalog, public

    Клиент в БД может работать с объектами в любых схемах 
\end{defin}

\begin{nota}{Именование объектов БД}
    Имя\_сервера.Имя\_БД.Имя\_схемы.Имя\_объекта

    Правила именования объектов:

    \begin{itemize}
        \item Должно начинаться с буквы 
        \item Может быть длиной до 128 символов 
        \item Должно содержать только символы A-Z, a-z, 0-9, \_, \$, \#
        \item Не должно совпадать с именем другого объекта БД 
        \item Не должно совпадать с зарезервированным словом языка 
        \item Ограничителем имени является двойная кавычка (имена нарушающие правила или чувствительные к регистру)
    \end{itemize}
\end{nota}

\begin{nota}{Разрешение имен}
    Указание схемы объекта: квалифицированное имя объекта явно определяет схему -- схема.имя. Имя без квалификатора проверяется в схемах, указанных в пути поиска 
\end{nota}

\begin{nota}{Специальные схемы}
    \begin{itemize}
        \item Схема pg\_catalog -- схема для объектов системного каталога
        \item Схема public -- схема для размещения объектов по умолчанию 
        \item Схема pg\_temp. Автоматически создается для временных таблиц в каждом сеансе. По окончании сеанса все объекты временной схемы удаляются 
    \end{itemize}
\end{nota}

\begin{Example}{Управление схемами}
    \begin{enumerate}
        \item Создание схемы 
        
\begin{lstlisting}
CREATE SCHEMA name;
\end{lstlisting}

        \item Удаление пустой схемы (не содержащую объектов)
        
\begin{lstlisting}
DROP SCHEMA name;
\end{lstlisting}

        \item Удаление схемы со всеми содержащимися в ней объектами 

\begin{lstlisting}
DROP SCHEMA name CASCADE;
\end{lstlisting}
    \end{enumerate}
\end{Example}

\newpage 

\subsection{Таблицы}

\begin{Remark}{Важно}
    Таблицы являются основными строительными блоками для хранения данных в вашей базе данных 

    Прежде чем создавать какие-либо таблицы БД, необходимо: 

    \begin{itemize}
        \item Спроектировать структуру объектов базы данных, выбрав имена, типы и назначение всех столбцов в каждой таблице 
        \item Убедиться, что взаимосвязь каждой таблицы с другой таблицей четко определена 
        \item Вдумчивое планирование поможет избежать ошибок при выборе подходящих типов данных 
    \end{itemize}

    Ваша БД должна обеспечивать поддержку бизнес-процессов выбранной предметной области и гарантировать целостность данных 
\end{Remark}

\begin{nota}{Типы таблиц}
    \begin{itemize}
        \item Постоянные 
        \item Временные 
        \item Нежурналируемые 
    \end{itemize}
\end{nota}

\begin{nota}{Создание таблиц}
    CREATE TABLE создает новую пустую таблицу в текущей БД. Владельцем таблицы будет пользователь, выполнивший эту команду 

    TABLESPACE -- определеяет место хранения данных таблицы. Если табличное пространство не указано, выбирается default\_tablespace для обычных или temp\_tablespace для временных таблиц
\end{nota}

\begin{Example}{}
\begin{lstlisting}
CREATE TABLE "Sales"."CustomersOrders" (
    OrderID serial NOT NULL,
    OrderDate date NOT NULL,
    CustomerID int NOT NULL,
    Notes varchar(200) NULL
)
TABLESPACE diskvol1;
\end{lstlisting}
\end{Example}

\begin{nota}{Временные таблицы}
    Временные таблицы: 

    \begin{itemize}
        \item Существуют в рамках только одной сессии (размещаются в локальном кеше)
        \item Не поддерживают ограничение FOREIGN KEY 
        \item Размещаются в специальной схеме pg\_temp (pg\_temp\_N). При создании таких таблиц имя схемы задать нельзя. Схема pg\_temp автоматически включается первой в путь поиска по умолчанию. Постоянная таблица с тем же именем не будет видна в текущем сеансе без указания схемы 
        \item Операции над данными не пишутся в WAL -- данные не защищены от сбоя 
        \item Все индексы автоматически становятся временными 
    \end{itemize}
\end{nota}

\begin{nota}{Время жизни временной таблицы}
    Временные таблицы автоматически удаляются в конце сеанса 

    Время жизни может быть ограничено рамками явной транзакции 

    Поведение на ON COMMIT:

    \begin{itemize}
        \item PRESERVE ROWS -- никакое специальное действие в конце транзакции не выполняется. Это поведение по умолчанию 
        \item DELETE ROWS -- все строки будут удаляться в конце каждого блока транзакции (TRUNCATE)
        \item DROP -- временная таблица будет удалена в конце текущего блока транзакции. Если у таблицы есть потомки в иерархии наследования, они также будут удалены 
    \end{itemize}
\end{nota}

\begin{Remark}{ВАЖНО!}
    Демон автоочистки не может читать и, как следствие, сжимать и анализировать временные таблицы. Соответствующие операции очистки и анализа следует выполнять, вызывая SQL-команды в рамках сеанса 

    Если временную таблицу планируется использовать в сложных запросах, следует выполнить для нее ANALYZE после заполнения ее данными 
\end{Remark}

\begin{defin}{Нежурналируемые таблицы}
    При указании параметра UNLOGGED -- таблица создается как нежурналируемая:

    \begin{itemize}
        \item Операции над данными не пишутся в WAL, работают гораздо быстрее обычных 
        \item Не восстанавливается при сбое 
        \item Содержимое нежурналируемой таблицы не реплецируется на ведомые серверы 
        \item Любые индексы автоматически становятся нежурналируемыми 
        \item Все последовательности нежурналируемой таблицы создаются как нежурналируемые 
    \end{itemize}
\end{defin}

\begin{nota}{Создание копии таблицы}
\begin{lstlisting}
CREATE TABLE new_table_name 
(LIKE source_table_name {INCLUDING|EXCLUDING} 
    {COMMENTS|COMPRESSION|CONSTRAINTS
    |DEFAULTS|GENERATED|IDENTITY|INDEXES
    |STATISTICS|STORAGE|ALL});

CREATE TABLE student_1
(LIKE student INCLUDING INDEXES INCLUDING COMMENTS);
\end{lstlisting}

    Создает новую таблицу со структурой родительской таблицы

    CREATE TABLE LIKE не копирует какие-либо данные 
\end{nota}

\begin{defin}{Создание таблицы на основе выборки; SELECT AS}
\begin{lstlisting}
CREATE [TEMPORARY|UNLOGGED] TABLE [IF NOT EXISTS] new_table_name
AS query;
\end{lstlisting}

    Оператор CREATE TABLE AS создает новую таблицу и заполняет ее данными, возвращенными запросом. Столбцы новой таблицы будут иметь имена и типы данных, связанные с выходными столбцами предложения SELECT 

    Если предложение SELECT содержит выражения, необходимо определить названия для вычисляемых столбцов: либо в качестве алиасов, либо в определении таблицы 
\end{defin}

\begin{defin}{Создание таблицы на основе выборки; SELECT INTO}
\begin{lstlisting}
SELECT select_list
INTO [TEMPORARY|UNLOGGED] [TABLE] new_table_name
FROM table_name 
WHERE search_condition;
\end{lstlisting}

    Оператор SELECT INTO создает новую таблицу и вставляет в нее данные, возвращенные запросом. В новой таблице будут столбцы с именами, такими же, как у столбцов результирующего набора запроса. В отличие от обычного оператора SELECT, оператор SELECT INTO не возвращает результат клиенту
\end{defin}

\begin{Remark}{}
    В языке PL/pgSQL оператор SELECT INTO используется для выбора данных в переменные 

    Поэтому для создания таблицы на основе выборки рекомендуется использовать оператор CREATE TABLE AS, которые предоставляет больше возможностей, чем оператор SELECT INTO
\end{Remark}

\newpage 

\subsection{Определение столбцов}

\begin{defin}{Определение столбцов}
\begin{lstlisting}
column_name data_type
[COLLATE sort_rule] [column_constraint [ ... ]]
\end{lstlisting}

    \begin{itemize}
        \item Тип данных -- определяет набор допустимых значений столбца. Может включать определение массива с этим типом
        \item COLLATE -- определяет правило сортировки для символьного столбца. Если оно отсутствует, используется правило сортировки по умолчанию, установленное для типа данных столбца 
        \item Ограничение\_столбца -- задают ограничения (проверки), которым должны удовлетворять добавляемые или изменяемые значения 
    \end{itemize}
\end{defin}

\begin{defin}{Генерируемые столбцы}
    Поддерживается 3 типа генерируемых столбцов:

    \begin{itemize}
        \item Вычисляемый столбец на основе выражения 
        \item Столбец идентификации 
        \item Столбец SERIAL 
    \end{itemize}
\end{defin}

\begin{nota}{Вычисляемый столбец на основе выражения}
\begin{lstlisting}
GENERATED ALWAYS AS (expression) STORED
\end{lstlisting}

    Значения в столбце вычисляется с помощью генерирующего выражения, которое: 

    \begin{itemize}
        \item Может обращаться к другим столбцам данной таблицы 
        \item Не может обращаться к другим генерируемым столбцам 
        \item Должно включать только постоянные функции и операторы 
    \end{itemize}

    STORED -- значения вычисляются при записи (добавлении или изменении) и сохраняются на диске. Виртуальные столбцы (вычисляются при чтении) не реализованы!
\end{nota}

\begin{nota}{Столбец идентификации}
\begin{lstlisting}
GENERATED {ALWAYS|BY DEFAULT} AS IDENTITY [(sequence_options)]
\end{lstlisting}

    Автоматически создается неявная последовательность, из которой столбец будет автоматически получать значения. Столбцу неявно назначается свойство NOT NULL

    ALWAYS -- при вставке (INSERT) пользовательское значение используется, только если указано OVERRIDING SYSTEM VALUE. При обновлении (UPDATE) любое отличное от DEFAULT значение будет отвергнуто 

    BY DEFAULT -- при вставке (INSERT) пользовательское значение имеет приоритет. При обновлении (UPDATE) столбец может быть изменен обычным образом 

    Параметры\_последовательности позволяют определить свойства последовательности -- (START [WITH] начало INCREMENT [BY] шаг MAXVALUE макс\_значение)
\end{nota}

\begin{nota}{Столбец SERIAL}
    В PostgreSQL имеется особый тип для создания столбцов идентификации -- SERIAL

    \begin{itemize}
        \item В основе этого типа лежит тип INTEGER 
        \item Столбцу неявно назначается свойство NOT NULL 
        \item Автоматически создается явная последовательность 
        \item Автоматически определяется ограничение DEFAULT, которое получает значение с помощью функции nextval() 
    \end{itemize}

    Для каждого поля этого типа создается таблица, которая содержит, помимо прочего, текущее число из последовательности. При извлечении очередного номера из последовательности текущее число увеличивается 

    Получить имя созданной последовательности -- pg\_get\_serial\_sequence
\end{nota}

\begin{nota}{Столбцы содержащие массивы}
    Для определения столбца массива необходимо после указания типа данных добавить пару квадратных скобок. Скобки указывабт на то, что в этот столбец можно без ограничений вставлять более одного значения описываемого типа данных: 

    \begin{itemize}
        \item single\_array type[] -- одномерный массив значений 
        \item multi\_array type[][] -- многомерный массив значений
    \end{itemize}

    Преимущества сохранения значений в массиве, по сравнению с сохранением в одной текстовой строке: 

    \begin{itemize}
        \item Каждое значение хранится физически отдельно от другого значения в столбце массива 
        \item Система знает, где начинается и заканчивается каждое значение массива, что позволяет выбирать значения по их индексу, а не вручную анализировать их из длинной текстовой строки 
    \end{itemize}
\end{nota}

\newpage 

\subsection{Изменение и удаление таблиц}

\begin{nota}{Изменение таблиц}
\begin{lstlisting}
ALTER TABLE table_name action;
{RENAME TO|ADD COLUMN ...|RENAME COLUMN ...
|ALTER COLUMN ...|DROP COLUMN ...[CASCADE]}
\end{lstlisting}

    Поддерживаемые операции: 

    \begin{itemize}
        \item Rename To -- переименование таблицы
        \item Add column -- добавление столбца
        \item Rename Column -- переименование столбца
        \item Drop Column -- удаление столбца
        \item Alter Column -- изменение характеристик столбца 
        
        \begin{itemize}
            \item Изменение типа данных 
            \item Переименование столбца 
            \item Задание/изменение значения по умолчанию 
            \item Добавление ограничений целостности 
        \end{itemize}
    \end{itemize}
\end{nota}

\begin{Remark}{ВАЖНО}
    Изменение типа данных столбца может вызвать ошибку, в случае если:

    \begin{itemize}
        \item Это может привести к усечению существующих данных
        \item Преобразование имеющихся данных к указанному типу не поддерживается 
        \item Существует ссылающийся на данный столбец внешний ключ (FK) в другой таблице 
    \end{itemize}

    Удаление столбца, являющегося первичным ключом (PK) не поддерживается при наличие соответствующего внешнего ключа (FK). В случае, если столбец действительно должен быть удален необходимо использовать параметр CASCADE - DROP ... CASCADE 
\end{Remark}

\begin{nota}{Изменение типа данных столбца}
    В том случае, когда исходный типа данных столбца изменяется на другой тип данных в пределах одной группы, например, оба типа -- числовые, то проблем обычно не возникает 

    Если исходный и целевой типы данных относятся к разным группа, тогда потребуется использование фразы USING команды ALTER TABLE 
\end{nota}

\begin{nota}{Удаление таблиц}
\begin{lstlisting}
DROP TABLE [IF EXISTS] table_name [CASCADE|RESTRICT];
\end{lstlisting}

    \begin{itemize}
        \item Параметр CASCADE позволяет удалить таблицу и зависимые от нее таблицы 
        \item Параметр RESTRICT отклоняет удаление, если от таблицы зависит какой-либо объект. Параметр RESTRICT используется по умолчанию, если вы не укажете его явно в операторе DROP TABLE
        \item Для удаления сразу нескольких таблиц необходимо перечислить их в операторе DROP TABLE через запятую 
    \end{itemize}
\end{nota}

\newpage 

\subsection{Хранение данных большого объема}

\begin{nota}{Структура хранения данных}
    Данные каждой таблицы сохраняются в отдельном файле. Каждый файл занимает не больше 1Гб (может быть изменено при сборке) и имеет свой уникальный идентификатор -- relfilenode. Если таблица больше 1Гб, то ее данные сохраняются в нескольких файлах 

    Файлы состоят из 8Кб страниц, которые в случае необходимости помещаются в буферный кэш. Версия строки должна целиком помещаться на одну страницу 
\end{nota}

\begin{nota}{Хранение данных большого объема}
    Использование PostgreSQL фиксированного размера страниц не позволяет кортежам занимать несколько страниц 

    Поэтому для сохранения очень больших значений полей (varchar/text/bytea/numeric), может быть использована одна из следующих стратегий: 

    \begin{itemize}
        \item Сжать данные столбца 
        \item Вынести данные соответствующего столбца в отдельную служебную таблицу 
        \item Объединить оба способа 
    \end{itemize}

    В PostgreSQL используется технология TOAST -- The Oversized Attributes Storage Technique

    \begin{itemize}
        \item Фактически для каждой таблицы с потенциально большими полями атоматически создается парная TOAST-таблица с нарезкой каждой большой записи сегментами по 2Кб (и к ней специальный индекс)
        \item Если приходится записывать строку с большим значением, то реальная запись произойдет не только в основную таблицу, но и в TOAST 
        \item Данные из TOAST-таблицы читаются только при обращении к длиному атрибуту 
    \end{itemize}
\end{nota}

\begin{nota}{Способы хранеия больших значений}
    Все столбцы имеют связанную с ними стратегию хранения:

    \begin{itemize}
        \item Plain (p) -- не допускает ни сжатия, ни внешнего хранения (numbers, chars)
        \item Extended (x) -- допускает как сжатие, так и внешнее хранение. Это значение по умолчанию для большинства типов данных, поддерживающих TOAST. Сначала предпринимается попытка сжатия, если строка все еще слишком велика создается TOAST таблица 
        \item Main (m) -- допускает сжатие, а внешнее хранение применяется как крайняя мера, когда нет другого способа уменьшить строку (numeric)
        \item External (e) -- допускает отдельное хранение, но не сжатие (сразу создает TOAST-таблицу). Ускоряет работу с данными в текстовых (text) и байтовых (bytea) столбцах 
    \end{itemize}
\end{nota}

\begin{nota}{Системные данные таблицы}
    PostgreSQL определяет ряд системных столбцов во всех таблицах, которые обычно невидимы для пользователя. Они не будут отображаться в запросах, если они не запрошены явно 

    Эти столбцы содержат метаданные о содержимом строк таблицы. Многие из них содержат данные, которые могут помочь различать кортежи (отдельные состояния строки) при работе с блоками транзакций. Любая строка таблицы, в дополнение к пользовательским столбцам, будет иметь значения в каждом из системных столбцов 
\end{nota}

\begin{nota}{Системные столбцы}
    \begin{center}
        \begin{tabular}{|m{14em}|m{22em}|}
            \hline
            Системный столбец & Описание \\
            \hline
            tableoid (table object identifier) & oid таблицы, содержащей строку. Имя и oid таблицы связаны системной таблицей pg\_class \\
            \hline
            xmin (transaction minimum) & Идентификатор транзакции, вставившей запись \\
            \hline
            cmin (command minimum) & Идентификатор команды, начинающийся с 0, связанный с транзакцией вставки записи \\ 
            \hline
            xmax (transaction maximum) & Идентификатор транзакции, удалившей запись. Если запись видна (не была удалена), он устанавливается равным нулю \\ 
            \hline
            cmax (command maximum) & Идентификатор команды, связанный с транзакцией удаления записи. Как и xmax, если запись видна, он устанавливается равным нулю \\
            \hline
            ctid (tuple identifier) & Идентификатор, описывающий физическое расположение записи в базе данных. ctid представлен парой чисел: номер блока и индекс записи в этом блоке \\
            \hline
        \end{tabular}
    \end{center}
\end{nota}

\newpage 

\subsection{Создание представлений VIEWS}

\begin{Remark}{Для чего нужны представления?}
    При работе с SQL часто возикают ситуации, когда требуется использовать запросы повторно. Это особенно актуально при работе с большими или сложными запросами -- вы можете запросить представление, основанное на сложном запросе, с помощью просто SELECT оператора. Передача чрезмерно больших запросов по сети на ваш сервер PostgreSQL для часто выполняемых подпрограмм может оказаться крайне неэффективной

    По умолчанию, представление лишено физической материализации, поэтому указанный запрос будет выполняться при каждом обращении к представлению 

    С точки зрения администратора, представления позволяют обеспечить уровень безопасности для данных в БД 
\end{Remark}

\begin{defin}{Создание представления (View)}
\begin{lstlisting}
CREATE [OR REPLACE] [TEMP|TEMPORARY] 
[RECURSIVE] VIEW name [(column_name [,...])]
    [WITH (view_option [= value] [, ...])]
    AS query
    [WITH [CASCADED | LOCAL] CHECK OPTION]
\end{lstlisting}

    Представление -- это сохраненные в БД именованные запросы. Вы можете ссылаться на представление в операторе SELECT, как на таблицы (виртуальные). Столбцы результирующей выборки должны иметь уникальные имена и желаемые типы 

    Представление определяются с помощью оператора SELECT 

    Если в определении представления задействованы временные таблицы, представление так же создается как временное (вне зависимости от присутствия явного указания TEMPORARY)

    Если при создании представления в предложении SELECT было указано *, столбцы, добавляемые в таблицу позже, частью представления не будут!
\end{defin}

\begin{nota}{Безопасность}
    Владелец представления должен иметь соответствующие права на нижележащие базовые отношения (таблицы и/или представления)

    Для пользователя представления доступ к таблицам, используемым в SELECT-запросе представления, определяется правами владельца представления. Это позволяет организовать безопасный, но ограниченный доступ к нижележащим таблицам
    
    Если в представлении используются пользовательские функции пользователь представления должен иметь все права, необходимые для вызова всех функций, задействованных в представлении 
\end{nota}

\begin{defin}{Изменяемые представления}
    Если представление удовлетворяет следующим требованиям, оно может использоваться для модификации данных в исходной таблице: 

    \begin{itemize}
        \item Запрос должен ссылаться на одну базовую таблицу (или изменяемое представление) в предложении FROM 
        \item Опрееделение представления не должно содержать предложения WITH, DISTINCT, GROUP BY, HAVING, LIMIT и OFFSET на верхнем уровне запроса 
        \item Определение представления не должно содержать операции с множествами (UNION, INTERSECT, EXCEPT) на верхнем уровне запроса
        \item Список выборки в запросе не должен содержать агрегатные и оконные функции, а также функции, возвращающие множества 
    \end{itemize}

    Пользователь, выполняющий операции добавления, изменения или удаления данных через представление, должен иметь соответствующие права для этого представления 
\end{defin}

\begin{defin}{Изменяемые представления с WHERE}
    Если автоматически изменяемое представление содержит условие WHERE, это условие ограничивает набор строк, которые могут быть изменены командой UPDATE и удалены командой DELETE в этом представлении 
\end{defin}

\begin{Remark}{Внимание}
    \begin{itemize}
        \item UPDATE может изменить строку так, что она больше не будет соответствовать условию WHERE и больше не будет видна через представление 
        \item INSERT может вставить в базовое отношение строки, которые не удовлетворят условию WHERE и поэтому не будут видны через представление  
        \item ON CONFLICT UPDATE может подобным образом воздействовать на существующую строку, не видимую через представление 
    \end{itemize}
\end{Remark}

\begin{nota}{Поддержка изменений исходных данных}
\begin{lstlisting}
[WITH[CASCADED|LOCAL] CHECK OPTION]
\end{lstlisting}

    Управляет поведением автоматически имзеняемых представлений, не имеющих триггеров INSTEAD OF: если указание CHECK OPTION отсутствует, команды INSERT и UPDATE смогут создавать в этом представлении строки, которые нарушают условие фильтрации, заданные в представлении 

    LOCAL -- новые строки проверяются только по условиям, определенным непосредственно в самом представлении. Любые словия, определенные в нижележащих базовых представлениях, не проверяются (если только в них нет указания CHECK OPTION)

    CASCADED (по умолчанию) -- новые строки проверяются по условиям данного представления и всех нижележащих базовых 
\end{nota}

\begin{nota}{Параметры представления}
\begin{lstlisting}
WITH (option_name [= value] [, ...])
\end{lstlisting}

    \begin{itemize}
        \item check\_option (enum). Может принимать значение local (локально) или cascaded (каскадно). Равнозначен указанию WITH [CASCADED | LOCAL] CHECK OPTION. Изменить этот параметр у существующего представления с помощью ALTER VIEW нельзя!
        \item security\_barrier (boolean). Следует использовать, если представление должно обеспечивать защиту на уровне строк 
    \end{itemize}
\end{nota}

\begin{nota}{Материализованные представления}
    Материализованные представления PostgreSQL позволяют физически сохранять результат запроса. Они кэшируют результат сложного и затратного запроса и позволяют периодически обновлять этот результат (WITH DATA)

    Материализованные представления полезны во многих случаях, когда требуется быстрый доступ к данным, поэтому они часто используются в хранилищах данных и приложениях бизнес-аналитики 
\end{nota}

\begin{nota}{Загрузка данных в материализованное представление}
    При создании представления с параметром WITH NO DATA представление помечается как нечитаемое. Вы не можете запрашивать данные из представления, пока не загрузите данные! 

    Для загрузки данных в материализованное представление используется оператор REFRESH MATERIALIZED VIEW
\end{nota}

\begin{nota}{Изменение представления}
    Для изменения запроса, определяющего представление, используется оператор CREATE OR REPLACE VIEW 

    Измененный запрос должен генерировать те же столбцы, которые были созданы при создании представления

    \begin{itemize}
        \item PostgreSQL не поддерживает удаление существующего столбца в представлении
        \item Новые столбцы должны иметь те же имена, те же типы данных и в том же порядке, в котором они были указаны при создании представления
        \item PostgreSQL позволяет добавлять дополнительные столбцы в конец списка столбцов 
    \end{itemize}
\end{nota}

\begin{nota}{Изменение определения представления}
    Для изменения имени представления, имени столбца, владельца или схемы представления используется оператор ALTER VIEW

\begin{lstlisting}
ALTER VIEW [IF EXISTS] name ALTER [COLUMN] column_name SET 
    DEFAULT expression;
ALTER VIEW [IF EXISTS] name ALTER [COLUMN] column_name DROP DEFAULT;
ALTER VIEW [IF EXISTS] name OWNER TO {new_owner 
    | CURRENT_USER | SESSION_USER};
ALTER VIEW [IF EXISTS] name RENAME [COLUMN] column_name TO 
    new_column_name;
ALTER VIEW [IF EXISTS] name RENAME TO new_view_name;
ALTER VIEW [IF EXISTS] name SET SCHEMA new_schema;
\end{lstlisting}
\end{nota}

\begin{nota}{Изменение параметров представления}
\begin{lstlisting}
ALTER VIEW [IF EXISTS] name SET (option [= value] [, ...]);
ALTER VIEW [IF EXISTS] name RESET (option [, ...]);
\end{lstlisting}

    В настоящее время поддерживаются следующие параметры:

    \begin{itemize}
        \item check\_option (enum) -- изменяет параметр проверки представления: local (локально) или cascaded (каскадно)
        \item security\_barrier (boolean) -- изменяет свойство представления, включающее барьер безопасности (true или false)
    \end{itemize}
\end{nota}

\begin{nota}{Удаление представления}
    Чтобы удалить существующее представление в PostgreSQL используется оператор DROP VIEW

    \begin{itemize}
        \item CASCADE -- автоматически удалять объекты, зависящие от данного представления (например, другие представления), и, в свою очередь, все зависящие от них объекты 
        \item RESTRICT -- отказывать в удалении представления, если от него зависят какие-либо объекты. Это поведение по умолчанию!
    \end{itemize}

    Выполнить эту команду может только владелец представления 
\end{nota}

\newpage 

\section{Лекция 7. Создание ограничений}

\subsection{Внедрение ограничений целостности данных}

\begin{defin}{Ограничения}
    Ограничения -- механизм Database Engine для автоматического обеспечения целостности данных в базе данных 

    Ограничения обеспечивают:

    \begin{itemize}
        \item Сущностную целостность 
        \item Доменную целостность 
        \item Ссылочную целостность 
    \end{itemize}

    Типы ограничений целостности данных:

    \begin{itemize}
        \item Разрешение значений NULL 
        \item Определения DEFAULT значений 
        \item Ограничения CHECK 
        \item Ограничения UNIQUE
        \item Ограничения PRIMARY KEY
        \item Ограничения FOREIGN KEY
        \item Ограничения EXCLUSION
    \end{itemize}
\end{defin}

\begin{nota}{Ограничение NOT NULL}
    Ограничение уровня столбца, определяемого при создании или модификации таблицы 

    NOT NULL указывает, что в столбце недопустимы значения NULL 
\end{nota}

\begin{nota}{Определения DEFAULT значений}
    Ограничение уровня столбца, определяемого при создании или модификации таблицы 

    Определяет значение по умолчанию, которым Database Engine будет заполнять столбец, если при вставке строки для этого столбца значение не указано 

    При определении значения по умолчанию для новой колонки, добавляемой в существующую таблицу не происходит фактического добавления значений во все существующие записи 
\end{nota}

\begin{nota}{Ограничение CHECK}
    Ограничения CHECK может быть определено на уровне столбца или таблицы при создании или модификации таблицы. Для каждого столбца можно указать несколько непротиворечивых ограничений CHECK 

    Ограничение CHECK позволяет указать логическое условие для одного или нескольких столбцов, которое должно быть выполнено перед вставкой или обновлением значений. Использует логическое выражение для оценки значений перед их вставкой или обновлением в столбце. Если значения проходят проверку, PostgreSQL вставит или обновит эти значения в столбце. В противном случае PostgreSQL отклонит изменения и выдаст ошибку нарушения ограничения 

    Если при создании ограничения не указать его имя, PostgreSQL задаст его сам 
\end{nota}

\begin{nota}{Ограничение UNIQUE}
    Может быть задано на уровне столбца или таблицы при создании или модификации таблицы

    Обеспечивает уникальность записей в таблице (альтернативный ключ). При вставке новой строки, ограничение UNIQUE проверяет, является ли значение уникальным. Если значение не является уникальным (значение уже существует в столбце таблицы) -- изменение отклоняется и выдается ошибка. Тот же процесс выполняется для обновления существующих данных 

    Допускает наличие NULL-значений в столбце, при условии что не установлено ограничение NOT NULL

    Автоматически создается связанный с ограничением уникальный индекс 

    Если при создании ограничения не указать его имя, PostgreSQL задаст его сам
\end{nota}

\begin{Remark}{Добавление и удаление ограничения UNIQUE}
    При добавлении ограничения UNIQUE к существующему столбцу таблицы, в котором есть неуникальные значения -- будет выдано сообщение об ошибке
    
    При удалении ограничения UNIQUE, автоматически удаляется связанный с ограничением уникальный индекс
\end{Remark}

\begin{nota}{Ограничение PRIMARY KEY}
    Может быть задано на уровне столбца или таблицы при создании или модификации таблицы. Используется для создания первичного ключа таблицы

    В таблице может быть только одно ограничение PRIMARY KEY

    Столбец PRIMARY KEY не может содержать значения NULL. Технически, ограничение PRIMARY KEY представляет собой компбинацию ограничения UNIQUE и ограничения NOT NULL

    Автоматически создается связанный с ограничением уникальный индекс сбалансированного дерева

    Если при создании ограничения не указать его имя, PostgreSQL задаст его сам
\end{nota}

\begin{Remark}{Добавление и удаление ограничения PRIMARY KEY}
    При добавлении ограничения PRIMARY KEY к существующему столбцу таблицы, в котором есть неуникальные значения 00 будет выдано сообщение об ошибке 

    При попытке удаления первичного ключа, на который ссылается внешний ключ в связной таблице, будет выдано сообщение об ошибке 

    Для удаления первичного ключа и связанного с ним внешнего ключа необходимо использовать указание CASCADE

    При удалении ограничения PRIMARY KEY автоматически удаляется связанный с ограничением уникальный индекс 
\end{Remark}

\begin{nota}{Ограничение FOREIGN KEY}
    Внешний ключ -- это столбец или группа столбцов в таблице, которые ссылаются на существующий первичный или альтернативный ключ другой таблицы. Таблица, содержащая внешний ключ, называется ссылочной таблицей или дочерней таблицей. Таблица, на которую ссылается внешний ключ, называется родительской таблицей 

    Таблица может иметь несколько внешних ключей в зависимости от ее отношений с другими таблицами 

    В PostgreSQL внешний ключ определяется с помощью ограничения FOREIGN KEY. Ограничение FOREIGN KEY помогает поддерживать ссылочную целостность данных между дочерней и родительской таблицами. Ограничение внешнего ключа указывает, что значения в столбце или группе столбцов дочерней таблицы равны значениям в столбце или группе столбцов родительской таблицы

    У пользователя должно быть разрешение REFERENCES для таблиц, на которую указывают ссылки 

    Индекс не создается автоматически, поэтому его необходимо создать самостоятельно 
\end{nota}

\begin{nota}{Тип обработки}
    \begin{itemize}
        \item NO ACTION -- если при проверке ограничения обнаруживаются зависимые записи, возникает ошибка (это поведение по умолчанию). Позволяет отложить проверку в процессе транзакции или определении ограничения внешнего ключа как DEFERRABLE с режимом INITIALLY DEFERRED или INITIALLY IMMEDIATE
        \item RESTRICT -- предотвращает удаление/изменение связанной записи. Полностью запрещает удаление связанной строки и не допускает отложенной проверки до конца транзакции 
        \item CASCADE -- автоматическое удаление/изменение зависимых записей при удалении/изменении связанных записей
        \item SET NULL -- замена значений внешнего ключа на NULL в зависимых записях при удалении/изменении связанных записей
        \item SET DEFAULT -- замена значений внешнего ключа на значение по умолчанию в зависимых записях при удалении/изменении связанных записей. Необходимо определение ограничения DEFAULT для внешнего ключа. Необходимо наличие записи в главной таблице с соответсвующим значением первичного ключа 
    \end{itemize}
\end{nota}

\begin{Remark}{ВАЖНО}
    Влияние ALTER TABLE ADD CONSTRAINT: при добавлении ограничений к таблице выполняется проверка существующих данных. Сканирование большой таблицы может занять длительное время и будет препятствовать внесению других изменений до фиксирования команды ALTER TABLE ADD CONSTRAINT

    Для снижения влияния данной операции на параллельные транзакции можно отключить проверку существующих данных 
\end{Remark}

\begin{nota}{Отключение проверки существующих данных}
    Параметр NOT VALID: 

    \begin{itemize}
        \item Разрешен только для ограничений CHECK и FOREIGN KEY 
        \item Команда ALTER TABLE ADD CONSTRAINT не сканирует таблицу и может быть зафиксирована немедленно 
        \item Созданное ограничение будет применяться к последующим вставкам или обновлениям, но существующие записи будут игнорироваться 
        \item Возможность отложить проверку на время меньшей активности или провести дополнительную работу с существующими ошибками и при этом не допустить новых 
    \end{itemize}
\end{nota}

\begin{nota}{Проверка существующих данных}
    Команда VALIDATE CONSTRAINT:

    \begin{itemize}
        \item Выполняется полное скнаирование таблицы для проверки всех существующих строк на соответствие ограничению 
        \item Если огарничение уже помечено как верное, ничего не происходит 
        \item Выполнение этой команды не препятствует параллельным изменениям (для добавляемых или изменяемых строк в других транзакциях ограничение уже действует)
    \end{itemize}
\end{nota}

\newpage

\subsection{Гранулярность проверки ограничений}

\begin{nota}{Гранулярность проверки ограничений}
    В PostgreSQL существует 3 уровня проверки ограничений:

    \begin{itemize}
        \item На уровне строки: SQL-запрос, который обновляет множество строк, остановится на первой строке, не удовлетворяющей ограничению 
        \item На уровне запроса: в этом случае запрос произведет все изменения, прежде чем проверить ограничения 
        \item На уровне транзакции: любой запрос внутри транзакции может нарушить ограничение. Но в момент фиксации, ограничения будут проверены и транзакция откатится, если хотя бы одно из них будет нарушено 
    \end{itemize}
\end{nota}

\begin{nota}{DEFERRABLE}
    Чтобы иметь возможность изменять гранулярность првоерки ограничения необходимо явно объявить ограничение как отложенное (DEFERRABLE). Работает только для UNIQUE, PRIMARY KEY и REFERENCES. CHECK и NOT NULL всегда будут проверяться для каждой строки 

    При создании ограничения определить одну из следующих характеристик:

    \begin{itemize}
        \item DEFERRABLE INITIALLY DEFERRED -- откладываемое. Проверка ограничения откладывается до фиксации транзакции, но эта настройка может меняться для каждой транзакции с помощью оператора SET CONSTRAINTS
        \item DEFERRABLE INITIALLY IMMEDIATE -- откладываемое. Ограничения проверяются в конце каждого оператора, но эта настройка может меняться для каждой транзакции с помощью оператора SET CONSTRAINTS
        \item NOT DEFERRABLE INITIALLY IMMEDIATE -- не откладываемое (по умолчанию!). Ограничение проверяется после обновления каждой строки по умолчанию и мы не можем изменить этот параметр в транзакции 
    \end{itemize}
\end{nota}

\begin{nota}{Управление временем проверки ограничений для текущей транзакции}
    Чтобы указать когда будет выполняться проверка ограничений в текущей транзакции используется инструкция 

\begin{lstlisting}
SET CONSTRAINTS { ALL | name [, ...] } { DEFERRED | IMMEDIATE }
\end{lstlisting}

    Режим IMMEDIATE или DEFERRED задается для каждого ограничения независимо: ограничение IMMEDIATE проверяются в конце каждого оператора, а ограничение DEFERRED откладываются до момента фиксации транзакции

    На ограничения, созданные с параметром NOT DEFERRABLE, команда SET CONSTRAINTS не влияет!

    Для AutoCommit транзакций нет разницы между IMMEDIATE и DEFERRED для одного запроса 
\end{nota}

\begin{Remark}{ВНИМАНИЕ}
    В настоящее время это распространяется только на ограничения UNIQUE, PRIMARY KEY, REFERENCES и EXCLUDE 

    Ограничения NOT NULL и CHECK всегда проверяются немедленно в момент добавления или изменения строки (не в конце оператора)

    Ограничения уникальности (UNIQUE) и ограничения-исключения (EXCLUDE), объявленные без указания DEFERRABLE, так же проверяются немедленно 
\end{Remark}

\begin{nota}{Отложенные ограничения позволяют}
    \begin{itemize}
        \item Добавлять и изменять данные в таблицы, связанные циклическими проверками согласованности (циклические ограничения муж/жена)
        \item Сделать процесс наполнения таблиц более удобным. Отложенные внешние ключи позволяют загружать данные в таблицы в любом порядке
    \end{itemize}
\end{nota}

\begin{Remark}{Проблемы}
    \begin{itemize}
        \item Несмотря на то, что объявление ограний отложенными дает большую гибкость, не стоит откладывать все ограничения. Столбцы, на которые ссылается внешний ключ, должны быть столбцами неотложенного ограничения уникальности или первичного ключа в таблице 
        \item Неэффективная работа планировщика. Так как нет гарантий, что откладываемые ограничения буду выполняться все время, они мешают планировщику в выборе правильных и эффективных стратегий выполнения запросов. Отложенные ограничения PK допускают наличие повторяющихся значений в определенный момент времени, что снижает количество оптимизаций, которые может выполнить планировщик запросов
        \item Усложнение отладки. Получение ошибок только после завершения набора запросов усложняет отладку, так как нет возможности точно определить, какой запрос вызвал проблему
        \item Неэффективное использование ресурсов. Любая работа, выполненна после отложенного ограничения, может быть в итоге потеряна, после отката транзакции. Отложенные ограничения могут тратить CPU впустую 
    \end{itemize}
\end{Remark}

\newpage

\subsection{Дополнительные возможности}

\begin{defin}{Домен}
    Домен -- это определяемый пользователем тип данных, который может иметь необязательные ограничения (DEFAULT, NOT NULL и CHECK), ограничивающие допустимый набор значений 

    Домены полезны для абстрагирования и вынесения общих характеристик разных полей в единое место для упрощения сопровождения. Например, столбец телефон, определенный в нескольких таблицах, требует наличие ограничения CHECK, проверяющие синтаксис телефона. В этом случае лучше определить домен, а не задавать для каждой таблицы отдельные ограничения 
\end{defin}

\begin{nota}{Создание домена}
    Для создания домена используется опреатор CREATE DOMAIN

    \begin{itemize}
        \item Имя должно быть уникально в пределах схемы среди имен типов и доменов 
        \item Необходимо иметь право USAGE для исходного типа данных 
        \item Пользователь, определяющий домен, становится его владельцем 
    \end{itemize}

\begin{lstlisting}
CREATE DOMAIN domain_name [ AS ] data_type
    [ COLLATE collation ]
    [ DEFAULT expression ]
    [ CONSTRAINT constraint_name {NOT NULL | NULL | CHECK (expr)}]
\end{lstlisting}

    \begin{itemize}
        \item DEFAULT. Если значение по умолчанию не указано, им будет значение NULL. Значение по умолчанию для конкретного столбца имеет приоритет 
        \item CHECK. Задает ограничение проверки уровня столбца. Проверяемое значение в этом выражении обозначается ключевым словом VALUE. Если для домена задано несколько ограничений CHECK, они будут проверяться в алфавитом порядке имен 
    \end{itemize}
\end{nota}

\begin{Remark}{Примечания}
    Ограничения домена NOT NULL проверяется при преобразовании значения к типу домена. Если значение NULL уже имеет тип домена оно не будет дополнительно проверяться. Решение: домен -- допускает NULL, столбец доменного типа -- NOT NULL

    Ограничения CHECK проверяются только при первом преобразовании значения в тип домена. Если в выражении CHECK используется пользовательская функция, которая может быть изменена, сохраненные значения типа домена могут перестать удовлетворять ограничению CHECK и это останется незамеченным. Решение:

    \begin{itemize}
        \item Удалить ограничение (ALTER DOMAIN .... DROP CONSTRAINT)
        \item Измение определение функции 
        \item Пересоздать ограничение (при этом будет выполнена перепроверка сохраненных данных)
    \end{itemize}
\end{Remark}

\begin{Example}{Изменение домена}
\begin{lstlisting}
ALTER DOMAIN domain_name {SET DEFAULT expr | DROP DEFAULT};
ALTER DOMAIN domain_name {SET | DROP} NOT NULL;
ALTER DOMAIN domain_name ADD constraint_name [NOT VALID];
ALTER DOMAIN domain_name DROP CONSTRAINT [IF EXISTS]
    constraint_name [RESTRICT | CASCADE];
ALTER DOMAIN domain_name RENAME CONSTRAINT old_name TO new_name;
ALTER DOMAIN domain_name VALIDATE CONSTRAINT constraint_name;
ALTER DOMAIN domain_name OWNER TO {new_owner |
    CURRENT_USER | SESSION_USER};
ALTER DOMAIN domain_name RENAME TO new_name;
ALTER DOMAIN domain_name SET SCHEMA new_schema;
\end{lstlisting}
\end{Example}

\begin{nota}{Удаление домена}
    \begin{itemize}
        \item CASCADE. Автоматически удалять объекты, зависящие от данного домена (например, столбцы таблиц), и, в свою очередь, все зависящие от них объекты
        \item RESTRICT. Отказать в удалении домена, если от него зависят какие-либо объекты. Это поведение по умолчанию 
    \end{itemize}

    Удалить домен может только его владелец 
\end{nota}

\begin{defin}{Ограничение EXCLUDE}
    EXCLUDE определяет ограничение исключения, которое гарантирует, что при сравнении любых двух строк в указанных столбцах или выражениях с использованием указанных операторов хотя бы одно из этих сравнений (OR) вернет значение FALSE или NULL. Если хотя бы одно условие не выполняется -- запись будет добавлена. Если все указанные операторы проверяют равенство, это эквивалентно ограничению UNIQUE (но ограничение UNIQUE работает быстрее)

    Когда добавляется новая или обновленная строка, необходимо сравнить ее с каждой существующей строкой на основе списка сравнений, указанных в ограничении: если все сранвнения между новыми данными и существующей строкой возвращают значение TRUE, отклонить новые данные 
\end{defin}

\begin{Remark}{Синтаксис}
\begin{lstlisting}
[CONSTRAINT constraint_name] EXCLUDE [USING index_method]
(name_of_column WITH operator [, ...])
index parameters [WHERE (predicate)]
\end{lstlisting}

    Ограничения исключения реализуются с помощью индекса. На практике метод доступа всегда будет GiST или SP-GiST 

    Необходимо установить расширение btree\_gist, которое определяет ограничения исплючения для простых скалярных типов данных (выполнить один раз для каждой БД)

    Предикат позволяет указать ограничение исключения для подмножества записей таблицы (создает частичный индекс). Обратите внимание, что круглые скобки необходимы вокруг предиката 
\end{Remark}

\end{document}