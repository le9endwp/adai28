\documentclass[12pt]{article}
\usepackage{config}
\usepackage{subfiles}
\pgfplotsset{compat=1.18}

\begin{document}

\begin{flushright}
    Конспект Шорохова Сергея

    Если нашли опечатку/ошибку - пишите @le9endwp 
\end{flushright}

\tableofcontents
\newpage

\section{Лекция 1. Введение в реляционные базы данных}

\subsection{Понятие базы данных и СУБД}

\begin{defin}{Данные}
    Данные -- факты, текст, графики, картинки, звуки, аналоговые или цифровые видео-сегменты, представленные в форме, пригодной для хранения,  передачи и обработки
\end{defin}

\begin{nota}{Задачи технологий работы с данными}
    \begin{itemize}
        \item Загрузить 
        \begin{itemize}
            \item Получить
            \item Передать между системами
            \item Собрать в одном месте
        \end{itemize}
        \item Сохранить 
        \begin{itemize}
            \item Обеспечить эффективное безопасное хранение
            \item Предоставить доступ
            \item Обеспечить быстрый поиск
        \end{itemize}
        \item Обработать
        \begin{itemize}
            \item Объединить в одной структуре
            \item Рассчитать показатели
            \item Обработать модель
        \end{itemize}
        \item Принять решение
        \begin{itemize}
            \item Отчеты
            \item Дашборды
            \item Визуализация
            \item Предписание в операционном процессе
        \end{itemize}
    \end{itemize}
\end{nota}

\begin{nota}{Что должны обеспечивать системы обработки данных?}
    \begin{itemize}
        \item Поддержку необходимых требований к данными
        \begin{itemize}
            \item Сохранность и достоверность данных в соответствии со спецификой предметной области
            \item Защиту от искажения, уничтожения данных и несанкционированного доступа
            \item Простоту и легкость использования данных
            \item Требуемую скорость доступа к данным
        \end{itemize}
        \item Независимость прикладных программ от данных 
        \begin{itemize}
            \item Возможность использования одних и тех же данных различными приложениями
            \item Изменение логического представления данных (добавление/удаление новых элементов данных) не должно приводить к изменению прикладных программ обработки
            \item Изменение параметров физической организации данных (характеристик носителя, длины блока, и др.) или методов доступа к ним не должны приводить к изменению прикладных программ
        \end{itemize}
    \end{itemize}
\end{nota}

\begin{defin}{Независимость (от) данных}
    \begin{itemize}
        \item \textbf{Логическая}
        
        Изменение логического представления данных (добавление/удаление новых элементов данных, разделение на несколько логических сегментов, изменение порядка хранения) не должно приводить к изменению прикладных программ обработки
        \item \textbf{Физическая}
        
        Изменение параметров физической организации данных (характеристик носителя, длины блока, и др.) или методов доступа к ним не должны приводить к изменению логической структуры данных или прикладных программ их обработки            
    \end{itemize}
\end{defin}

\begin{nota}{Концепции обработки данных}
    \begin{itemize}
        \item \textbf{Файловая обработка данных}
        
        До середины 60-х годов прошлого века – основная концепция построения программного обеспечения обработки данных

        \item \textbf{Базы данных}
        
        Независимость прикладных программ от данных

        \item \textbf{Объектно-ориентированные базы данных}
        
        Независимость прикладных программ от данных вместе с процедурами их обработки (объектно-ориентированный подход в программировании)
    \end{itemize}
\end{nota}

\begin{Remark}{Файловая обработка данных}
    \begin{itemize}
        \item Совмещение логического и физического представления данных
        \begin{itemize}
            \item Физически данные ИС размещаются в файлах операционной системы
            \item Прикладные программы работают напрямую с файлами
            \item Структура файла зависит от требований конкретной прикладной программы, с ним работающей, и определяется разработчиком приложения
        \end{itemize}
        \item Зависимость программ обработки от организации данных
        \begin{itemize}
            \item Возможная избыточность и противоречивость данных 
            \item Для каждой задачи – свой алгоритм получения данных 
        \end{itemize}
        \item Разграничение доступа и защита данных – на уровне средств ОС
    \end{itemize}

    Она не обеспечивает:
    \begin{itemize}
        \item Поддержание логически согласованного набора файлов
        \item Единого языка манипулирования данными
        \item Восстановление информации после разного рода сбоев
        \item Реально параллельной работы нескольких пользователей
    \end{itemize}
\end{Remark}

\begin{Remark}{Базы данных}
    \begin{itemize}
        \item Разделение логического и физического представления данных
        \begin{itemize}
            \item Физически данные как правило размещаются в файлах операционной системы
            \item Разрабатывается определённая логическая структура данных, с которой «общаются» прикладные программы
            \item Логическая структура данных основана на физической, но не меняется при изменении последней
        \end{itemize}
        \item Независимость программ обработки от организации данных
        \begin{itemize}
            \item Сокращение избыточности и противоречивости данных
            \item Единые языки для получения и изменения данных
            \item Дополнительные средства разграничения доступа и защиты данных, учитывающие их логическую структуру
        \end{itemize}
    \end{itemize}
\end{Remark}

\begin{Remark}{Объектно-ориентированные БД}
    \begin{itemize}
        \item Разделение логического и физического представления данных
        \begin{itemize}
            \item Физические данные как правило размещаются в файлах операционной системы
            \item На логическом уровне данные представляют собой объекты
            \begin{itemize}
                \item Данные $\to$ свойства объекта (статическая часть)
                \item Обработка данных $\to$ методы объекта (динамическая часть)
            \end{itemize}
        \end{itemize}
        \item Независимость прикладных программ от объектов
        \item Концепция повторного использования программного кода
        \begin{itemize}
            \item Разные прикладные программы используют унифицированные методы обработки одних и тех же данных
        \end{itemize}
    \end{itemize}
\end{Remark}

\newpage

\subsection{Базы данных и СУБД}

\begin{defin}{База данных}
    База данных -- логически структурированная совокупность постоянно хранимых в памяти компьютера данных, характеризующих актуальное состояние некоторой предметной области и используемых прикладными программными системами какого-либо предприятия

    База данных (БД) -- совокупность данных, хранимых в соответствии со схемой данных, манипулирование которыми выполняют в соответствии с правилами средств моделирования данных (ГОСТ)
\end{defin}

\begin{nota}{Основные характеристики БД}
    \begin{itemize}
        \item Компьютерная система -- БД хранится и обрабатываемя в вычислительной системе
        \item Содержит структурированную информацию -- данные в БД логически структурированы (систематизированы) с целью обеспечения возможности их эффективного поиска и обработки в вычислительной системе 
        \begin{itemize}
            \item Структурированность БД оценивается не на уровне физического хранения, а на уровне некоторой логической модели данных
        \end{itemize}
        \item Поддерживает определенный набор операций над данными 
        \begin{itemize}
            \item Структурированность определяет семантику и допустимые операции
        \end{itemize}
    \end{itemize}
\end{nota}

\begin{defin}{Система баз данных (банк данных)}
    База данных является составной частью системы баз данных 

    Система базы данных -- компьютеризированная система обработки данных, хранящихся в БД

    Основные функции системы баз данных:

    \begin{itemize}
        \item Добавление новых структур данных (таблиц) в базу данных
        \item Изменение существующих структур данных (таблиц)
        \item Добавление новых элементов данных (записей в таблицы)
        \item Выборка необходимых элементов данных (записей из таблиц)
        \item Обновление элементов данных (записей в таблицах)
        \item Удаление элементов данных (записей из таблиц)
        \item Удаление структур данных (таблиц) из базы данных 
    \end{itemize}
\end{defin}

\begin{defin}{Системы управления базами данных}
    СУБД -- совокупность программных средств, предназначенная для модификации и извлечения из БД необходимых пользователю (прикладной программе) данных, а также для создания БД, поддержания их в работоспособном состоянии, обеспечения безопасности БД и решения других задач администрирования

    \textbf{Цель:} Обеспечивать совместное безопасное использование данных различными приложениями и пользователями

    Основные функции СУБД:

    \begin{itemize}
        \item Обеспечение физической и логической независимости данных
        \item Поддержка связи между логической и физической организацией данных
        \item Предоставление интерфейса доступа к данным пользователям и прикладным программам
        \item Обеспечение целостности и непротиворечивости данных при совместной работе нескольких пользователей
        \item Предоставление механизмов защиты данных
        \item Предоставление механизмов восстановления данных
    \end{itemize}
\end{defin}

\begin{nota}{Обеспечение логической и физической независимости данных}
    СУБД обеспечивает необходимые структуры внешней памяти как для хранения пользовательских данных БД, так и для служебных целей

    СУБД скрывает от пользователей как используется файловая система и как организованы файлы

    Для связи логической и физической структур данных СУБД использует служебную (мета) информация, хранящуюся в словаре данных
\end{nota}

\begin{nota}{Управление буферами оперативной памяти}
    Для увеличения скорости обработки данных используется буферизация данных в оперативной памяти

    СУБД поддерживает собственный набор буферов оперативной памяти с собственным алгоритмом замены буферов
\end{nota}

\begin{nota}{Предоставление интерфейса доступа к данным}
    Для работы с базами данных СУБД предоставляет поддержку специальных языков, называемых языками баз данных

    \begin{itemize}
        \item Язык описания данных (DDL) -- позволяет создавать и изменять структуру объектов базы данных
        \item Язык манипулирования данными (DML) -- позволяет заносить данные в БД, удалять, модифицировать или выбирать существующие данные
    \end{itemize}

    Использование данных языков позволяет пользователям сохранять, извлекать и обновлять данные в БД без необходимости понимания физической реализации системы
\end{nota}

\begin{nota}{Обеспечение целостности}
    Целостность БД -- свойство БД, означающее, что в ней содержится полная, непротиворечивая и адекватно отражающая предметную область информация 

    Целостность данных предполагает:
    
    \begin{itemize}
        \item Отсутствие неточно введенных данных или двух одинаковых записей об одном и том же факте
        \item Защиту от ошибок при обновлении данных в БД
        \item Невозможность удаления (или каскадное удаление) записей, которые связаны с другими записями
        \item Неискажение данных при работе в многопользовательском режиме
        \item Сохранность данных при сбоях техники (восстановление данных)
    \end{itemize}

    СУБД должна обладать инструментами контроля за тем, чтобы данные и их изменения соответствовали заданным правилам 
\end{nota}

\begin{nota}{Управление параллельной работой пользователей}
    Для управления параллельной работой пользователей и поддержки целостности данных в СУБД реализован механизм изоляции транзакций
\end{nota}

\begin{defin}{Транзакция}
    Транзакция -- некоторая неделимая последовательность операций над данными БД, которая отслеживается СУБД от начала и до завершения

    Если по каким-либо причинам (сбои и отказы оборудования, ошибки в программном обеспечении) транзакция остается незавершенной или при выполнении транзакции нарушается целостность данных, то она отменяется
\end{defin}

\begin{defin}{Журнализация}
    СУБД должна иметь возможность восстановить последнее согласованное состояние БД после любого аппаратного или программного сбоя 

    Для восстановления БД нужно располагать некоторой дополнительной информацией, которая должна храниться особо надежно

    Наиболее распространенным методом поддержания такой избыточной информации является ведение журнала изменений БД -- журнала транзакций
\end{defin}

\begin{nota}{Обеспечение безопасности БД}
    СУБД должна иметь механизм, гарантирующий возможность доступа к базе данных только санкционированных пользователей

    Термин безопасность относится к защите БД от преднамеренного или случайного несанкционированного доступа

    Защита данных от несанкционированного доступа может достигаться:

    \begin{itemize}
        \item Созданием ролей и ввдеением системы паролей
        \item Настройкой разрешений на доступ к данным и выполнение операций с данными
        \item Шифрованием соединения с прикладными программами
        \item Шифрованием данных 
    \end{itemize}
\end{nota}

\begin{nota}{Выбор СУБД}
    Выбор СУБД -- важный шаг при создании ИС, влияющий на эффективность, как проектирования, так и функционирования системы

    Учитывая тенденции развития ИС, СУБД должна отвечать следующим требованиям:

    \begin{itemize}
        \item Обеспечивать работу в гетерогенной сетевой среде, включая возможность эффективной работы в Интернете
        \item Легко переноситься с платформы на платформу
        \item Обеспечивать работу с большими объемами разнотипных данных
        \item Быть надежной и эффективной
    \end{itemize}
\end{nota}

\newpage

\subsection{Принципы организации базы данных}

\begin{nota}{Требования к БД и СУБД}
    \begin{itemize}
        \item Высокое быстродействие (малое время отклика на запрос)
        \item Простота обновления данных
        \item Защита данных от преднамеренного или непреднамеренного нарушения секретности, искажения или разрушения
        \item Поддержка целостности данных
        \item Независимость данных -- возможность изменения логической и физической структуры БД без изменения предсталвений пользователей
        \item Совместное использование данных многими пользователями
        \item Стандартизация построения и эксплуатации БД
        \item Адекватность отображения данных соответствующей предметной области 
    \end{itemize}
\end{nota}

\begin{nota}{Принципы организации БД}
    \begin{itemize}
        \item Разделение различных видов данных
        \begin{itemize}
            \item Данные пользовательские (приложений)
            \item Вспомогательные данные (индексы)
            \item Метаданные (словарь данных БД)
            \item Служебная информация
        \end{itemize}
        \item Позволяет повысить безопасность данных и быстродействие работы с ними
        \item Проектирование логической структуры данных 
        
        Выбор модели данных (в зависимости от требований доступа к данным)

        \item Позволяет обеспечить: 
        \begin{itemize}
            \item Логическую и физическую независимость данных 
            \item Адекватность отображения данных соответствующей предметной области 
            \item Удобство работы и гибкость
        \end{itemize}
        \item Определение ограничений данных 
        \begin{itemize}
            \item Уменьшение ошибок ввода/изменения данных 
            \item Зависимость от семантики данных
        \end{itemize}
        \item Позволяет поддержать целостность данных 
    \end{itemize}
\end{nota}

\subsection{Реляционная модель данных}

\begin{defin}{Модель данных}
    Модель данных -- формальное описание представления и обработки данных в системе управления базами данных
\end{defin}

\begin{nota}{Компоненты реляционной модели данных}
    \begin{itemize}
        \item Структурный аспект 
        
        \begin{itemize}
            \item Какие структуры данных рассматриваются реляционной моделью 
            \item Постулируется, что единственной структурой данных, используемой в реляционной модели, являются нормализованные $n$-арные отношения
        \end{itemize}

        \item Аспект целостности 
        
        \begin{itemize}
            \item Ограничения специального вида, которые должны выполняться для любых отношений в любых реляционных базах данных 
            \item Целостность сущностей реального мира 
            \item Ссылочная целостность 
        \end{itemize}

        \item Аспект обработки 
        
        \begin{itemize}
            \item Способы манипулирования реляционными данными
            \item Реляционная алгебра -- базируется на теории множеств
            \item Реляционное исчисление -- базируется на логическом аппарате исчисления предикатов первого порядка 
        \end{itemize}
    \end{itemize}
\end{nota}

\newpage

\subsection{Структурный аспект реляционной модели}

\begin{defin}{Отношение}
    Отношение (relation) -- класс объектов реального мира, каждый из которых должен быть уникально идентифицирован

    \begin{itemize}
        \item Подмножество $R$ декартового произведения множеств элементов доменов: (не обязательно различных)
        \item Или множество кортежей, соответствующих одной схеме отношения 
        \item Мощность отношения -- количество кортежей в отношении
        \item На бытовом уровне -- тело таблицы
    \end{itemize}
\end{defin}

\begin{defin}{Схема отношения}
    \begin{itemize}
        \item Именованное конечное множество пар вида $\{$Имя\_атрибута: Имя\_домена$\}$
        \item Степень или -арность (схемы) отношения -- количество атрибутов
        \item На бытовом уровне -- заголовок таблицы 
    \end{itemize}
\end{defin}

\begin{defin}{Атрибут}
    Атрибут (поле, столбец) -- характеристика объекта, принимающая значения определенного типа данных 

    \begin{itemize}
        \item Подмножество домена (атрибут $A_n$ определен на домене $D_n$, который содержит множество возможных значений атрибута)
        
        $A_1(D_1), A_2(D_2), \ldots A_n(D_n)$

        \item На бытовом уровне -- столбец таблицы 
        \item Имена атрибутов должны быть уникальны в пределах отношения 
    \end{itemize}
\end{defin}

\begin{defin}{Тип данных}
    Тип данных -- реляционная модель данных допускает использование только простых типов 

    \begin{itemize}
        \item Соответствует понятию типа данных в языках программирования 
        \item Реляционная модель данных допускает использование только простых типов (логические, символьные, числовые \dots), т.к. в реляционных операциях не должна учитываться внутренняя структура данных 
    \end{itemize}
\end{defin}

\begin{defin}{Домен}
    Домен -- произвольное логическое выражение (опционально), определяющее набор допустимых значений атрибута 

    \begin{itemize}
        \item Базовый тип данных + произвольное логическое выражение (опционально)
        \item Если вычисление заданного логического выражения для элемента данных заданного типа дает результат "истина"\ , то он является элементом домена
        \item Домены ограничивают сравнения: некорректно, с логической точки зрения, сравнивать значения из различных доменов, даже если они имеют одинаковый тип данных (например, возраст сотрудника и количество его детей)
    \end{itemize}
\end{defin}

\begin{defin}{Кортеж}
    Кортеж (запись, строка) -- набор связанных значений атрибутов, относящихся к одному объекту (сущности)

    \begin{itemize}
        \item Множества пар вида $\{$ Имя\_атрибута: Значение\_атрибута $\}$
        \item На бытовом уровне -- строка таблицы 
        \item Значение атрибута должно быть в пределах заданного домена
        \item Каждый кортеж отношения должен быть уникально идентифицирован
    \end{itemize}
\end{defin}

\begin{defin}{Схема БД}
    Схема БД (в структурном смысле) -- набор именованных схем отношений 
\end{defin}

\begin{defin}{Реляционная база данных}
    Реляционная база данных -- набор отношений, имена которых совпадают с именами схем отношений в схеме БД
\end{defin}

\begin{nota}{Свойства отношений}
    \begin{itemize}
        \item В отношении нет кортежей-дубликатов
        
        Т.к. отношение -- это множество кортежей, а каждое множество (в классической теории множеств) состоит из различных элементов 

        Во многих РСУБД может нарушаться для отношений, являющихся результатами запросов

        \item Кортежи не упорядочены
        
        Множество не упорядочено

        \item Атрибуты не упорядочены 
        
        Каждый атрибут имеет уникальное имя в пределах отношения, поэтому порядок атрибутов не имеет значения 

        \item Значение атрибута должно быть атомарным (неразделяемым на несколько значений)
        
        В современных РСУБД в ячейки таблиц можно поместить что угодно -- массивы, структуры и даже другие таблицы 

        \item Домены ограничивают сравнения
        
        Некорректно, с логической точки зрения, сравнивать значения из различных доменов, даже если они имеют одинаковый тип данных 
    \end{itemize}
\end{nota}

\newpage

\subsection{Аспект целостности реляционной модели}

\begin{defin}{Целостность базы данных}
    Целостность базы данных (database integrity) -- соответствие имеющейся в базе данных информации ее внутренней логике, структуре и всем явно заданным правилам 

    Каждое такое правило, налагающее ограничение на возможное состояние базы данных, называется ограничением целостности (integrity constraint)

    Задача аналитика и проектировщика БД -- возможно более полно выявить все имеющиеся ограничения целостности и задать их в базе данных 

    СУБД может (и должна) контролировать целостность БД
\end{defin}

\begin{nota}{Сущностная целостность}
    Каждый кортеж отношения должен быть уникально идентфиицирован по значениям его атрибутов

    Потенциальный ключ обладает следующими свойствами:

    \begin{itemize}
        \item Свойством уникальности -- в отношении не моежт быть двух различных кортежей с одинаковым значением потенциального ключа
        \item Свойством неизбыточности -- никакое подмножество в потенциальном ключе не обладает свойством уникальности, т.к. если из потенциального ключа убрать любой атрибут, он утратит свойство уникальности
    \end{itemize}

    Отношение может иметь несколько потенциальных ключей:

    \begin{itemize}
        \item Один из потенциальных ключей объявляется первичным -- Primary Key, а остальные -- альтернативными -- Alternate Key
        \item С точки зрения реляционной модели данных, нет оснований выделять таким образом один из потенциальных ключей 
    \end{itemize}
\end{nota}

\begin{nota}{Правила для поддержки сущностной целостности}
    Потенциальный ключ может быть:

    \begin{itemize}
        \item Простым -- состоит из одного атрибута 
        \item Составным -- состоит из нескольких атрибутов 
    \end{itemize}

    Потенциальные ключи фактически являются идентификаторами. Если бы идентификаторы могли содержать NULL значения, невозможно было бы дать ответ "да"\ или "нет"\ на вопрос, совпдаают ли два идентификатора 

    Это определяет следующее правило: значения атрибутов, входящих в состав некоторого потенциального ключа не могут быть NULL (во многих СУБД выполняется только для первичного ключа)
\end{nota}

\begin{defin}{NULL}
    Для того чтобы обойти проблему неполных или неизвестных данных, каждый тип данных в БД может быть дополнен NULL

    NULL -- это не значение, а некий маркер, показывающий, что значение неизвестно 

    В ситуации, когда возможно появление неизвестных или неполных данных, разработчик имеет на выбор два варианта: 

    \begin{itemize}
        \item Ограничиться использованием обычных типов данных и не использовать NULL, а вместо неизвестных данных вводить либо нулевые значения, либо значения специального вида 
        \item Использовать NULL вместо неизвестных данных 
    \end{itemize}

    Наличие NULL приводит к использованию трехзначной логики:

    \begin{itemize}
        \item Три возможных значений выражений: TRUE (T), FALSE (F), UNKNOWN (U)
        \item NULL = NULL $\to$ U (NOT NULL = NULL $\to$ U)
        \item NULL !+ NULL $\to$ U (NOT NULL != NULL $\to$ U)
        \item F OR NULL $\to$ U (T OR NULL $\to$ T)
        \item T AND NULL $\to$ U (F AND NULL $\to$ F)
    \end{itemize}
\end{defin}

\begin{defin}{Внешние ключи}
    Различные объекты предметной области, информация о которых хранится в базе данных, взаимосвязаны друг с другом 

    Для реализации взаимосвязи между родительским и дочерним отношениями в реляционных БД используются внешние ключи -- foreign key (FK)
\end{defin}

\begin{nota}{Требования к FK}
    Подмножество атрибутов FK отношения R будем называть внешним ключом, если 

    \begin{itemize}
        \item Существует отношения S (R и S не обязательно различны) с потенциальным ключом K
        \item Каждое значение FK в отношении R всегда совпадает со значением K для некоторого кортежа из S, либо является NULL
    \end{itemize}
\end{nota}

\begin{Remark}{Замечания относительно FK}
    \begin{itemize}
        \item Отноешние S называется родиетльским отношением, отношение R называется дочерним отношением
        \item FK, также как и потенциальный, может быть простым и Составным
        \item FK должен быть определен на тех же доменах, что и соответствующих потенциальный ключ родительского отношения
        \item FK, как правило, не обладает свойством уникальности (тип связи -- один ко многим)
        \item Для FK не требуется, чтобы он был компонентом некоторого потенциального ключа
        \item NULL для значений атрибутов FK допустимы только в том случае, когда атрибуты FK не входят в состав никакого потенциального ключа 
    \end{itemize}
\end{Remark}

\begin{defin}{Связь}
    Связь -- ассоциирование двух или более сущностей (или копий одной и той же сущности)

    Одно из основным требований к организации БД -- это обеспечение возможности поиска одних сущностей по значениям других, для чего необходимо установить между ними определенные связи 

    Типы связей:

    \begin{itemize}
        \item Связь 1:1. Один экземпляр сущности одного класса связан с одним экземпляром сущности другого класса
        \item Связь 1:M. Один экземпляр сущности одного класса связан со многими экземплярами сущности другого класса 
        \item Связь M:N. Несколько экземпляров сущности одного класса связаны с несколькими экземплярами сущности другого класса
    \end{itemize}
\end{defin}

\begin{nota}{Допустимая кратность связей}
    В реляционных БД допустимыми являются связи типа 1:M и 1:1 (значения внешнего ключа -- уникальны)

    Механизм реализации допустимых взаимосвязей состоит в том, что на дочернее отношение добавляются атрибуты, являющиеся ссылками на ключевые атрибуты родительского отношения 

    Невозможно ссылаться на несуществующие объекты $\to$ значения атрибута внешнего ключа дочернего отношения должны иметь соответствие среди значений атрибутов отношения потенциального ключа родительского

    Взаимосвязи типа M:N реализуются использованием нескольких взаимосвязей типа 1:M
\end{nota}

\newpage

\subsection{Знакомство с PostgreSQL (реклама)}

\begin{defin}{PostgreSQL}
    PostgreSQL -- это открытая, BSD-лицензированная система управления объектно-ориентированными реляционными базами данных 
\end{defin}

\begin{nota}{История PostgreSQL}
    \begin{itemize}
        \item 1986 -- старт проекта PostgreSQL на факультете компьютерных наук Калифорнийсокго университета в Беркли
        
        Первоначальное название проекта -- POSTGRES (развитие старой БД Ingres)

        \item 1996 -- проект POSTGRES переименован в PostgreSQL, для отражения поддержки SQL
        
        Global Development Group PostgreSQL, специализированное сообщество участников, продолжает выпускать релизы проекта с открытым исходным кодом 

        \item Первоначально PostgreSQL был разарботан для работы на UNIX-подобных платформах
        
        Сейчас PostgreSQL поддерживает различны платформы, такие как Windows, macOS и Solaris
    \end{itemize}
\end{nota}

\begin{nota}{Преимущества и особенности СУБД PostgreSQL}
    \begin{itemize}
        \item Надежность
        \item Производительность
        \item Расширяемость
        \item Поддержка SQL
        \item Поддержка многочисленных типов данных
    \end{itemize}
\end{nota}

\begin{nota}{Расширяемость}
    PostgreSQL спроектирован с рассчетом на расширяемость 

    Прикладные программисты могут:

    \begin{itemize}
        \item Создавать собственные типы данных на основе уже имеющихся (составные типы, диапазоны, масисвы, перечисления)
        \item Писать хранимые процедуры и функции для обработки данных в БД (в том числе триггеры)
        \item Писать расширения (языке программирования Си), которые добавляют необходимый функционал и, обычно, могут подключаться даже к работающему серверу
    \end{itemize}

    Если вам не нравится какая-либо часть системы, вы всегда можете разработать собственный плагин
\end{nota}

\begin{Remark}{Важный факт}
    Подавляющее большинство СУБД:

    \begin{itemize}
        \item Представляет собой сервис (демон в $^*$nix-системах), который взаимодействует с внешним миром по специальным протоколам (чаще всего, построенным поверх TCP/IP)
        \item Не имеет никакого человеческого интерфейса
        \item Общение осуществляется на специализированном языке через специальные библиотеки
    \end{itemize}

    MySQL Workbench, Microsoft SQL Serber Management Studio, Oracle SQL Developer и им подобные -- это не СУБД, это лишь клиентское программное обеспечение, позволяющее нам взаимодействовать с СУБД
\end{Remark}

\begin{nota}{Упрощенная архитектура PostgreSQL}
    PostgreSQL -- это СУБД клиент-серверного типа с многопроцессной архитектурой, работающая на одном хосте 

    Сбой в одном из процессов не повлияет на остальные и система продолжит функционировать 

    Набор нескольких процессов, совместно управляющих одним кластером БД, называется "сервером PostgreSQL"\

    Один сервер PostgreSQL может управлять несколькими конкурентными клиенсткими подключениями 
\end{nota}

\begin{nota}{Основные процессы}
    \begin{itemize}
        \item FrontEnd процессы -- клиентские приложения:
        
        \begin{itemize}
            \item Используют PostgreSQL в качестве менеджера баз данных
            \item Соединение может происходить через TCP/IP или локальные сокеты 
        \end{itemize}

        \item Демон postres (postmaster) -- это основной процесс PostgreSQL:
        
        \begin{itemize}
            \item Прослушивание через порт/сокет входящих клиенстких подключений
            \item Создание BackEnd процессов и выделение им ресурсов
        \end{itemize}

        \item BackEnd процессы:
        
        \begin{itemize}
            \item Аутентификация клиенстких подключений 
            \item Управление запросами и отправка результатов клиенстким приложениям 
            \item Выполнение внутренних задач (служебные процессы)
        \end{itemize}
    \end{itemize}
\end{nota}

\begin{nota}{Процесс взаимодействия с БД}
    \begin{enumerate}
        \item Клиент (FrontEnd)
        
        \begin{enumerate}
            \item Используя язык БД формулирует требования к результату
            \item Опирается на знание логической структуры БД
        \end{enumerate}

        \item СУБД (postmaster и BackEnd)
        
        \begin{enumerate}
            \item Получает запрос от клиента 
            \item Анализирует разрешения
            \item Анализирует и оптимизирует запрос 
            \item Создает план выполнения запроса, опираясь на знание физической структуры данных
            \item Выполняет запрос 
        \end{enumerate}
    \end{enumerate}
\end{nota}

\begin{nota}{Взаимодействие с БД}
    Для работы с реляционной СУБД существует два основных подхода:

    \begin{itemize}
        \item Работа с библиотекой, которая соответствует конкретной СУБД и позволяет использовать для работы с БД язык БД 
        \item Работа с ORM, которая использует объектно-ориентированный подход для работы с БД и автоматически генерирует код на языке БД 
    \end{itemize}
\end{nota}

\begin{nota}{Подключение к СУБД с использованием клиентской библиотеки}
    Строка подключения вклюает:

    \begin{itemize}
        \item Имя сервера БД (или IP адрес и порт)
        \item Имя базы данных
        \item Учетную запись пользователям
        \item И другие параметры, необходимые для установки исходного подключения 
    \end{itemize}
\end{nota}

\newpage

\subsection{SQL и NoSQL}

\begin{nota}{Модели данных}
    \begin{itemize}
        \item Иерархическая (файловая система)
        \item Сетевая (социальные сети)
        \item Документ-ориентированная (системах управления содержимым)
        \item Реляционная (банковские системы)
        \item Объектно-ориентированная (естественное отображение ООП кода на БД, уменьшающее impedance mismatch)
        \item Многомерная (аналитические системы)
    \end{itemize}
\end{nota}

\begin{nota}{Преимущества РБД}
    \begin{itemize}
        \item Совместное использование данных
        
        \begin{itemize}
            \item Улучшенное управление паралелльной работой
            \item Повышенная безопасность 
            \item Контроль доступа к данным 
        \end{itemize}

        \item Поддержка целостности данных 
        
        \begin{itemize}
            \item Контроль за избыточностью данных и их непротиворечивостью
            \item Обеспечение поддержки бизнес-правил 
        \end{itemize}

        \item Эффективное управление 
        
        \begin{itemize}
            \item Упрощение сопровождения системы за счет неазависимости от данных 
            \item Эффективное резервное копирование и восстановление данных
        \end{itemize}

        \item Применение стандартов 
    \end{itemize}
\end{nota}

\begin{nota}{Недостатки РБД}
    \begin{itemize}
        \item Сложность
        
        Затраты на преобразование данных на входе и выходе

        \item Уязвимость
        
        Централизация ресурсов повышает уязвимость системы 

        \item Высокие финансовые затраты 
        
        \begin{itemize}
            \item Стоимость СУБД 
            \item Стоимость сопровождения 
            \item Дополнительные затраты на аппаратное обеспечение 
        \end{itemize}
    \end{itemize}
\end{nota}

\begin{defin}{Базы данных NoSQL}
    Базы данных NoSQL хорошо подходят для приложений, которые должны быстро, с низкой временной задержкой (low latency) обрабатывать большой объем данных с разной структурой 

    \begin{itemize}
        \item Гибкость. Благодаря использованию гибких моделей данных БД NoSQL хорошо подходят для частично структурированных и неструктурированных данных. Эффективность работы с разреженными данными 
        \item Масштабируемость. БД NoSQL рассчитаны на масштабирование с использованием распределенных кластеров аппаратного обеспечения. Широко используются в облачных решениях в качестве полностью управляемых сервисов
        \item Высокая производительность. БД NoSQL оптмизированы для конкретных моделей данных и шаблонов доступа, что позволяет достичь более высокой производительности по сравнению с реляционными базами данных 
        \item Широкие функциональные возможности. БД NoSQL предоставляют API и типы данных с широкой функциональностью, которые специально разработаны для соответствующих моделей данных 
    \end{itemize}
\end{defin}

\begin{defin}{Нереляционные БД}
    \begin{itemize}
        \item Хранилища ключей и значений 
        
        \begin{itemize}
            \item Поддерживают высокую разделяемость и обеспечивают беспрецендентное горизонтальное масштабирование 
            \item Игровые, рекламные прилоежния и приложения IoT (Amazon DynamoDB, Redis, Riak)
        \end{itemize}
        
        \item Колоночные
        
        \begin{itemize}
            \item Данные хранятся не по строкам, а по столбцам 
            \item Хорошо подходят для BigData (Hbase, Clickhouse, Vertica)
        \end{itemize}

        \item Документоориентированные 
        
        \begin{itemize}
            \item Хранение коллекций документов с произвольным набором атрибутов (полей)
            \item Каталоги, пользовательские профили и системы управления контентом, где каждый документ уникален и изменяется со временем (CouchDB, Couchbase, MongoDB)
        \end{itemize}

        \item Графовые
        
        \begin{itemize}
            \item Упор на установление произвольных связей между данными 
            \item Социальные сети, сервисы рекомендаций, системы выявления мошенничества и графы знаний (OrientDB, Neo4j)
        \end{itemize}
    \end{itemize}
\end{defin}

\begin{center}
    \begin{tabular}{|m{7.5em}|m{16em}|m{16em}|}
        \hline
        Параметр & Реляционные (SQL) & NoSQL \\
        \hline
        Подходящие рабочие нагрузки & OLTP и OLAP & Приложения с низкой задержкой доступа к данным \\
        \hline
        Модель данных & Нормализованная реляционная модель обеспечивает целостность ссылочных данных в отношениях между таблицами & Предоставляют разнообразные модели данных, оптимизированные для высокой производительности и масштабируемости \\ 
        \hline
        Струткура & Жесткая схема: таблицы (строки, столбцы) & Гибкие модели: документы, ключ-значение, графы, колоночные \\
        \hline
        Изменение схемы & Требует ALTER TABLE, миграции & Гибкость (документы без фиксированной схемы) \\
        \hline
        Типы данных & Строгая типизация & Диинамические (JSON, BLOB и другие) \\
        \hline
        Связи & JOIN, внешние ключи, ACID-транзакции & Часто денормализация, ссылки или вложенные данные \\
        \hline
        Производительность & Зависит от дисковой подсистемы. Требуется оптимизация запросов, индексов и струткур таблицы & Зависит от размера кластера базового аппаратного обеспечения, задержки сети и вызывающего приложения \\ 
        \hline
        Чтение/запись & Быстрые сложные запросы (OLTP), но JOIN могут замедлять & Высокая скорость для простых операция (ключ-значение) \\
        \hline
        Оптимизация & Индексы, нормализация & Денормализация, распределенные вычисления \\
        \hline
        Масштабирование & Масштабируются путем увеличения вычислительных возможностей аппаратного обеспечения или добавления отдельных копий для рабочих нагрузок чтения & Поддерживают высокую разделяемость благодаря шаблонам доступа с возможностью масштабирования на основе распределенной архитектуры \\
        \hline
        Горизонтальное & Сложно (шардинг требует усилий) & Оптмиизировано (например, Cassandra, DynamoDB) \\
        \hline
        Вертикальное & Стандартный подход (увеличение сервера) & Возможно, но реже используется \\
        \hline
    \end{tabular}
\end{center}

\newpage

\subsection{Классификация баз данных}

\begin{nota}{Классификация БД}
    \begin{itemize}
        \item Классификация БД по характеру организации данных 
        
        \begin{itemize}
            \item Неструктурированные 
            
            БД, хранят данные в виде обычного текста или гипертекстовой разметки 

            \begin{itemize}
                \item рпоще зафиксировать (как есть)
                \item Очень трудно искать конкретные данные, поскольку они не структурированы 
                \item Очень трудно анализировать, поскольку данных как правило качественные (семантические)
            \end{itemize}

            \item Структурированные 
            
            БД, хранящие данные в организованном виде в отформатированном хранилище

            \begin{itemize}
                \item Требуют предварительного проектирования и описания структуры БД
                \item Только после этого БД такого типа могут быть заполнены данными 
                \item Очень простой поиск и нахождение данных в базе данных или наборе данных 
                \item Очень легко анализировать данные, поскольку они как правило количественные
            \end{itemize}
        \end{itemize}

        \item Классификация БД по характеру хранимой информации 
        
        \begin{itemize}
            \item Документальные
            
            \begin{itemize}
                \item Предназначены для хранения слабо структурированных данных. Единицей хранения является документ, заданный конечным (но не фиксированным) набором полей в общем случае произвольной длины. Значение поля может иметь сложную структуру и зависеть от контекста использования 
                \item Пользователю в ответ на его запрос выдается либо ссылка на документ, либо сам документ, в котором он может найти интересующую информацию
                \item Использование: гипертекстовые документы в сети Интернет
                \item Информационно-справочные или информационно-поисковые системы 
            \end{itemize}
            \item Фактографические
            
            \begin{itemize}
                \item Ориентированы на хранение хорошо структурированных данных. Единицей информации служит описание факта конечным, четко определенным множеством свойств. Каждое свойство факта (объекта) имеет атомарное значение, которое не зависит от контекста использования
                \item Использование: БД оперативной обработки транзакций (OLTP) -- операционные БД, БД оперативной аналитической обработки (OLAP) -- хранилища данных (Data Warehouse)
            \end{itemize}
        \end{itemize}

        \item Классификация БД и СУБД по структуре организации данных 
        
        Структурированные БД различаются по типу используемой модели представления данных 

        \begin{itemize}
            \item Сетевые
            \item Иерархические
            \item Реляционные
            \item Многомерные 
            \item Объектно-ориентированные 
        \end{itemize}
    \end{itemize}
\end{nota}

\begin{defin}{Модель представления данных}
    Модель данных -- интегрированный набор понятий для описания и обработки данных, связей между ними и ограничений, накладываемых на данные в рамках предметной области 

    Модель данных можно рассматривать как сочетание трех компонентов:

    \begin{itemize}
        \item Структурная часть -- набор правил, по которым может быть построена БД 
        \item Управляющая часть -- определяет типы допустимых операций с данными: для обновления и извллечения данных, для изменения структуры данных 
        \item Набор ограничений (необязательный) для поддержки целостности данных, гарантирующих корректность используемых данных (полноту, непротиворечивость и адекватное отражение предметной области)
    \end{itemize}
\end{defin}

\begin{defin}{Иерархическая модель данных}
    Иерархическая модель данных -- это модель данных, где используется представление БД в виде древовидной (иерархической) структуры, состоящей из объектов (данных) различных уровней -- родителей-потомков 

    В иерархической модели узел может иметь только одного родителя

    \begin{itemize}
        \item Самый верхний узел называется корневым узлом 
        \item Все узлы дерева, за исключением корневого, должны иметь родительский узел 
        \item Связи между отдельными узлами дерева отражаются с помощью направленных ребер графа -- от родителя к ребенку
    \end{itemize}
\end{defin}

\begin{defin}{Сетевая модель данных}
    Для описания сетевой модели данных используют понятия "запись"\ и "связь"\ 

    Связь определяется для двух записей: предка и потомка 

    В сетевой модели данных запись-потомок может иметь произвольное число записей-предков 

    В сетевой структуре каждый элемент может быть связан с любым другим элементом 

    Сетевые базы данных подобны иерархическим, за исключением того, что в них имеются указатели в обоих направлениях, которые соединяют родственную информацию 

    Несмотря на то, что эта модель решает некоторые проблемы, связанные с иерархической моделью, выполнение простых запросов остается достаточно сложным процессом 

    Также, поскольку логика процедуры выборки данных зависит от физической организации этих данных, то эта модель не является полностью независимой от приложения. Другими словаи, если необходимо изменить структуру данных, то нужно изменить и приложение 
\end{defin}

\begin{defin}{Реляционная модель данных}
    Эта модель данных основана на понятии математических отошений (relation)

    В реляционной модели данные представлены в виде плоских таблиц, связанных между собой. Необходимо помнить, что таблица есть понятие нестрогое и часто означает не отношение как абстрактное понятие, а визуальное представление отношения на бумаге или экране. В частности -- таблицы обычно предполагают упорядоченное хранение данных, в то время как отношения -- не обладают этой характеристикой 

    Между отношениями поддерживаются связи один-к-одному или один-ко-многим 
\end{defin}

\begin{defin}{Многомерная модель данных}
    Данные представлены в виде многомерного куба (массива). Измерение (атрибут в реляционной модели) -- размерность куба. Факт (агрегированная числовая характеристика) -- содержимое ячейки 

    Агрегаты по всем срезам куба высчитываются один раз и хранятся в базе 
\end{defin}

\begin{defin}{Объектно-ориентированная модель данных}
    Данные представлены в виде классов и относящихся к ним объектов 

    \begin{itemize}
        \item Класс -- тип объекта 
        \item Атрибут -- свойство объекта 
        \item Метод -- операция над объектом 
    \end{itemize}

    Инкапсуляция структурного и функционального описания объектов 

    Наследуемость внешних свойств объектов на основе соотношения "класс-подкласс"\
\end{defin}

\newpage 

\subsection{Классификация СУБД}

\begin{defin}{Словарь данных}
    Словарь данных -- набор доступных для выборки всем пользователям базы данных системных таблиц, в которых хранятся метаданные (данные о данных)
\end{defin}

\begin{nota}{Классификация СУБД}
    \begin{itemize}
        \item Классификация по количеству пользователей 
        
        \begin{itemize}
            \item Однопользовательские 
            
            \begin{itemize}
                \item Реализуются на автономном ПК без использования сетей связи 
                \item Рассчитаны на работу одного пользователя или группы пользователей, разделяющих по времени одно рабочее место 
                \item Настольные или локальные СУБД 
            \end{itemize}

            \item Многопользовательские 
            
            \begin{itemize}
                \item Ориентированы на коллективное использование информации 
                \item Строятся на базе локальной вычислительной сети 
                \item Могут быть распределены по нескольким узлам (хостам)
            \end{itemize}
        \end{itemize}

        \item Классификация по степени распределенности
        
        \begin{itemize}
            \item Локальные СУБД -- все части размещаются на одном компьютере 
            \item Распределенные СУБД -- части СУБД могут размещаться не только на одном, но на двух и более компьютерах 
            
            \begin{itemize}
                \item Файл-серверные
                \item Клиент-серверные 
                
                \begin{itemize}
                    \item Двухзвенные (СУБД и БД, клиентские приложения)
                    \item Многозвенные (СУБД и БД, сервер приложений, клиентские приложения)
                \end{itemize}
            \end{itemize}
        \end{itemize}
        \item Классификация по способу доступа к БД 
    \end{itemize}
\end{nota}

\begin{nota}{Недостатки файл-серверной архитектуры}
    СУБД не располагает информацией о том, что происходит на компьютере где хранятся данные:

    \begin{itemize}
        \item Невозможно считать из БД только ту часть данных, которые запрашивает пользователь -- считывается файл целиком (блокировка файла) 
        \item Большой объем сетевого трафика (передача по сети множества блоков и файлов, необходимых приложению)
        \item Узкий спект операций манипулирования с данными, определяемый только файловыми командами 
        \item Отсутствие адекватных средств безопасности доступа к данным (защита только на уровне файловой системы)
        \item Недостаточно развитый аппарат транзакций служит потенциальным источником ошибок в плане нарушения смысловой и ссылочной целостности информации при одновременном внесении изменений в одну и ту же запись 
    \end{itemize}
\end{nota}

\begin{defin}{Архитектура клиент-сервер (двухзвенная)}
    На сервере: база данных, серверная часть СУБД -- взаимодействует с БД, обеспечивая выполнение запросов клиентской части 

    На клиенте: прикладные программы, клиентская часть СУБД -- обеспечивает взаимодействие с пользователем и формирование запросов к БД и передача их на сервер

    Преимущества:

    \begin{itemize}
        \item СУБД располагает информацией о наборе файлов БД
        \item Обеспечение разграничения доступа к данным нескольких пользователей 
        \item Считывание только необходимой пользователю информации из файла (блокировка блока данных)
        \item Обеспечивает корректную параллельную раоту всех пользователей с единой БД 
    \end{itemize}

    Недостатки: 

    \begin{itemize}
        \item Очень большая загрузка на сервер, так как он обслуживает множество клиентов и выполняет всю основную обработку данных 
        \item Нагрузка с обработкой полученных данных дублируется на клиентские хосты 
    \end{itemize}
\end{defin}

\begin{defin}{Архитектура клиент-сервер (трехзвенная)}
    Схема: тонкий клиент $\to$ сервер приложений $\to$ сервер базы данных 

    В функции клиентской части (тонкий клиент) входи только интерактивное взаимодействие с пользователем 

    Вся логика обработки данных (прикладные программы) вынесена на сервер приложений, который и обеспечивает формирование запросов к БД, передаваемых на выполнение серверу БД 

    Сервер приложений может являться специализированной программой или обычным web-сервером 

    Преимущества: 

    \begin{itemize}
        \item Снижается нагрузка на сервер БД -- он занимается исключительно функциями СУБД 
        \item При изменении бизнес-логики нет необходимости изменять клиенсткие приложения 
        \item Максимально снижаются требования к аппаратуре пользователей 
        \item Данная модель обладает большей гибкостью, чем двухуровневые модели 
    \end{itemize}

    Недостатки:

    \begin{itemize}
        \item Более высокие затраты ресурсов компьютеров на обмен информацией между компонентами приложений по сравнению с двухуровневыми моделями 
    \end{itemize}
\end{defin}

\begin{defin}{Встраиваемые СУБД}
    Встаиваемая СУБД -- поставляется как составная часть некоторого программного продукта, не требующая процедуры самостоятельной установки

    Предназначена для локального хранения данных своего приложения и не рассчитана на коллективное использование в сети 

    Физически чаще всего реализуется в виде подключаемой библиотеки 

    Доступ к данным со стороны приложения может происходить через язык запросов либо через специальные программные интерфейсы 
\end{defin}

\newpage

\subsection{Аспект обработки реляционной модели}

\begin{nota}{Математические аппараты для манипулирования данными}
    Виды:

    \begin{itemize}
        \item Реляционная алгебра -- основана на теории множеств. Описывает порядок выполнения операций, позволяющих из исходных выражений получить результат 
        \item Реляционное исчисление -- основано на логике предикатор первого порядка. Описывает результат в терминах исходных отношений 
    \end{itemize}

    Свойство замкнутости операций на множестве отношений. Выражения реляционной алгебры и формулы реляционного исчисления определяются над отношениями реляционных БД и результатом вычисления также являются отношения 

    В современных РСУБД не используется в чистом виде ни реляционная алгебра, ни реляционное исчисление. Фактическим стандартом доступа к реляционным данным стал язык SQL (Structured Query Language), который представляет собой смесь операторов реляционной алгебры и выражений реляционного исчисления, использующий синтакси, близкий к фразам английского языка и расширенный лополнительными отсутствующими в упомянутых аппаратах
\end{nota}

\begin{defin}{Реляционная алгебра (РА)}
    Реляционная алгебра -- это формальный язык операций над отношениями (таблицами), включающий SQL -- декларативный язык запросов, который включает не только операции РА, но и дополнительные конструкции (агрегацию, рекурсию, модификацию данных и др.)

    Вывод: классическая реляционная алгебра и базовый SQL (без агрегации, рекурсии, оконных функци итд) эквивалентны по выразительной силе в рамках запросов к базе данных. Однако SQL строго мощнее, если учитывать все его возможности (например, рекурсивные запросы, агрегацию, модификацию данных)

    Операции реляционной алгебры:

    \begin{itemize}
        \item Теоретико-множественные
        
        \begin{itemize}
            \item Объединение отношений 
            \item Пересечение отношений
            \item Вычитание отношений 
            \item Декартово произведение отношений 
        \end{itemize}

        \item Специальный 
        
        \begin{itemize}
            \item Выборка (ограничение) отношений 
            \item Проекция отношения
            \item Соединение отношений 
            \item Деление отношения 
        \end{itemize}

        \item Дополнительные 
        
        \begin{itemize}
            \item Присваивание (сохранение результатов вычисления)
            \item Переименование атрибутов отношения 
        \end{itemize}
    \end{itemize}
\end{defin}

\begin{nota}{Совместимость по типу}
    Некоторые реляционные операции требуют, чтобы отношения были совместимы по типу 

    Отношения являются совместимыми по типу, если их схемы идентичны 

    Отношения имеют одно и то же множество имен атрибутов, т.е. для любого атрибута в одном отношении найдется атрибут с таким же именем в другом отношении 

    Атрибуты с одинаковыми именами определены на одних и тех же доменах 

    Степени схем отношений (количество атрибутов) совпадают 
\end{nota}

\begin{defin}{Объединение отношений}
    Объединением двух совместимых по типу отношений $A$ и $B$ называется отношение $S$ с той же схемой, что и у отношений $A$ и $B$, и состоящее из кортежей, принадлежащих или $A$, или $B$, или обоим отношениями

    Синтаксис: A UNION B или A $\cup$ B

    \begin{Remark}{}
        Объединение, как и любое отношение, не может содержать одинаковых кортежей 

        Если некоторый кортеж входит и в отношение A, и в отношение B, то в объединение он входит один раз
    \end{Remark}
\end{defin}

\begin{defin}{Вычитание отношений}
    Вычитанием двух совместимых по типу отношений A и B называется отношение S с той же схемой, что и у отношений A и B, и состоящее из кортежей, принадлежащих отношению A и не принадлежащих отношению B 

    Синтаксис: A EXCEPT B или A $\setminus$ B
\end{defin}

\begin{defin}{Пересечение отношений}
    Пересечением двух совместимых по типу отношений A и B называется отношение S с той же схемой, что и у отношений A и B, и состоящее из кортежей, принадлежащих одновременно обоим отношениям 

    Синтаксис: A INTERSECT B или A $\cap$ B 

    \begin{Remark}{}
        Пересечение может быть выражено через операцию вычитания: $A \cap B = A \setminus (A \setminus B)$
    \end{Remark}
\end{defin}

\begin{defin}{Декартово произведение отношений}
    Декартовым произведением двух отношений $A = (A_1, A_2, \ldots A_n)$ и $B = (B_1, B_2 \ldots B_m)$ называется отношение S, со схемой, состоящей из атрибутов отношений $A$ и $B$: $(A_1, A_2 \ldots A_n, B_1, B_2 \ldots B_m)$ и являющееся результатом конкатенации (сцепления) каждого кортежа из отношения $A$ с каждый кортежем из отношения $B$. В результате получаем набор кортежей $(a_1, a_2 \ldots a_n, b_1, b_2 \ldots b_m)$, таких, что $(a_1 \ldots a_n) \in A$, а $(b_1 \ldots b_m) \in B$

    Синтаксис: A CROSS JOIN B или $A * B$

    \begin{Remark}{}
        Мощность произведения равен произведению мощностей отношений A и B 

        Если в отношениях A и B имеются атрибуты с одинаковыми наименованиями, то перед выполнением операции декартового произвдеения такие атрибуты необходимо переименовать 
    \end{Remark}
\end{defin}

\begin{defin}{Выборка (ограничение) отношений}
    Выборкой (ограничением) называется подмножество кортежей отношения R, удовлетворяющих определенному условию (предикату)

    Результат выборки -- горизонтальный срез отношения по некоторому условию

    Предикат -- логическое выражение, в которое могут входить атрибуты отношения R и/или скалярные выражения 

    Синтаксис: R WHERE или $\sigma$ R
\end{defin}

\begin{defin}{Проекция отношения}
    Проекцией называется вертикальное подмножество кортежей отношения R, создаваемое посредством извлечения значений указанных атрибутов $A_1 \ldots A_n$ отношения 

    Результат проекции -- вертикальный срез отношения, в котором удалены все возникшие при этом дубликаты кортежей 

    Синтаксис: $R[A_1 \ldots A_n]$ или $\prod_{A_1 \ldots A_n} R$
\end{defin}

\begin{defin}{Соединение отношений}
    $\theta$-соединение (тэта-соединение) -- определяет отношение S, которое содержит кортежи из декартового произведения отношений A и B, удовлетворяющих предикату $\theta$

    Синтаксис: (A JOIN B) ON $\theta$

    \begin{Remark}{Частные случаи}
        \begin{itemize}
            \item Экви-соединение -- предикат содержит только оператор равенства 
            \item Естественное соединение -- эквисоединение отношений A и B, выполненное по всем общим атрибутам, из результатов которого исключается по одному экземпляру каждого общего атрибута 
            \item Левое внешнее соединение -- соединение, при котором кортежи отношения A, не имеющие совпадающих значений в общих атрибутах отношения B, также включаются в общее отношение 
        \end{itemize}
    \end{Remark}
\end{defin}

\begin{defin}{Деление}
    Пусть даны отношения $A(X_1 \ldots X_n, Y_1 \ldots Y_p)$ и $B(Y_1 \ldots Y_p)$, причем атрибуты $(Y_1 \ldots Y_p)$ -- общие для двух отношений 

    Результатом деления отношения A на B является отношение со схемой $S(X_1 \ldots X_n)$, содержащее множество кортежей $(x_1 \ldots x_n)$, таких, что для всех кортежей $(y_1 \ldots y_p) \in B$ в отношении A найдется кортеж $(x_1 \ldots x_n, y_1 \ldots y_p)$

    Отношение A выступает в роли делимого, отношение B выступает в роли делителя 

    Все атрибуты отношения B должны входить в состав схемы отношения A 

    Синтаксис: A DIVIDE BY B или A $\div$ B

    \begin{Remark}{}
        Деление может быть выражено через операции декартова произведения и вычитания 

        Типичные запросы, реализуемые с помощью операции деления, обычно в своей формулировке имеют слово все 
    \end{Remark}
\end{defin}

\begin{Example}{}
    \begin{enumerate}
        \item Получить имена поставщиков, поставляющих деталь номер 2:
        
        ((DP JOIN P) WHERE DNUM=2)[PNAME]

        \item Получить имена поставщиков, поставляющих по крайней мере одну гайку 
        
        (((D JOIN DP) JOIN P) WHERE DNAME=Гайка)[PNAME]
        (((D WHERE DNAME=Гайка) JOIN DP) JOIN P)[PNAME]

        \item Получить имена поставщиков, поставляющих все детали 
        
        ((DP[PNUM,DNUM] DIVIDE BY D[DNUM]) JOIN P)[PNAME]
    \end{enumerate}
\end{Example}

\newpage

\subsection{Типы данных}

\begin{defin}{PostgreSQL и типы данных}
    SQL -- язык со строгой типизацией. Каждый элемент данных имеет некоторый тип, определяющий его поведение и допустимое использование 

    PostgreSQL наделен расширяемой системой типов, более универсальной и гибкой по сранвению с другими реализациями SQL 
\end{defin}

\begin{nota}{Типы данных}
    \begin{itemize}
        \item Символьные 
        \item Числовые 
        \item Дата и время 
        \item Логические 
        \item Двоичные 
        \item Специальные 
    \end{itemize}
\end{nota}

\begin{defin}{Символьные данные}
    varchar(n), char(n), text 

    Константные зачения. Последовательность символов, заключенная в апострофы. Две строковые константы, разделенные пробельными символами и минимум одним переводом строки, объединяются в одну 

    \begin{itemize}
        \item Константы со спецпоследовательностями в стиле С 
        
        Начинаются с буквы Е (заглавной или строчной)

        \item Строковые константы со спецпоследовательностями Unicode 
        
        Позволяют включать в строки символы Unicode по их кодам 

        Начинается с U\& (строчная или заглавная U и амперсанд)

        Символы Unicode можно записывать двумя способами:

        \begin{itemize}
            \item $\backslash$ и код символа из четырех шестнадцатеричных цифр 
            \item $\backslash+$ и код символа из шести шестнадцатеричных цифр
        \end{itemize}

        \item Строковые константы, заключенные в доллары 
        
        Используются для работы со строками, содержащими много апострофов или обратных косых черт. Позволяют избежать необходимости зеркалирования служебных символов. Делают строки более читабельными. Обрамляются \$[тэг]\$
    \end{itemize}
\end{defin}

\begin{defin}{Точные числовые данные}
    Целочисленные типы -- smallint (int2), integer (int4), bigint (int8)

    Числа фиксированной точности -- numeric (precision, scale) и decimal (precision, scale)
\end{defin}

\begin{defin}{Числовые данные с плавающей точкой}
    real, double precision и float(p)

    Поддерживают специальные значения Infinity, -Infinity и NaN

    Если точность вводимого числа выше допустимой -- будет выполняться округление значения. При вводе слишком большого или очень маленького значения будет генерироваться ошибка 

    Внимание: сравнение двух чисел с плавающей точкой на предмет равенства их значений может привести к неожиданным результатам 
\end{defin}

\begin{defin}{опследовательные типы}
    serial (int4), bigserial (int8) и msallserial (int2)

    Реализованы как удобная замена целой группы SQL-команд: создание объекта SEQUENCE -- генератор уникальных целых чисел, генерация и получение значений последовательности 

    Часто используются в качестве значений суррогатного первичного ключа (Primary Key)

    Нет неоюходимости указывать явное значение для вставки в поле РК 
\end{defin}

\begin{nota}{Функции для работы с последовательностями}
    \begin{center}
        \begin{tabular}{|m{7em}|m{4em}|m{25em}|}
            \hline
            Функция & Тип результата & Описание \\ 
            \hline
            currval('name') & bigint & Возвращает последнее сгенерированное значение указанной последовательности (которое было возвращено при последнем вызове функции nextval) \\
            \hline
            lastval() & bigint & Возвращает последнее сгенерированное значение любой последовательности (которое было возвращено при последнем вызове функции nextval) \\
            \hline 
            nextval('name') & bigint & Генерит и возвращает новое значение последовательности \\ 
            \hline
            setval('name', bigint) & bigint & Устанавливает текущее значение последовательности \\
            \hline
            setval('name', bigint, boolean) & bigint & Устанавливает текущее значение последовательности и флаг is-called, указывающий на то, что это значение уже использовалось \\
            \hline
        \end{tabular}
    \end{center}
\end{nota}

\begin{defin}{Дата и время}
    date, time и time with time zone (timetz)

    Даты обрабатываются в соответствии с григорианским календарем

    time хранит время внутри суток. time with time zone хранит время с учетом смещения, соответствующего часовому поясу

    При вводе значений их нужно заключать в одинарные кавычки, как и текстовые строки
\end{defin}

\begin{defin}{Временная метка (интегральный тип)}
    timestamp, timestamp with time zone (timestamptz)

    Получается в результате объединения типов даты и времени 

    Оба типа занимают 8 байтов 

    Значения типа timestamptz хранятся приведенными к нулевому часовому поясу (UTC), а перед выводом приводятся к часовому поясу пользователя 
\end{defin}

\begin{defin}{Тип interval}
    Представляет продолжительность отрезка времени 

    Формат: quantity unit [quantity unit ...] direction

    Стандарт ISO 8601: P[yyyy-mm-dd][Thh:mm:ss]

    Значение типа interval можно получить при вычитании одной временной метки из другой 
\end{defin}

\begin{nota}{Операторы даты/времени}
    \begin{itemize}
        \item date +/- integer -- добавляет/вычитает к дате заданное число дней 
        \item date +/- interval -- добавляет/вычитает к дате интервал 
        \item date +/- time -- добавляет/вычитает к дате время 
        \item interval +/- interval -- складывает/вычисляет интервалы 
        \item timestamp +/- interval -- добавляет/вычитает к метке времени интервал 
        \item date - date -- возвращает разницу между датами в днях 
        \item timestamp - timestamp -- вычитает из одной отметки времени другую (преобразуя 24-часовые интервалы в дни)
    \end{itemize}
\end{nota}

\begin{defin}{Логический тип}
    boolean

    Может иметь три состояния: true, false, NULL. Реализует трехзначную логику 
\end{defin}

\begin{defin}{Двоичные типы данных}
    bytea

    Позволяют хранить байты с кодом 0 и другими непечатаемыми значениями (значения вне десятичного диапазона 32..126)

    В операциях с двоичными строками обрабатываются байты в чистом виде 

    Поддерживает два формата ввода и вывода (параметр bytea-output):

    \begin{itemize}
        \item hex (шестнадцатеричный) -- '$\backslash x$ коды символов в 16-ой системе'
        \item escape (спецпоследовательностей) -- '$\backslash$коды символов в 8-ой системе'
    \end{itemize}
\end{defin}

\begin{nota}{Приведение типов}
    Приведение типов в PostgreSQL -- это осуществление преобразования одного типа информации в другой

    Для приведения типов данных в PostgreSQL используется: функция CAST, выражение::тип, тип выражения 

    Неявные преобразования, производимые PostgreSQL, могут влиять на результат запроса
\end{nota}

\newpage

\section{Лекция 2. Введение в язык}

\subsection{Язык SQL}

\begin{defin}{Язык SQL}
    SQL (Structured Query Language) -- язык структурированных запросов 

    Разработан IBM в 1970-х годах. Принят органами стандартизации ANSI и ISO. Первоначальное название -- SEQUEL (Structured English QUEry Language). Широко используется в промышленности (диалекты)

    Язык запросов SQL:

    \begin{itemize}
        \item Является декларативным 
        \item Определяет требования к результату, а не алгоритм выполнения 
        \item Регистронезависим
    \end{itemize}
\end{defin}

\begin{nota}{История версий стандарта SQL}
    \begin{center}
        \begin{tabular}{| m{5em} | m{33em} |}
            \hline
            Название & Изменения \\ 
            \hline
            SQL-86 & Первый вариант стандарта, принятый институтом ANSI и одобренный ISO в 1987 году \\
            \hline
            SQL-89 & Немного доработанный вариант предыдущего стандарта \\ 
            \hline
            SQL-92 & Значительные изменения (ISO 9075); уровень Entry Level стандарта SQL-92 был принят как стандарт FIPS 127-2 \\
            \hline
            SQL:1999 & Добавлена поддержка регулярных выражений, рекурсивных запросов, поддержка триггеров, базовые процедурные расширения, не скалярные типы данных и некоторое объектно-ориентированные возможности \\
            \hline
            SQL:2003 & Введены расширения для работы с XML-данными, оконные функции, генераторы последовательностей и основанные на них типы данных \\
            \hline
            SQL:2006 & Функциональность работы с XML-данными значительно расширена. Появилась возможность совместно использовать в запросах SQL и XQuery \\
            \hline
            SQL:2008 & Улучшены возможности оконных функций, устранены некоторое неоднозначности стандарта SQL:2003 \\
            \hline
            SQL:2011 & Добавлена поддержка temporal баз данных. Расширены возможности использования оконных функций и выражение FETCH \\
            \hline
            SQL:2016 & Добавлен поиск на основе шаблона строк, полиморфические табличные функции, JSON \\
            \hline
            SQL:2019 & Добавлена часть 15, многомерные массивы (MDarray type and operatorrs) \\
            \hline
        \end{tabular}
    \end{center}
\end{nota}

\begin{nota}{Команды языка SQL}
    SQL command:
    \begin{itemize}
        \item DDL 
        
        \begin{itemize}
            \item Create 
            \item Alter 
            \item Drop 
            \item \textbf{Truncate Table}
        \end{itemize}

        \item DCL 
        
        \begin{itemize}
            \item Grant
            \item Revoke 
        \end{itemize}

        \item DML 
        
        \begin{itemize}
            \item Insert
            \item Update 
            \item Delete
        \end{itemize}

        \item TCL 
        
        \begin{itemize}
            \item \textbf{Begin}
            \item Commit 
            \item Rollback 
            \item Savepoint
        \end{itemize}

        \item DQL
        
        \begin{itemize}
            \item Select
        \end{itemize}
    \end{itemize}
\end{nota}

\begin{Remark}{DDL -- Data Definition Language}
    Используются для определения структур базы данных 

    \begin{itemize}
        \item CREATE -- создание объектов 
        \item ALTER -- модификация структуры объектов 
        \item DROP -- удаление объектов
        \item TRUNCATE TABLE -- пересоздание таблицы с удалением всех записей и освобождением места
    \end{itemize}
\end{Remark}

\begin{Remark}{DCL -- Data Control Language}
    Используются для управления привилегиями пользователей на доступ к объектам в базе данных
    
    \begin{itemize}
        \item GRANT -- предоставление привилегии 
        \item REVOKE -- отзыв ранее предоставленной привилегии (неявный запрет)
    \end{itemize}
\end{Remark}

\begin{Remark}{DML -- Data Manipulation Language}
    Команды языка манипулирования данными используются для выполнения всех типов модификации данных в базе данных 

    \begin{itemize}
        \item INSERT -- добавление записей в таблицу
        \item UPDATE -- изменение значений в полях таблицы
        \item DELETE -- удаление записей из таблицы
    \end{itemize}
\end{Remark}

\begin{Remark}{TCL -- Transaction Control Language}
    Используются для управления выполнением транзакций

    \begin{itemize}
        \item BEGIN -- открытие явной транзакции 
        \item COMMIT -- сохранение (фиксация) изменений, выполненных транзакцией
        \item ROLLBACK -- отмена (откат) изменений, выполненных транзакцией
        \item SAVEPOINT -- задание точки сохранения
    \end{itemize}
\end{Remark}

\begin{Remark}{DQL -- Data Query Language}
    Используется для извлечения данных из таблиц базы данных
\end{Remark}

\newpage 

\subsection{Написание простых запросов}

\begin{nota}{Синтаксис оператора SELECT}
    \begin{center}
        \begin{tabular}{|m{5em}|m{10em}|m{23em}|}
            \hline
            Элемент & Выражение & Описание \\
            \hline
            SELECT & Список столбцов через запятую & Определяет, какие столбцы должна содержать результирующая таблица \\
            \hline
            FROM & Определение таблиц-источников строк & Определяет таблицы-источники для извлечения данных \\
            \hline
            WHERE & Условие отбора исходных строк & Фильтрует данные из таблиц-источников с помощью предиката \\
            \hline
            GROUP BY & Группировка по списку столбцов & Упорядочивает строки по группам \\
            \hline 
            HAVING & Условие отбора групп & Фильтрует группы с помощью предиката \\ 
            \hline
            ORDER BY & Сортировка по списку столбцов & Сортирует строки результирующей таблицы \\
            \hline
        \end{tabular}
    \end{center}
\end{nota}

\begin{Remark}{Логическая последовательность выполнения оператора SELECT}
    Порядок, в котором запрос записывается отличается от порядка в котором запрос выполняется сервером БД 

    \begin{tabular}{m{2em} m{6em} m{15em}}
        5. & SELECT & <select list> \\
        7. & [INTO & new\_table\_name] \\
        1. & FROM & <table source> \\
        2. & WHERE & <search condition> \\
        3. & GROUP BY & <group by list> \\
        4. & HAVING & <search condition> \\
        6. & ORDER BY & <order by list>[ASC|DESC] \\
    \end{tabular}
\end{Remark}

\begin{Example}{Применение логического порядка операций к написанию SELECT}
    \begin{lstlisting}
        SELECT empid,
            extract('year' from orderdate) AS OrderYear
        FROM "Sales"."Orders"
        WHERE custid = 71
        GROUP BY empid, extract('year' from orderdate)
        HAVING COUNT(*) > 2
        ORDER BY empid, OrderYear;
    \end{lstlisting}
\end{Example}

\begin{Remark}{SELECT безо всего}
    Используется для:

    \begin{itemize}
        \item Инициализации переменных
        \item Возврата результата выражений и функций
    \end{itemize}
\end{Remark}

\begin{Example}{Извлечение данных из таблицы}
    Извлечение из всех столбцов таблицы 
    \begin{lstlisting}
SELECT *
FROM "Sales"."Customers";
    \end{lstlisting}

    Извлечение из отдельных столбцов таблицы 
    \begin{lstlisting}
SELECT companyname, country
FROM "Sales"."Customers";
    \end{lstlisting}
\end{Example}

\begin{nota}{Элементы языка}
    \begin{center}
        \begin{tabular}{|m{15em}|m{20em}|}
            \hline
            Элементы языка & Предикаты и операторы \\
            \hline
            Предикаты & BETWEEN, IN, LIKE, IS, ALL, ANY, SOME \\
            \hline
            Операторы сравнения & =, >, <, >=, <=, <> (!=) \\
            \hline
            Логические операторы & AND, OR, NOT \\
            \hline
            Арифметические операторы & *, /, \%, +, -, - (унарный) \\
            \hline
            Конкатенация (*зависит от диалекта языка) & ||, *(\&, +) \\
            \hline
        \end{tabular}
    \end{center}
\end{nota}

\begin{Example}{Вычисляемые столбцы и псевдонимы столбцов}
    Создание вычисляемых столбцов 
    \begin{lstlisting}
SELECT unitprice, qty, (qty * unitprice) 
FROM "Sales"."OrderDetails";
    \end{lstlisting}

    Псевдонимы заключаются в двойные качки, если содержат пробелы, специальные символы или необходимо различать регистры символов
    \begin{lstlisting}
SELECT unitprice, qty Quantity, (qty * unitprice) AS Total 
FROM "Sales"."OrderDetails";
    \end{lstlisting}
\end{Example}

\begin{Example}{Псевдонимы таблиц}
    Создаются в предложении FROM. Полезны при выборке данных из нескольких таблиц 
    \begin{lstlisting}
SELECT custid, orderdate 
FROM "Sales"."Orders" AS SO;
    \end{lstlisting}

    Ссылка на столбцы таблицы с использованием псевдонима таблицы 
    \begin{lstlisting}
SELECT SO.custid, SO.orderdate
FROM "Sales"."Orders" AS SO;
    \end{lstlisting}
\end{Example}

\begin{nota}{Влияние логического порядка выполнения запроса на псевдонимы}
    Предложения FROM, WHERE и HAVING обрабатываются до SELECT 

    Псевдонимы столбцов создаются в SELECT и видны только в ORDER BY 

    Выражения, для которых в предложении SELECT определены псевдонимы, должны быть повторно использованы в остальных предложениях запроса
\end{nota}

\begin{nota}{Использование выражения CASE в предложении SELECT}
    Выражение CASE возвращает скалярное значение 

    CASE может использоваться для:

    \begin{itemize}
        \item Создания вычисляемого столбца в SELECT 
        \item Формирования условия в WHERE или HAVING
        \item Задания порядка сортировки в ORDER BY
    \end{itemize}

    CASE возвращает результат вычисления выражения
\end{nota}

\begin{nota}{Формы выражений CASE}
    \begin{itemize}
        \item Simple CASE 
        
        \begin{itemize}
            \item Сравнивает одно выражение со списком возможных значений 
            \item Возвращает первое совпадение
            \item Если совпадений не обнаружено, возвращает значение, основываясь на выражении ELSE
            \item Если не найдено совпадений и не определено выражение ELSE, возвращает NULL
        \end{itemize}
        
        \item Searched CASE 
        
        \begin{itemize}
            \item Проверяет набор предикатов или логических выражений 
            \item Возвращает значение указанное в выражении THEN первого выражения, которое возвращает TRUE
        \end{itemize}
    \end{itemize}
\end{nota}

\begin{Example}{Simple CASE}
    \begin{lstlisting}
SELECT contactname,
    CASE contacttitle
        WHEN 'Owner' THEN 'Yes'
        ELSE 'No'
    END AS Owner
FROM "Sales"."Customers"
    \end{lstlisting}
\end{Example}

\begin{Example}{Searched CASE}
    \begin{lstlisting}
SELECT productname, unitprice,
    CASE 
        WHEN discontinued = 1::bit THEN 'withdrawn from sale'
        WHEN unitprice < 25::money THEN 'low price'
        WHEN unitprice BETWEEN 25::money AND 30::money THEN 'medium-price'
        WHEN unitprice BETWEEN 31::money AND 50::money THEN 'high-price'
    ELSE 'VIP-price'
END AS "Price category"
FROM "Production"."Products"
    \end{lstlisting}
\end{Example}

\begin{nota}{Использование функций}
    \begin{center}
        \begin{tabular}{|m{9em}|m{12em}|m{15em}|}
            \hline
            Функции форматирования и преобразования & Поддержка приведения и преобразования типов данных & CAST, TO\_CHAR, TO\_DATE, TO\_NUMBER, TO\_TIMESTAMP \\
            \hline
            Логические функции & Выполнение логических операций & NULLIF, GREATEST, LEAST \\
            \hline
            Функции даты и времени & Выполняют операции над значениями даты и времени & AGE, NOW, CURRENT\_DATE, CURRENT\_TIME, LOCALTIME, DATE\_PART, DATE\_TRUNC, MAKE\_DATE, EXTRACT \\
            \hline
            Строковые функции & Выполняют операции со строковыми (char и varchar) значениями & CONCAT, CONCAT\_WS, FORMAT, LEFT, LENGTH, LOWER, LTRIM, REPLACE, REGEXP\_REPLACE, REVERSE, RIGHT, RTRIM, SUBSTRING, TRIM, UPPER \\
            \hline
            Математические функции & Выполняют вычисления, основанные на числовых значениях & ABS, CEILING, FLOOR, POWER, ROUND, SQRT, TRUNC \\
            \hline
            Функции для перечислений & Используются для работы с типами перечислений (ENUM) & ENUM\_FIRST, ENUM\_LAST, ENUM\_RANGE \\
            \hline
        \end{tabular}
    \end{center}
\end{nota}

\newpage

\subsection{Сортировка данных}

\begin{nota}{Использование ORDER BY}
    ORDER BY сортирует записи в результирующем наборе. Без ORDER BY порядок записей результирующей выборки не гарантируется. Сортирует все NULL значения вместе 

    ORDER BY может ссылаться на:

    \begin{itemize}
        \item Имя столбца, псевдоним или позицию столбца в результирующей выборке (не рекоммендуется)
        \item Результат выражения 
        \item Столбцы, не используемые в результирующей выборке (если не используется DISTINCT)
    \end{itemize}

    ORDER BY не поддерживается в инструкциях SELECT/INTO 
\end{nota}

\begin{Example}{Пример использования ORDER BY}
\begin{lstlisting}
SELECT companyname, contactname 
FROM "Sales"."Customers" c 
ORDER BY country ASC, city desc;

SELECT custid, orderdate 
FROM "Sales"."Orders" o 
ORDER BY DATE_PART('year', orderdate) DESC;
\end{lstlisting}
\end{Example}

\begin{nota}{Фильтрация с помощью LIMIT*}
    Ограничивает число строк, возвращаемых в результирующем наборе 

    \begin{itemize}
        \item integer\_expression -- число или числовое выражение, определяющее количество возвращаемых строк 
        \item ALL -- равносильно отсутствию указания LIMIT
        \item OFFSET -- указывает число строк, которые необходимо пропустить, прежде чем начать выдавать строки 
        \item Для получения предсказуемого и согласованного результата необходимо использовать фильтрацию отсортированого набора ORDER BY
    \end{itemize}
\end{nota}

\begin{Example}{Фильтрация с помощью LIMIT}
\begin{lstlisting}
SELECT productname, unitprice
FROM "Production"."Products"
WHERE unitprice <= 40::money 
ORDER BY unitprice DESC
limit 3;
\end{lstlisting}
\end{Example}

\begin{nota}{Фильтрация в ORDER BY с помощью OFFSET-FETCH}
    OFFSET-FETCH -- это расширение ORDER BY. Позволяет отфильтровать требуемый диапазон строк. Предоставляет механизм для разбиения результирующего набора на страницы 

    Определяет количество строк, которые необходимо 

    \begin{itemize}
        \item Пропустить -- OFFSET (может быть ноль, если не нужно пропускать строки)
        \item Вернуть -- FETCH (должно быть больше или равно единице)
    \end{itemize}

    Если FETCH опущено -- возвращаются все записи до конца набора 

    WITH TIES -- вернуть дополнительные строки, с точки зрения ORDER BY совпадающие с последней строкой набора результатов
\end{nota}

\begin{Example}{Фильтрация с помощью OFFSET-FETCH}
\begin{lstlisting}
SELECT orderid, custid, orderdate 
FROM "Sales"."Orders" o 
ORDER BY orderdate DESC 
OFFSET 50 ROWS FETCH FIRST 50 ROWS ONLY;
\end{lstlisting}
\end{Example}

\begin{nota}{Фильтрация дубликатов}
    SELECT DISTINCT используется для возврата только уникальных записей: удаляет дубликаты, базируясь на результирующем списке столбцов (не на основе таблицы-источника); работает с записями уже обработанными в выражениях WHERE, HAVING и GROUP BY; NULL значения уникальны 
\end{nota}

\begin{defin}{DISTINCT ON}
    DISTINCT ON отличается от DISTINCT тем, что определяет уникальность записей не по всем полям, а только указанным. Строки с одинаковыми значениями выражений считаются дублирующимися и возвращается только первая строка. Обработка DISTINCT ON производится после сортировки ORDER BY 
\end{defin}

\newpage

\subsection{Фильтрация записей}

\begin{defin}{Фильтрация исходных записей -- WHERE}
    Содержит логическое условие: записи, для которых условие возвращает TRUE -- попадают в результрующую выборку; FALSE и UNKNOWN -- отфильтровываются

    В предложении WHERE не доступны псевдонимы столбцов 

    Данные фильтруются на стороне сервера. Оптмизиация за счет использования индексов, снижение нагрузки на сеть и использование памяти на клиенте 
\end{defin}

\begin{nota}{Операторы сравнения}
    \begin{center}
        \begin{tabular}{|m{8em}|m{19em}|m{10em}|}
            \hline
            Оператор & Описание & Пример \\
            \hline
            < > = <= >= <> !< !> != & Операторы сравнения & Name != 'Vasia' или Name <> 'Vasia' \\ 
            \hline 
            $\sim$ и !$\sim$ & Проверка соответствия строки регулярному выражению POSIX с учетом регистра & 'Thomas' $\sim$ '.*thomas.*' $\to$ False \\
            \hline 
            $\sim$* и !$\sim$* & Проверка соответствия строки регулярному выражению POSIX без учета регистра & 'Thomas' $\sim$* '.*thomas' $\to$ True \\
            \hline
        \end{tabular}
    \end{center}
\end{nota}

\begin{nota}{Предикативные операторы}
    \begin{center}
        \begin{tabular}{|m{10em}|m{17em}|m{10em}|}
            \hline
            Оператор & Описание & Пример \\
            \hline
            BETWEEN/NOT BETWEEN & Проверка по диапазону & orderdate BETWEEN '2006-07-05' AND '2006-07-25' \\
            \hline
            IN/NOT IN & Проверка на основе списка & Price IN (50, 125, 253, 264) \\
            \hline
            LIKE/NOT LIKE & Сравнение строк по маске с учетом регистра & City LIKE 'London' \\
            \hline
            ILIKE/NOT ILIKE & Сравнение строк по маске без учета регистра & City ILIKE 'london' \\
            \hline
            SIMILAR TO/NOT SIMILAR TO & Сравнение строк по шаблону на основе регулярных выражений в стандарте SQL & 'abc' SIMILAR TO '\%(b|d)\%' \\
            \hline
            IS NULL/IS NOT NULL & Проверка на наличие/отсутствие NULL значений & region IS NOT NULL \\
            \hline
            IS DISTINCT FROM/IS NOT DISTINCT FROM & Проверка на неравенство/равенство заданному значению. При этом NULL воспринимается как обычное значение & region IS DISTINCT FROM 'WA' \\
            \hline
        \end{tabular}
    \end{center}
\end{nota}

\begin{Example}{Использование операторов сравнения}
\begin{lstlisting}
SELECT productname, unitprice
FROM "Production"."Products" p 
WHERE discontinued != 1::bit;
\end{lstlisting}
\end{Example}

\begin{Example}{Фильтрация с использованием логических операторов}
    Приоритет логических операторов -- NOT, AND, OR 

    Если два оператора в выражении имеют один и тот же уровень приоритета, они вычисляются в порядке слева направо по мере их появления в выражении 

    Чтобы изменить приоритет операторов в выражении, следует использовать скобки

\begin{lstlisting}
SELECT * 
FROM "Production"."Products" p
WHERE categoryid = 1 OR categoryid = 2 AND unitprice >= 40::money;
\end{lstlisting}
\end{Example}

\begin{Example}{Фильтрация NULL значений}
    NULL значения используются для маркировки отсутствующих значений (missing values)

    Для корректно обработки необходимо использовать предикаты:

    \begin{itemize}
        \item IS NULL (ISNULL) или IS NOT NULL (NOTNULL)
        \item IS DISTINCT FROM (!=) или IS NOT DISTINCT FROM (=)
    \end{itemize}

\begin{lstlisting}
SELECT companyname, region
FROM "Sales"."Customers" c
WHERE region IS NULL;

SELECT companyname, region
FROM "Sales"."Customers" c
WHERE region IS DISTINCT FROM 'WA';
\end{lstlisting}
\end{Example}

\begin{Example}{Проверка на принадлежность диапазону}
    Границы диапазона включены. Для задания исключающего диапазона используйте операторы больше (>) и меньше (<)

    Если любой параметр предиката BETWEEN или NOT BETWEEN имеет значение NULL, результат не определен (UNKNOWN)

\begin{lstlisting}
SELECT productname, unitprice
FROM "Production"."Products" p
WHERE unitprice BETWEEN 30::money AND 38::money;
\end{lstlisting}
\end{Example}

\begin{Example}{Проверка на принадлежность множеству}
    Определеяет, совпадает ли указанное значение с одним из значений, содержащихся во вложенном запросе или списке

    Использование значений NULL с предикатами IN/NOT IN может привести к непредвиденным результатам

\begin{lstlisting}
SELECT productname, unitprice
FROM "Production"."Products" p
WHERE unitprice IN (22::money, 30::money, 32::money, 38::money);
\end{lstlisting}
\end{Example}

\begin{Example}{Проверка на соответствие шаблону}
\begin{lstlisting}
match_expression [NOT] LIKE pattern [ESCAPE escape_character]
match_expression [NOT] ILIKE pattern [ESCAPE escape_character]
\end{lstlisting}
\end{Example}

\begin{Example}{Фильтрация по шаблону}
\begin{lstlisting}
SELECT custid, contactname, contacttitle
FROM "Sales"."Customers" c
WHERE contacttitle LIKE '%Manager';

SELECT custid, contactname, contacttitle
FROM "Sales"."Customers" c
WHERE contactname LIKE 'C%' OR contactname LIKE 'L%';
\end{lstlisting}
\end{Example}

\begin{Example}{Сопоставление с началом строки}
\begin{lstlisting}
SELECT custid, contactname, contacttitle
FROM "Sales"."Customers" c
WHERE start_with(contactname, 'L');

SELECT custid, contactname, contacttitle
FROM "Sales"."Customers" c
WHERE contactname ^@ 'C' OR contactname ^@ 'L';
\end{lstlisting}
\end{Example}

\begin{nota}{Символы шаблона POSIX}
    \begin{center}
        \begin{tabular}{|m{3em}|m{30em}|}
            \hline
            . & любой один символ \\ 
            \hline
            [...] & любой один символ в диапазоне или наборе \\
            \hline
            [\^\ ...] & любой один символ, не входящий в диапазон или набор \\
            \hline
            * & повторение предыдущего элемента 0 и более раз \\
            \hline
            + & повторение предыдущего элемента 1 и более раз \\
            \hline
            ? & вхождение предыдущего элемента 0 или 1 раз \\
            \hline
            $\{m\}$ & ровно m вхождений предыдущего элемента \\
            \hline
            $\{m,\}$ & m и более вхождений предыдущего элемента \\
            \hline
            $\{m,n\}$ & от m до n вхождений предыдущего элемента \\
            \hline
            () & объединение нескольких элементов в одну логическую группу \\
            \hline
            | & выбор (одного из двух вариантов) \\
            \hline
             & привязывает шаблон к началу строки \\
            \hline
            \$ & привязывает шаблон к концу строки \\
            \hline
        \end{tabular}
    \end{center}
\end{nota}

\begin{nota}{Проверка на соответствие шаблону POSIX}
    Возвращает true или false в зависимости от того, соответствует ли данная строка шаблону или нет. Шаблоны соответствуют определению регулярных выражений в стандарте SQL. Регулярные выражения SQL представляют собой гибрид синтаксиса LIKE с синтаксисом обычных регулярных выражений POSIX 

    Условие SIMILAR TO истинно, только если шаблон соответствует всей строке. Это отличается от условий с регулярными выражениями, в которых шаблон может соответствовать любой части строки
\end{nota}

\begin{Example}{Фильтрация с помощью SIMILAR TO}
\begin{lstlisting}
SELECT custid, contactname, contacttitle
FROM "Sales"."Customers" c
WHERE contactname SIMILAR to 'S(i|m)%';

SELECT custid, contactname, contacttitle
FROM "Sales"."Customers" c
WHERE contactname NOT SIMILAR to '[^B-R]%';
\end{lstlisting}
\end{Example}

\begin{nota}{Операторы регуярных выражений POSIX}
    \begin{center}
        \begin{tabular}{|m{3em}|m{20em}|m{10em}|}
            \hline
            Оператор & Описание & Пример \\
            \hline 
            $\sim$ & Проверка соответствия строки регулярному выражению с учетом регистра & 'thomas' $\sim$ 't.*ma' \\
            \hline
            $\sim$* & Проверка соответствия строки регулярному выражению без учета регистра & 'thomas' $\sim$* 'T.*ma' \\
            \hline
            !$\sim$ & Проверка несоответствия строки регулярному выражению с учетом регистра & 'thomas' !$\sim$ 't.*max' \\
            \hline
            !$\sim$* & Проверка несоответствия строки регулярному выражению без учета регистра & 'thomas' !$\sim$* 'T.*ma' \\
            \hline
        \end{tabular}
    \end{center}
\end{nota}

\begin{Example}{Фильтрация с использованием операторов регулярных выражений}
\begin{lstlisting}
SELECT region 
FROM "Sales"."Customers" c 
WHERE region ~ '.*ra$';

SELECT companyname, contactname, city 
FROM "Sales"."Customers" c 
WHERE contactname ~ '^(B|K|S).*(e|k)$';
\end{lstlisting}
\end{Example}

\newpage

\subsection{Массивы}

\begin{defin}{Массивы}
    Многомерные массивы переменной длины 

    Элементами массивов могут быть: 

    \begin{itemize}
        \item Любые встроенные или определенные пользователями базовые типы
        \item Перечисления, составные типы, типы-диапазоны или домены 
    \end{itemize}

    Для объявления типа массива 

    \begin{itemize}
        \item К названию типа элементов добавляются квадратные скобки 
        \item Запись с ключевым словом ARRAY
    \end{itemize}
\end{defin}

\begin{Example}{}
\begin{lstlisting}
integer[3]
integer ARRAY[3]
integer ARRAY 
\end{lstlisting}
\end{Example}

\begin{Example}{Определение массива}
\begin{lstlisting}
SELECT '{1,2,3,4,5}'::integer[], ARRAY[1,2,3]::integer[];

SELECT '{{1,2},{3,4}}'::integer[], ARRAY[[1,2],[3,4]]::integer[];
\end{lstlisting}
\end{Example}

\begin{Example}{Добавление элементов в массив}
    Добавление элементов в массив:

    \begin{itemize}
        \item Оператор || (конкатенация)
        \item Функция array\_append(массив, элемент)
        \item Функция array\_prepend(элемент, массив)
    \end{itemize}
\begin{lstlisting}
SELECT '{1,2,3,4}'::integer[] || 5,
    array_append('{1,2,3,4}'::integer[],5),
    array_prepend(5,'{1,2,3,4}'::integer[]);
\end{lstlisting}
\end{Example}

\begin{Example}{Удаление и изменение элементов массива}
    Удаление элементов из массива: функция array\_remove(массив, значение элемента)

    Изменение элемента массива: функция array\_replace(массив, старое значение, новое значение)

\begin{lstlisting}
SELECT array_remove('{1,2,3,4}::integer[],3),
    array_replace('{1,2,3,4}'::integer[],2,5);
\end{lstlisting}
\end{Example}

\begin{Example}{Извлечение элементов массива}
    Индексация элементов массива начинается с 1 

    Для извлечения одного элемента массива -- необходимо указать его номер в []

    Для извлечения нескольких элементов из массива -- необходимо в [] указать номер первого элемента и номер последнего извлекаемого элемента разделенные символом двоеточие

\begin{lstlisting}
select ('{"(921)-745-8965","(908)-567-78234",
        "(911)-745-8512","(812)-750-8965"}'::text[])[2];
\end{lstlisting}
\end{Example}

\begin{Example}{Проверка на вхождение в массив}
    Для проверки вложенности элементов одного массива в состав элементов другого массива используются операторы вложенности массивов (<@, @>)

    Один массив считается вложенным в другой, если каждый элемент первого встречается во втором. Повторяющиеся элементы рассматриваются на общих основаниях

\begin{lstlisting}
select '{(408)-567-78234}'::text[] <@ '{(408)-745-8965","(408)-567-78234"}'::text[];
\end{lstlisting}

    Для проверки вхождения литерала в массив используется оператор ANY (SOME)

\begin{lstlisting}
SELECT 10 = SOME (ARRAY[192, 168, 10, 10]);
\end{lstlisting}
\end{Example}

\begin{Example}{Разворачивание массива в набор записей}
    Чтобы представить элементы массива в виде значений некоторого столбца необходимо воспользоваться функцией UNNEST (ANYARRAY)

\begin{lstlisting}
SELECT UNNEST(ARRAY[100, 110, 153, 500]) as prodid,
        50000::money as price,
        '2022-10-20' as change_date;
\end{lstlisting}
\end{Example}

\begin{Example}{Пример использования массива}
\begin{lstlisting}
select contactname,
        split_part(contactname,',',1) as "Lname",
        trim((string_to_array(contactname,','))[2]) as "Fname"
from "Sales"."Customers";
\end{lstlisting}
\end{Example}

\newpage 

\subsection{Типы JSON}

\begin{defin}{JSON}
    JSON (JavaScript Object Notation) -- текстовый формат обмена данным, основанный на JavaScript. Как и многие другие текстовые форматы, JSON легко читается людьми. ФОрмат JSON был разработан Дугласом Крокфордом 

    Несмотря на происхождение от JavaScript (точнее, от подмножества языка стандарта ECMA-262 1999 года), формат считается независимым от яызка и может использоваться практически с любым языком программирования 

    Для многих языков существует готовый код для создания и обработки данных в формате JSON 
\end{defin}

\begin{nota}{Структура JSON-данных}
    JSON -- текст, имеющий одну из двух структур: 

    \begin{itemize}
        \item Ключ -- может быть только строка (регистрозависимость не регулируется стандартом, это остается на усмотрение программного обеспечения)
        \item Значение -- любая допустимая форма
    \end{itemize}

    Упорядоченный набор значений. Во многих языках это реализовано как массив, вектор, список или последовательность
\end{nota}


\begin{nota}{Значения JSON}
    В качестве json значений могут выступать:

    \begin{itemize}
        \item Запись -- неупорядоченное множество пар ключ:значение, заключенное в фигурные скобки. Пары ключ-значение отделяются друг от друга запятыми
        \item Массив (одномерный) -- это упорядоченное множество значений. Массив заключается в квадратные скобки. Значения разделяются запятыми. Массив может быть пустым. Значение в пределах одного массива могут иметь разный тип 
        \item Число (целое или вещественное)
        \item Литералы (в нижнем регистре) true, false и null 
        \item Строка -- это упорядоченное множество из нуля или более символов юникода, заключенное в двойные кавычки. Поддерживаются строковые константы со спецпоследовательностями в стиле C и строковые константы со спецпоследовательностями Unicode 
    \end{itemize}
\end{nota}

\begin{nota}{Типы данных JSON}
    Предназначены для сохранения и обработки данных в формате JSON в БД PostgreSQL

    Существует два типа данных для работы с JSON, которые отличаются способом хранения данных и способом работы с ними: json и jsonb 
\end{nota}

\begin{Remark}{json}
    Использует текстовый формат хранения JSON-данных, который позволяет хранить только простые типы данных JSON: строки, числа, логические значения, null и массивы или объекты, состоящие только из этих типов

    При хранении данных типа json не происходит никакой оптимизации -- высокая скорость записи 

    \begin{itemize}
        \item Сохраняет порядок следования ключей и повторяющиеся значения ключей, при этом функции обработки будут считать действительной последнюю пару 
        \item Любые изменения в данных приводят к перезаписи всей строки JSON 
        \item При использовании выполняется полный разбор -- низкая скорость обработки 
    \end{itemize}
\end{Remark}

\begin{Remark}{jsonb}
    Использует бинарный формат хранения JSON-данных, который позволяет хранить все типы данных JSON, включая вложенные объекты и массивы, а также дополнительные типы данных, такие как булевы значения, даты и времена итд 

    Бинарный формат данных jsonb позволяет эффективно хранить, индексировать и быстро выполнять запросы к данным в формате JSON:

    \begin{itemize}
        \item Разбор производится однократно при сохранении -- низкая скорость сохранения 
        \item Ключи не дублируются 
        \item Отсортированы по длине и ключу 
        \item При изменении данных не требует перезаписи всей строки JSON, а лишь тех частей, которые изменились 
        \item При использовании разбор не выполняется -- высокая скорость обработки 
    \end{itemize}
\end{Remark}

\begin{Remark}{ВАЖНО!}
    PostgreSQL позволяет использовать только одну кодировку символов в базе данных. Если кодировка базы данных не UTF-8:

    \begin{itemize}
        \item Данные JSON не будут полностью соответствовать спецификации
        \item Нельзя будет вставить символы, непредставимые в кодировке сервера 
        \item Допустимыми будут символы, представимые в кодировке сервера, но не в UTF-8
    \end{itemize}
\end{Remark}

\begin{Example}{Примеры json данных}
    \begin{itemize}
        \item Числа, строки в двойных кавычках, true и false (в нижнем регистре) или null 
        
        \begin{lstlisting}
SELECT '5'::json, '"Post"'::json, 'true'::json, 'null'::json;
        \end{lstlisting}

        \item Массив из нуля и более элементов (элементы могут быть разных типов)
        
        \begin{lstlisting}
SELECT '[1, 2, "foo", null]'::json;
        \end{lstlisting}

        \item Объект, содержащий пары ключей и значений (ключи объектов -- всегда строки в двойных кавычках)
        
        \begin{lstlisting}
SELECT '{"cheef":"Ivan", "Empl":["Svetlana","Eugen"]}'::jsonb;
        \end{lstlisting}
    \end{itemize}
\end{Example}

\begin{defin}{Функции-конструкторы}
    Для формирования json можно использовать специализированные функции:

    \begin{itemize}
        \item to\_json(anyelement) и to\_jsonb(anyelement) 
        \item jsonb\_build\_object(VARIADIC "any"\ ) и jsonb\_build\_array(VARIADIC "any"\ )
        \item array\_to\_json(anyarray [, pretty\_bool ]) 
        \item row\_to\_json(record [, pretty\_bool ])
        \item json\_object(keys text[], values text[]) и jsonb\_object(keys text[], values text[])
    \end{itemize}
\end{defin}

\begin{Example}{Извлечение значений по индексу и имени ключа}
    Получение элементов массива по индексу (индексация элементов начинается с 0. Отрицательные числа задают позиции с конца)

\begin{lstlisting}
SELECT '[{"a":"foo"},{"b":"bar"}]'::json -> 2;
SELECT '[{"a":"foo"},{"b":"bar"}]'::jsonb ->> -1;
\end{lstlisting}

    Получение значения по имени ключа 

\begin{lstlisting}
SELECT '{"cheef":"Ivan", "Empl":["Svetlana","Eugen"]}'::json -> 'cheef';
SELECT '{"cheef":"Ivan", "Empl":["Svetlana","Eugen"]}'::jsonb ->> 'Empl';
\end{lstlisting}
\end{Example}

\begin{Example}{Проверка наличия ключа верхний уровень (jsonb)}
    Типы данных json или jsonb не требуют задавать структуру объектов, т.е. конкретные имена ключей и типы значений. Может потребоваться выполнить проверку наличия соответствующего ключа. Сделать это можно только для типа данных jsonb

\begin{lstlisting}
SELECT '[{"a":"foo"},{"b":"bar"}]'::jsonb ? 'b';
\end{lstlisting}
\end{Example}

\begin{Example}{Извлечение элементов по пути}
    Для извлечения элементов можно использовать указание пути 

    \begin{itemize}
        \item \#> -- результат json/jsonb 
        \item \#>> -- результат текст
    \end{itemize}
\end{Example}

\begin{Example}{Проверка вхождения по пути (jsonb)}
    Для проверки наличия пути/значения используется оператор @> (<@)

\begin{lstlisting}
SELECT '{"a":1, "b":2}'::jsonb @> '{"b":2}'; --true
\end{lstlisting}
\end{Example}

\begin{nota}{Функции}
    \begin{itemize}
        \item json\_extract\_path -- возвращает значение JSON по пути, заданному элементами пути (\#>)
        \item json\_extract\_path\_text -- возвращает значение JSON по пути, заданному элементами пути, как text (\#>>)
        \item jsonb\_path\_exists -- выполняет поиск ключа как на заданном уровне, так и на произвольном 
        \item jsonb\_path\_match -- выполняет проверку предиката пути JSON для заданного значения JSON
        \item jsonb\_strip\_nulls -- удаления ключей с NULL-значениями
    \end{itemize}
\end{nota}

\begin{nota}{Изменение json и jsonb}
    \begin{itemize}
        \item Добавление/изменение элементов (jsonb\_set)
        \item Удаление элементов (-)
    \end{itemize}
\end{nota}

\newpage

\subsection{Встроенные функции}

\begin{nota}{Типы функций}
    \begin{itemize}
        \item Обзор встроенных функций 
        \item Функции для работы с текстом 
        \item Функции для работы с датой/временем 
        \item Функции для работы с числами 
        \item Функции преобразования и форматирования 
        \item Функции для работы с NULL 
        \item Системные информаицонные функции
    \end{itemize}
\end{nota}

\begin{nota}{Обзор встроенных функций}
    PostgreSQL предоставляет широкий набор встроенных функций, работающих со встроенными типами данных

    Все встроенные функции разделяются на стандартные функции SQL92 и функции в стиле PostgreSQL

    \begin{itemize}
        \item В функциях SQL92 аргументы разделяются специальными ключевыми словами SQL (такими, как FROM, FOR, USING)
        \item Функции в стиле PostgreSQL получают аргументы, разделенные запятыми
    \end{itemize}

    \textbf{Внимание:} круглые скобки не обязательны только для ряда функци SQL92
\end{nota}

\begin{nota}{Использование вложенных функций}
    Вызовы функций могут быть вложенными: тип данных, возвращаемый внутренней функцией должен быть совместим с типом соответствующего аргумента внешней функции

    Допускается вложение вызовов на произвольную глубину
\end{nota}

\begin{defin}{Строковые функции}
    В PostgreSQL существует множество разнообразных строковых функций, предназначенных для форматирования, анализа и сравнения строк. Под строками в данном контексте подразумеваются значения типов character, character varying и text
\end{defin}

\begin{nota}{Строковые функции}
    \begin{itemize}
        \item char\_length('string')
        \item character\_length('string')
        \item length('string')
        \item lower('string')
        \item upper('string')
        \item strpos('string', 'substring')
        \item position('substring' in 'string')
        \item subst('string', from\_int[, count\_int])
        \item substring('string' [from int] [for int])
        \item substring('string' from 'шаблон POSIX')
        \item substring('string' from 'шаблон SQL' for 'спецсимвол')
        \item regexp\_matches('string', 'шаблон POSIX')
        \item repeat('string', count\_int)
        \item reverse('string')
        \item trim([leading|trailing|both]['characters'] from 'string')
        \item ltrim('string'[, 'characters'])
        \item rtrim('string'[, 'characters'])
        \item right('string', count\_int)
        \item left('string', count\_int)
        \item concat(arg1 [,arg2[,...]])
        \item concat\_ws('separator',arg1[,arg2[,...]])
        \item replace('string','old text','new text')
        \item translate('string,'old text','new text')
        \item overlay('string' placing 'substring' from int [for int])
        \item regexp\_replace('string','шаблон POSIX','replacement')
        \item split\_part('string' text, 'delimiter', item\_int)
        \item regexp\_split\_to\_array('string','шаблон POSIX')
    \end{itemize}
\end{nota}

\begin{nota}{Использование шаблонов}
    Для определения шаблонов в PostgreSQL поддерживается два типа регулярных выражений:

    \begin{itemize}
        \item Регулярные выражения в стиле SQL 
        \item Регулярные выражения POSIX
    \end{itemize}
\end{nota}

\begin{nota}{Регулярные выражения в стиле SQL}
    Для определения шаблона в стиле SQL используются:

    \begin{itemize}
        \item \_ -- любой один символ -- '\_етров' => 'Ветров', 'Петров' и т.д.
        \item \% -- любая строка, содержащая ноль или более символов -- 'компьютер\%' => 'компьютер', 'компьютеры', 'компьютерный' и т.д.
    \end{itemize}
\end{nota}

\begin{defin}{Функция format}
    Функция format выдает текст, отформатированный в соответствии со строкой формата 

\begin{lstlisting}
format(formatstr text [, formatarg "any" [, ...]])
\end{lstlisting}

    formatstr -- спецификатор формата 

    \begin{itemize}
        \item позиция -- строка вида n\$, где n -- индекс выводимого аргумента. Если позиция опускается, по умолчанию используется следующий аргумент по поярдку
        \item Флаги -- поддерживается только знак минус, который выравнивает результат спецификатора по левому краю если определена ширина
        \item Ширина -- минимальное число символов, которое будет занимать результат данного спецификатора
        \item Тип спецификатора -- определяет преобразование соответствующего выводимого значения
        
        \begin{itemize}
            \item S -- строка
            \item I -- SQL-идентификатор, при необходимости заключается в кавычки 
            \item L -- значение аргумента заключается в апострофы, как строка SQL
        \end{itemize}
    \end{itemize}
\end{defin}

\begin{nota}{Функции даты/времени}
    \begin{itemize}
        \item age(timestamp)
        \item age(timestamp, timestamp)
        \item current\_date
        \item current\_time 
        \item current\_time(integer)
        \item current\_timestamp
        \item current\_timestamp(integer)
        \item clock\_timestamp()
        \item now()
        \item localtime 
        \item localtimestamp
        \item date\_trunc('part', timestamp)
        \item date\_trunc(text, interval)
        \item date\_trunc('part', timestamp with time zone, 'time\_zone\_name')
        \item date\_part('part', timestamp)
        \item date\_part('part', interval)
        \item extract(part from timestamp)
        \item extract (part from interval)
        \item make\_date(year int, month int, day int)
        \item make\_time(hour int, min int, sec double precision)
        \item make\_timestamp(year int, month int, day int, hour int, min int, sec double precision)
    \end{itemize}
\end{nota}

\begin{Example}{Часовые пояса (timezone names)}
\begin{lstlisting}
select name, abbrev, uct_offset
from pg_timezone_names;
\end{lstlisting}

\begin{lstlisting}
SELECT TIMESTAMP '2022-02-16 20:38:40' AT 
    TIME ZONE 'America/Denver';
\end{lstlisting}

\begin{lstlisting}
select date_trunc('day', timestamptz '2022-10-16 20:38:40+00', 'Australia/Sydney'),
    date_trunc('day', timestamptz '2022-10-16 20:38:40+00', 'US/Samoa');
\end{lstlisting}
\end{Example}

\begin{Example}{Функции даты/времени}
\begin{lstlisting}
SELECT age('2022-06-25 12:34'::timestamp),
    clock_timestamp( ),
    clock_timestamp( );
\end{lstlisting}

\begin{lstlisting}
SELECT extract(hour from timestamp '2001-02-16 20:38:40'),
    date_part('hour', timestamp '2001-02-16 20:38:40');
\end{lstlisting}
\end{Example}

\begin{nota}{Математические функции}
    \begin{itemize}
        \item random()
        \item ceil(dp/numeric)
        \item ceiling(dp/numeric)
        \item floor(dp/numeric)
        \item round(dp/numeric)
        \item round(v numeric, s integer)
        \item trunc(dp/numeric)
        \item trunc(v numeric, s integer)
        \item power(a dp, b dp)
        \item power(a numeric, b numeric)
        \item abs(x)
        \item div(y numeric, x numeric)
        \item mod(y, x)
        \item sqrt(dp/numeric)
        \item cbrt(dp)
    \end{itemize}
\end{nota}

\begin{defin}{Преобразование типов}
    Для явного преобразования типов используется 

    \begin{itemize}
        \item Функция CAST (стандарт SQL) -- CAST(выражение AS type)
        \item Конструкция :: (PostgreSQL) -- выражение::type
        \item Синтаксис функций приведения к типу -- typename(выражение). Будет работать только для типов, имена которых являются допустимыми именами функций!
    \end{itemize}
\end{defin}

\begin{Remark}{Внимание}
    Приведение будет успешным, только если определен подходящий оператор преобразования типов 

    Явно приведение типа можно опустить, если возможно однозначно определить, какой тип должно иметь выражение (неявное преобразование)

    Запись typename 'string' можно использовать только для указания типа простой текстовой константы; она не работает для массивов 
\end{Remark}

\begin{nota}{Функции форматирования}
    \begin{center}
        \begin{tabular}{|m{9em}|m{12em}|m{15em}|}
            \hline
            Функция & Описание & Пример \\
            \hline
            to\_char(timestamp, text) & Преобразует время в текст & to\_char(current\_timestamp, 'HH12:MI:SS') \\
            \hline
            to\_char(interval, text) & Преобразует интервал в текст & to\_char(interval '15h 2m 12s', 'HH24:MI:SS') \\
            \hline
            to\_char(int, text) & Преобразует целое число в текст & to\_char(125, '999') \\
            \hline
            to\_char(double precision, text) & Преобразует плавающее одинарной/двойной точности в текст & to\_char(125.8::real, '999D9') \\
            \hline
            to\_char(numeric, text) & Преобразует числовое значение в текст & to\_char(-125.8, '999D99S') \\
            \hline 
            to\_date(text, text) & Преобразует текст в дату & to\_date('05 Dec 2000', 'DD Mon YYYY') \\
            \hline
            to\_number(text, text) & Преобразует текст в число & to\_number('12,454.8-', '99G999D9S') \\
            \hline
            to\_timestamp(text, text) & Преобразует строку во время & to\_timestamp('05 Dec 2000', 'DD Mon YYYY') \\
            \hline
        \end{tabular}
    \end{center}
\end{nota}

\begin{defin}{Функции для работы с NULL}
    Функция COALESCE возвращает первый попавшийся аргумент, отличный от NULL. Если же все аргументы равны NULL, результатом тоже будет NULL 

    Функция NULLIF выдает значение NULL, если занчение1 равно значение2; в противном случае она возвращает значение1. Это может быть полезно для реализации обратной операции к COALESCE
\end{defin}

\begin{nota}{Функции получения информации о сеансе}
    \begin{center}
        \begin{tabular}{|m{10em}|m{4em}|m{20em}|}
            \hline 
            Имя & Тип рез. & Описание \\
            \hline 
            current\_catalog current\_database() & name & Имя текущей базы данных (в стандарте SQL она называется каталогом) \\
            \hline 
            current\_user current\_role & name & Имя пользователя в текущем контексте выполнения \\
            \hline 
            session\_user & name & Имя пользователя сеанса \\
            \hline 
            current\_schema[()] & name & Имя текущей схемы \\
            \hline 
            pg\_backend\_pid() & int & Код серверного процесса, обслуживающего текущий сеанс \\
            \hline 
            pg\_blocking\_pids(int) & int[] & Идентификаторы процессов, не дающих серверному процессу с определенным ID получить блокировку \\
            \hline 
            version() & text & Информация о версии PostgreSQL \\
            \hline
        \end{tabular}
    \end{center}
\end{nota}

\newpage 

\subsection{Физическое хранение БД. Низкий уровень}

\begin{nota}{Физическое хранение базы данных}
    Для каждой БД существует подкаталог внутри каталога ТП по умолчанию (PGData/base) и каталогов ТП, в которых размещены объекты БД: име подкаталога = OID БД (pg\_database). Этот подкаталог -- по умолчанию место хранения файлов БД 

    Все файлы объектов одной БД, принадлежащих одному табличному пространству, буудт помещены в один каталог
\end{nota}

\begin{nota}{Идентификация файлов связанных с таблицами и индексами}
    Каждый объект БД, хранящий данные (таблица, индекс, последовательность, материализованное представление), представляет собой набор файлов, расположенных в каталоге БД 

    Каждый объект имеет уникальный идентификатор объекта БД -- OID
    
    Файлы идентифицируются с помощью relfilenode. Значение relfilenode таблиц и индексов изначально совпадают с соответствующими OID. Выполнение команд TRUNCATE, REINDEX, CLUSTER -- изменяет значения relfilenode таблиц и индексов
\end{nota}

\begin{nota}{Типы файлов (слои)}
    Каждой объекту БД, хранящему данные, соответствует несколько типов файлов (слоев):

    \begin{itemize}
        \item Основной слой (main) -- данные 
        \item Слой инициализации (init)
        \item Карта свободного пространства (fsm -- free space map)
        \item Карта видимости (vm -- visibility map)
    \end{itemize}

    Каждый тип файла содержат определенный вид данных 

    Каждый слой состоит из одного или нескольких файлов-сегментов размером до 1Гб. Когда размер файла превышает 1Гб, PostgreSQL создает новый файл с именем refilenode.1. Изменение размера сегмета (--with-segsize) -- только при сборке 
\end{nota}

\begin{nota}{Слои данных}
    Основной слой (main) -- это данные: версии строк таблиц или строки индексов. Существует для всех объектов, хранящих данные. Имена файлов состоят только из идентификатора -- refilenode, refilenode.1 \dots 

    Слой инициализации (init) -- существует только для нежурналируемых таблиц (UNLOGGED) и их индексов:

    \begin{itemize}
        \item Действия над такими таблицами не записываются в WAL-log 
        \item При восстановлении (recovery) PostgreSQL удаляет все слои таких объектов и записывает слой инициализации на место основного слоя (получается пустая таблица)
        \item Имена файлов имеют окончание \_init -- refilenode\_init
    \end{itemize}
\end{nota}

\begin{nota}{Организация данных в куче}
    Файлы разделены на страницы (блоки). Страница по умолчанию имеет размер 8Кб. Изменение размера блока (--with-blocksize) -- только при сборке (16Кб или 32Кб). Собранный и запущенный кластер может работать со страницами только одного размера 

    Табличные данные на страницах файла хранятся неупорядоченно -- куча (HEAP). Записи (Tuple) кучи идентифицируются с помощью TID -- tuple id. TID состоит из номера файла, номера блока в файле и позиции строки внутри блока 

    Для получения доступа к записям используется система указателей, размещаемых в начале страниц. Указатели имеют фиксированный размер (4 байта). Наличие указателей позволяет перемещать строку внутри страницы, не ломая индексные ссылки.

    Кортеж идентифицируется внутренним идентификатором кортежа (TID): номер страницы, номер указателя строки 
\end{nota}

\begin{nota}{Структура страницы}
    Страница разделена на области. Границы областей страницы записаны в ее заголовке:

    \begin{itemize}
        \item 0 -- начало заголовка страницы 
        \item 24 -- начало указателей на версии строк 
        \item lower -- начало свободного места 
        \item upper -- начало данных (версий строк)
        \item special -- начало специальных данных (только для индексов)
        \item pagesize -- конец страницы
    \end{itemize}
\end{nota}

\begin{nota}{Структура версии строки}
    Все версии строк таблицы имеют одинаковую структуру: 

    \begin{itemize}
        \item Заголовок фиксированного размера -- 23 байта 
        \item Необязательная битовая карта пустых (NULL) значений 
        \item Необязательное поле идентификатора объекта 
        \item Пользовательские данные 
    \end{itemize}

    Заголовок содержит служебну информация:

    \begin{itemize}
        \item t\_xmin -- идентификатор транзакции (XID), создавшей кортеж 
        \item t\_xmax -- идентификатор транзакции, удалившей кортеж
        \item t\_cid -- идентификатор команды внутри транзакции (CID), создавшей и/или удалившей кортеж 
        \item infomask -- набор служебных битов (флагов), определяющих свойства версии 
        \item ctid -- внутренний казатель на более новую версию кортежа. У самой новой (актуальной) версии строки citd ссылается на саму эту версию 
    \end{itemize}
\end{nota}

\begin{nota}{Инспектирование страиц}
    Для получения информаици о структуре и содержании страниц используется стандартное расширение pageinspect

    При установке расширения становятся доступны функции, позволяющие исследовать страницы баз данных на низком уровне:

    \begin{itemize}
        \item get\_raw\_page(relname text, blkno int) -- возвращает содержимое указанной страницы из основного слоя в bytea 
        \item page\_header(page bytea) -- возвращает набор полей заголовка указанной страницы 
        \item heap\_page\_items(page bytea) -- возвращает кортежи, их заголовки и содержимое ItemIdData указанной страницы 
        \item page\_checksum(page bytea, blkno int4) -- возвращает контрольную сумму указанной страницы 
    \end{itemize}
\end{nota}

\begin{nota}{Просмотр содержимого заголовка}
    Получение информации из заголовка нулевой страницы из таблицы pg\_class 

    Получение контрольной суммы 0-й страницы, которая должна была бы находиться в заданном блоке 
\end{nota}

\begin{nota}{Служебные слои}
    Карта свободного пространства (fsm) -- free space map 

    \begin{itemize}
        \item Хранит информацию об объеме свободного места на страницах после очистки 
        \item Используется при вставке новых версий строк 
        \item Имена файлов имеют окончание \_fsm -- relfilenode\_fsm, relfilenode\_fsm.1
        \item Существует для всех объектов
    \end{itemize}
\end{nota}

\begin{nota}{Служебные слои}
    Карта видимости (vm) -- битовая карта видимости. Появляется только после выполнения очистки. Отмечает чистые страницы, на которых все версии строк видны во всех снимках. Существует только для таблиц 

    Используется для оптимизации работы процесса очисти (отмеченные страницы не нуждаются в очистке); ускорения индексного доступа 

    Имена файлов имеют окончание \_vm -- relfilenode\_vm. Начиная с версии 9.6 в этом же слое хранится и карта заморозки
\end{nota}

\newpage 

\subsection{Хранение больших данных}

\begin{nota}{Хранение длинных строк}
    Физический размер одной записи не может занимать больше одной страницы данных 

    Для длинных версий строк, размер которых превышает 2Кб, автоматически применяется технология TOAST -- The Oversize Attributes Storage Technique: PostgreSQL сжимает и/или разбивает на несколько физических строк и выносит значения поля за пределы таблицы. Это происходит незаметно для пользователя и на большую часть кода сервера влияет незначительно 

    Для каждой таблицы с потенциально большими полями автоматически создается отдельная TOAST-таблица (и к ней специальный индекс)
\end{nota}

\begin{nota}{TOAST-таблица}
    Каждая TOAST-таблица содержит разделенные на части (chunk) длинные атрибуты записи основной таблицы. Запись в основной таблице будет содержать указатель (chunk\_id), указывающий на нужный фрагмент в TOAST-таблице. Одному chunk\_id может соответствовать несколько строк TOAST-таблице 

    TOAST-таблица состоит из 3 столбцов:

    \begin{itemize}
        \item chunk\_id -- номер чанка, на который ссылается куча 
        \item chunk\_seq -- номер кжадого сегмента чанка 
        \item chunk\_data -- часть данных каждого сегмента 
    \end{itemize}

    TOAST-таблица читается только при обращении к длинному атрибуту. Собственная версионность: если обновление данных не затрагивает длинное значение, новая версия строки будет ссылаться на то же самое значение в TOAST-таблице

    TOAST-таблица для базовой таблицы -- в схеме pg\_toast, для временной -- в схеме pg\_toast\_temp
\end{nota}

\begin{nota}{Параметры TOAST}
    КОд обработки TOAST срабатывает, когда размер записи превышает toast\_tuple\_threshold байт (по умолчанию 2Кб)

    Параметр toast\_tuple\_target указывает до какого размера в байтах TOAST должен пытаться сжать запись (по умолчанию 2Кб). Значение данного параметра можно переопределить на уровне таблицы 

    Ни toast\_tuple\_threshold, ни toast\_tuple\_target не являются жестким ограничением на максимальный размер кортежа 
\end{nota}

\begin{nota}{Стратегия обработки больших данных}
    Атрибут STORAGE столбца таблицы определяет стратегию обработки:

    \begin{itemize}
        \item plain -- TOAST не применяется (тип имеет фиксированную длину)
        \item main -- приоритет сжатия. Отдельное хранение -- как крайняя мера 
        \item extended -- допускается как сжатие, так и отдельное хранение 
        \item external -- только отдельное хранение без сжатия. Этот режим можно использовать для повышения производительности (избегая сжатия/распаковки) за счет более высокого потребления дискового пространства
    \end{itemize}
\end{nota}

\begin{nota}{TOAST-able типы данных}
    Стратегия хранения конкретного типа данных определяет стратегию обработки 

    Информаиця о типе данных и его характеристики хранится в таблице pg\_catalog.pg\_type 

    Стратегии хранения:

    \begin{itemize}
        \item p = PLAIN 
        \item x = EXTENDED 
        \item e = EXTERNAL (по умолчанию эта стратегия не используется ни для каких типов данных)
        \item m = MAIN
    \end{itemize}
\end{nota}

\begin{nota}{TOAST}
    PostgreSQL стремится к тому, чтобы на странице помещалось хотя бы 4 строки 

    Если размер строки превышает $\frac{1}{4}$ страницы с учетом заголовка, к части значений необходимо применить TOAST: 

    \begin{enumerate}
        \item Анализ атрибутов со стратегиями external и extended 
        
        \begin{itemize}
            \item Extended-атрибуты пытается сжать и, если занчение превосходит $\frac{1}{4}$ страницы, оно отправляется в TOAST-таблицу 
            \item External-атрибуты обрабатываются так же, но не сжимаются 
        \end{itemize}

        \item Если это не помогло, осуществляется попытка сжать атрибуты со стратегией main, оставив их на табличной странице 
        \item Если строка все равно недостаточно коротка, main-атрибуты отправляются в TOAST-таблицу
    \end{enumerate}
\end{nota}

\begin{Remark}{Особенность}
    Если при определении столбцов таблицы PostgreSQL видит, что размер строки не может превысить TOAST\_TUPLE\_THRESHOLD, TOAST-таблица не создается 

    Если вы смените тип какого-либо столбца, в результате чего размер записи увеличится -- будет создана TOAST-таблица 

    Если снова сменить тип -- СУБД удалит TOAST-таблицу 
\end{Remark}

\begin{nota}{Алгоритмы сжатия}
    Для сжатия строк поддерживается два алгоритма:

    \begin{itemize}
        \item PGLZ -- используется по умолчанию 
        \item LZ4 -- доступен, если PostgreSQL был собран с флагом --with-lz4
    \end{itemize}

    LZ4 сжимает данные хуже других алгоритмов, но он очень быстрый 

    Особенность PGLZ -- если ему не удается сжать первые 1024 байта входных даннхы, алгоритм сдается и гвоорит, что эти данные несжимаемые. Если у вас какие-то особые данные, первые байты которых плохо сжимаются, иметь смысл дописать к ним в начале нулевых байт 
\end{nota}

\newpage

\subsection{Планировщик запросов}

\begin{defin}{Планировщик запросов}
    В PostgreSQL используется планировщик запросов, основанный на стоимости 

    Основная задача -- построение плана выполнения запроса с наименьшей оценочной стоимостью выполнения 

    \begin{itemize}
        \item Объем ресурсов ОП 
        \item Объем ресурсов ЦП
        \item Для приложений работающих с OLTP БД скорость выполнения запроса не должна превышать десятки миллисекунд (в худшем случае сотни миллисекунд)
    \end{itemize}

    Планировщик при построении плана выполнения запроса:

    \begin{itemize}
        \item Использу статистические данные оценивает селективность предикатов 
        \item Выполняет анализ различных методов доступа к данным 
        \item Для многотабличных запросов выполняет анализ способов соединений наборов записей 
    \end{itemize}
\end{defin}

\begin{nota}{Селективность предикатов}
    Предикаты -- выражения, которые оцениваются как истинные или ложные. Используются в предложениях JOIN, WHERE, HAVING 

    Избирательность (селективность) предикатов 

    \begin{itemize}
        \item Процент строк таблицы, соответствующих предикату 
        \item Высокая избирательность = низкий процент возвращаемых строк 
        \item Низкая избирательность = высокий процент возвращаемых строк
    \end{itemize}

    Селективность при оптимизации запросов используется для выбора метода доступа к данным и операций соединения в многотабличных запросах 
\end{nota}

\begin{defin}{EXPLAIN}
    Чтобы узнать, какой план был выбран планировщиком для запроса, используется команда EXPLAIN 

    EXLAIN query 

    \begin{itemize}
        \item Позволяет посмотреть на план выполнения без фактического выполнения запроса (оценочный план)
        \item cost -- сумма затрат на работу с диском (чтение/запись) и оценка CPU: первое значение -- затраты на получение первой строки; второе -- затраты на получение всех строк
        \item rows -- приблизительное количество возвращаемых строк 
        \item width -- средний размер одной строки в байтах 
    \end{itemize}

    EXPLAIN (ANALYZE) query 

    \begin{itemize}
        \item Фактически выполняет запрос и отображает результат, полученный на реальных данных 
        \item actual time -- реальное время в миллисекундах, затраченное для получения первой строки и всех строк соответственно 
        \item rows -- реальное количество полученных строк 
        \item loops -- сколько раз пришлось выполнить операцию 
        \item Execution Time -- общее время выполнения запроса 
    \end{itemize}

    EXPLAIN (ANALYZE, BUFFERS) query 

    \begin{itemize}
        \item Позволяет посмотреть что происходит на физическом уровне при выполнении запроса 
        \item Buffers: shared read -- количество блоков, считанное с диска 
        \item Buffers: shared hit -- количество блоков, считанных из кэша PostgreSQL
        \item Объем кэша определяется параметром shared\_buffers
        \item Sort Method: external merge Disk -- при сортировке используется временный файл на диске 
        \item Sort Method: quicksort memory -- сортировка целиков проведена в оперативной памяти 
    \end{itemize}

    EXPLAIN (SETTINGS) query 

    \begin{itemize}
        \item Добавляет в выходные данные EXPLAIN параметры конфигурации, отличные от параметров по умолчанию (которые плияют на планирование запросов)
        \item Добавлен в PostgreSQL v12 (2019) и по умолчанию отключен 
    \end{itemize}
\end{defin}

\newpage 

\subsection{Методы доступа к данным}

\begin{nota}{Методы доступа к данным}
    Метод доступа характеризует способ, используемый для прсомотра таблиц с целью извлечения только тех записей, которые соответствуют условиям запроса 

    \begin{itemize}
        \item Последовательное сканирование (Seq Scan) (без использования индекса)
        \item Индексное сканирование (Index Scan)
        \item Сканирование битовой карты (Bitmap Scan)
        \item Исключительно индексное сканирование (Index Only Scan)
    \end{itemize}
\end{nota}

\begin{nota}{Доступ к данным в куче}
    При выполнении запроса к данным в куче выполняется последовательное сканирование таблицы целиков. Полностью читаются файлы основного слоя таблицы. На каждой прочитанной странице: 

    \begin{itemize}
        \item Проверяется видимость каждой версии строки
        \item Версии, не удовлетворяющие условиям запроса, отбрасывается
    \end{itemize}

    Чтение происходит через буферный кеш. При последовательном сканировании больших таблиц используется буферное кольцо небольшого размера:

    \begin{itemize}
        \item Несколько процессов, одновременно сканирующих таблицу, могут присоединяться к кольцу и тем самым экономить дисковые чтения 
        \item Поэтому в общем случае сканирование может начаться не с начала файла 
    \end{itemize}
\end{nota}

\begin{defin}{Последовательное сканирование}
    Последовательное сканирование -- самый эффективный способ прочитать всю таблицу или значительную ее часть. Хорошо работает при низкой селективности запроса. Последовательное чтение выполняется быстрее, чем чтение страниц вразнобой. Это особенно верно для жестких дисков, где механическая операция подведения головки к дорожке занимает существенно больше времени, чем само чтение данных; в случае дисков SSD этот эффект менее выражен 

    Для поиска поднабора записей данный метод малоэффективен 

    Решение: нужно создать индекс
\end{defin}

\begin{defin}{Что такое индексы?}
    Индексы в PostgreSQL -- специальные объекты базы данных, предназначенные в основном для ускорения доступа к данным. Это вспомогательные структуры, сохраняемые в отдельных файлах. Их можно удалить и восстановить заново по информации в таблице. Индексы также служат для поддержки некоторых ограничений целостности

    Индекс устанавливает соответствие между ключом индекса (значением проиндексированного столбца) и TID записей, в которых это значение встречается. С помощью ключа можно быстро найти интересующие нас строки, без необходимости полного сканирования всей таблицы. Индекс, созданный по столбцу, участвующему в соединении двух таблиц, может позволить ускорить процесс выборки записей из таблиц
\end{defin}

\begin{Remark}{Издержки}
    Замедление операций модификации данных в таблицах
    
    \begin{itemize}
        \item При выполнении операций модификации над проиндексированными данными индексы должны быть перестроены в рамках той же транзакции
        \item Обновление полей таблицы, не входящих в состав ключа индекса, не приводит к перестроению индексов -- HOT (Heap-Only Tuple)
        \item Чем больше смещение профиля нагрузки в сторону увеличения записей по отношению к чтению, тем это более критично 
    \end{itemize} 

    Дополнительные объемы дискового пространства

    \begin{itemize}
        \item Размер совокупных индексных данных не должен превышать 0,5 размера таблицы 
    \end{itemize}

    Усложненное техническое обслуживание 

    \begin{itemize}
        \item Добавление новых версий строк при модификации данных -- Vacuum решает задачу для основных записей, но не для индексных 
        \item Индексы могут распухать (BLOAD) на часто изменяемых данных и их необходимо пересоздавать. Это требует тонкой работы, чтобы не устроить даун-тайм для всего сервиса 
    \end{itemize}

    Поддержкой индексов в актуальном состоянии занимается СУБД -- тратя ресурсы 
\end{Remark}

\begin{defin}{Индексное сканирование (Index scan)}
    Индексное сканирование (Index Scan) 

    \begin{itemize}
        \item На основе ключа индекса определяется TID 
        \item Происходит обращение к странице таблицы, на которую указывает TID, для получения версии строки 
        \item Проверяется ее видимость в соответствии с правилами многоверсионности, и возвращаются полученные данные 
        \item Процесс повторяется для каждого TID 
    \end{itemize}

    Индексное сканирование хорошо работает, если версии строк в таблице коррелированы с порядком, в котором метод доступа выдает идентификаторы 

    Используется:

    \begin{itemize}
        \item Для быстрого поиска по ключу 
        \item Для выдачи остортированного результата в том случае, когда порядок сортировки запроса совпдаает с порядком сортировки индексных записей 
        \item Для получения данных, которые присутствуют в индексе без обращения к таблице 
    \end{itemize}
\end{defin}

\begin{defin}{Bitmap Scan}
    При увеличении выборки возрастают шансы, что придется возвращаться к одной и той же табличной странице несколько раз 

    Сканирование битовой карты 

    \begin{itemize}
        \item Возвращаются все TID, соответствующие условию (узел Bitmap Index Scan)
        \item По ним строится битовая карта версий строк (exact)
        \item Затем версии строк читаются из таблицы (узел Bitmap Heap Scan) -- при этом каждая страница будет прочитана только один раз 
    \end{itemize}

    Размер битовой карты не может превышать размер work\_mem. Если выборка слишком велика -- строится грубая битовая карта страниц (lossy), содержащих хотя бы одну подходящую версию строки. Для создания более точной битовой карты -- увеличить размер work\_mem. При чтении страницы приходится перепроверять условия для каждой хранящеймя там строки (узел Recheck Cond)

    При выполнении фильтрации по нескольким проиндексированным полям таблицы, сканирование битовой карты позволяет (если оптимизатор сочтет это выгодным) использовать несколько индексов одновременно:

    \begin{itemize}
        \item Для каждого индекса строятся битовые карты версий строк 
        \item Если выражения соединены условием AND -- битовые карты логически побитово умножаются 
        \item Если выражения соединены условием OR -- битовые карты логически побитово складываются
    \end{itemize}
\end{defin}

\begin{defin}{Index Only Scan}
    Если все необходимые для запроса данныые находятся на индексных страницах, такой индекс называется покрывающим (covering). В этом случае оптимизатор может применить исключительно индексное сканирование (Index Only Scan)

    Для прокешированных данных результаты практически не отличаются от Index Scan 

    Индексы в PostgreSQL не содержат информации, позволяющей судить о видимости строк 

    \begin{itemize}
        \item Метод доступа возвращает все версии строк, попадающие под условие поиска, независимо от того, видны они текущей транзакции или нет 
        \item Если страница, на которую указывает TID отмечена в карте видимости -- видимость не проверяется 
        \item Если страница, на которую указывает TID, не отмечена в карте видимости выполняется проверка видимости строки на основании табличных данных 
    \end{itemize}

    Требуется регулярное выполнение очистки VACUUM. Оптимизатор учитывает число мертвых строк и может отказаться от использования исключительно индексного сканирования. Число вынужденных обращений к таблице (Heap Fetches) можно узнать, используя команду explain analyze 
\end{defin}

\begin{defin}{Parallel Index Scan}
    Индексный доступ может выполняться в параллельном режиме:

    \begin{itemize}
        \item Сначала ведущий процесс (gather) спускается от корня дерева к листовой странице 
        \item Затем рабочие процессы (parallel\_workers) выполняют параллельное чтение листовых страниц индекса, двигаясь по указателям 
    \end{itemize}

    Издержки:

    \begin{itemize}
        \item Процесс, прочитавший индексную страницу, выполняет и чтение необходимых табличных страниц 
        \item Если несколько индексных страниц, прочитанных разными процессами, содержат ссылку на одну и ту же табличную страницу -- ее прочитают несколько процессов (страница будет находиться в буферном кеше в одном экземпляре)
    \end{itemize}
\end{defin}

\begin{nota}{Число рабочих процессов}
    Равно нулю (параллельный план не строится), если размер выборки < min\_parallel\_index\_scan\_size (=512kB)

    Фиксировано, если для таблицы указан параметр хранения parallel\_workers

    Вычисляется по формуле 1 + [log 3 (размер выборки / min\_parallel\_index\_scan\_size)], но не больше, чем max\_parallel\_workers\_per\_gather
\end{nota}

\begin{nota}{Сранвения стоимости методов доступа}
    Каждый из методов доступа имеет свои преимущества и недостатки:

    \begin{itemize}
        \item Индексное сканирование зависит от корреляции между физически расположением версий строк и порядком, в котором индексный метод доступа выдает идентификаторы
        \item Сканирование только индекса сильно зависит от карты видимости 
        \item Сканирование по битовой карте при слабой корреляции существенно превосходит индексное сканирование 
        \item Последовательное сканирование не зависит от селективности и, начиная с некоторой доли выбираемых строк, обычно работает лучше остальных методов 
    \end{itemize}

    Планировщик выполняет серьезную работу по оценке эффективности каждого из методов в каждом конкретном случае. Чтобы эти оценки были близки к реальности, очень важна актуальная статистика 
\end{nota}

\begin{nota}{Параметры сервера}
    \begin{itemize}
        \item seq\_page\_cost (floating point) -- стоимость получения страницы при последовательном чтении. По умолчанию 1.0
        \item random\_page\_cost -- стоимость получения случайной страницы. По умолчанию 4.0
        \item Оба параметра могут быть изменены для tablespace (SSD) или когда данные целиком умещаются в памяти. Таким образом, можно для активной части базы в памяти иметь random\_page\_cost близкий к единице, а для архивных данных -- оставить значение по умолчанию 
        \item cpu\_tuple\_cost -- стоимость получения страницы данных из памяти. По умолчанию 0.01
        \item cpu\_index\_tuple\_cost -- то же самое, только для индекса. По умолчанию 0.005
        \item cpu\_operator\_cost -- стоимость обработки оператора или функции. По умолчанию 0.0025
    \end{itemize}

    Значение параметра effective\_cache\_size не влияет на выделение памяти, но подсказывает PostgreSQL, на какой общий размер кэша рассчитывать, включая кэш операционной системы. Чем выше это значение, тем большее предпочтение отдается индексам. Начать можно с 50-75\% от объема ОЗУ

    Параметры, включающие или отключающие использование планировщиком запросов соответствующих методов доступа:

    \begin{itemize}
        \item enable\_seqscan 
        \item enable\_indexscan
        \item enable\_indexonlyscan
        \item enable\_bitmapscan
    \end{itemize}

    Значение по умолчанию -- on. Если off -- препятствует планировщику использовать соответствующий метод доступа, если есть другие доступные методы 
\end{nota}

\newpage 

\subsection{Способы соединения}

\begin{nota}{Соединения}
    Очень часто запросы обращаются к данным из нескольких таблиц:

    \begin{itemize}
        \item Недостаточно получать данные с помощью соответствующих методов доступа 
        \item Необходимо соединять два и более наборов строк 
        \item Проверять наличие связных записей в соединяемых наборах 
    \end{itemize}

    При написании запроса используются логические операции соединения таблиц (JOIN и их производные). Выбор типа логической операции зависит от решаемой задачи. Порядок соединения таблиц не важен с точки зрения логики запроса

    Для реализации соединения таблиц PostgreSQL использует способы соединения наборов записей, учитывающие вопросы производительности. Наборы записей всегда соединяются попарно. Порядок соединения наборов записей может влиять на производительность 
\end{nota}

\begin{nota}{Типы соединений наборов записей}
    \begin{itemize}
        \item Соединение вложенными циклами (Nested Loop)
        \item Соединение хешированием (Hash Join)
        \item Соединение слиянием (Merge Join)
    \end{itemize}
\end{nota}

\begin{defin}{Nested Loop}
    Реализован в виде двух вложенных циклов. Для каждой записи первого (внешнего -- outer) набора проверяется условие соединения во втором (внутреннем -- inner) наборе. Процесс повторяется до тех пор, пока внешний набор не исчерпает все строки. Обращение к записям второго (внутреннего) набора осуществляется столько раз, сколько записей в первом (внешнем) наборе. Если отсутствует эффективный метод доступа для поиска соответствующих записей во втором наборе (отсуттсвует индекс) эффективность сильно снизится, так как придется просматривать большое количество ненужных записей 

    Данный тип объединения оптимизатор обычно предпочитает для небольших выборок 

    Единственный способ для соединений не по =

    Подходит для OUTER JOIN, EXISTS, NOT EXISTS. задает порядок соединения 

    \begin{enumerate}
        \item Nested Loop Left Join -- возвращает строки, даже если для левого набора записей не нашлось соответствия в правом наборе записей (LEFT JOIN)
        \item Nested Loop Anti Join -- возвращает записи одного набора в том случае, если для них не нашлось соответствия в другом наборе (NOT EXISTS, LEFT|RIGHT JOIN ... WHERE поле IS NULL)
        \item Nested Loop Semi Join -- возвращает строки одного набора, если для них нашлось хотя бы одно соответствие в другом наборе (EXISTS) (т.е. достаточно получить всего одну строку)
    \end{enumerate}

    Модификаций алгоритма вложенного цикла для правого (RIGHT) и полного (FULL) соединений не существует. Это связано с тем, что полный проход по второму набору строк может не выполняться 

    Соединение вложенным циклом может использоваться вв параллельных планах
\end{defin}

\begin{defin}{Соединение с индексированным вложенным циклом}
    Если для внутренней таблицы существует индекс, который может ускорить поиск записей, удовлетворяющих условию соединения, планировщик рассматривает возможность использования этого индекса для прямого поиска записей внутренней таблицы вместо последовательного сканирования -- indexed nested loop join 

    Если есть индекс внешней таблицы и его атрибуты участвуют в условии соединения, то его можно использовать для сканирования индекса вместо последовательного сканирования внешней таблицы. В частности, при наличии индекса, атрибутом которого может быть предикат доступа в предложении WHERE, диапазон поиска во внешней таблице сужается; следовательно, стоимость соединения с вложенным циклом может быть значительно снижена 
\end{defin}

\begin{defin}{Hash join}
    Реализация:

    \begin{itemize}
        \item По одному набору записей строится хеш-таблица на ключах соединения (узел Hash). Функция хеширования равномерно распределяет значения по ограниченному числу корзин хеш-таблицы -- по значению хеш-функции определяется номер корзины. Если равномерности не будет -- в одной корзине может образоваться список значений, что приведет к снижению производительности 
        \item Затем Postgres выполняет итерацию по второму набору записей: 
        
        \begin{itemize}
            \item Вычисляет хеш-функцию от значения полей, участвующих в условии соединения 
            \item Проверяет наличие соответствующего хеш-значения в хеш-таблице hash(table1.val)=hash(table2.val)
            \item Дополнительно проверяет значения полей, подходящие под условие соединения 
        \end{itemize}
    \end{itemize}

    Используется для соединений по =

    Для большой выборки оптимизатор предпочитает соединение хешированием. Зависит от порядка соединения -- внутренний набор должен быть меньше внешнего, чтобы минимизировать хеш-таблицу 

    Размер хеш-таблицы в памяти ограничен значением work\_mem x hash\_mem\_multiplier (начиная с 13 версии). В корзину помещаются хеш-код и все поля, которые входят в условие соединения или используются в запросе. Не следует использовать в запросе лишние поля, в том числе звездочку

    Если таблица не умещается в памяти:

    \begin{enumerate}
        \item Разбивает наборы записей на пакеты (Batches)
        \item Строит хеш-таблицу для одного пакета (work\_mem x hash\_mem\_multiplier)
        \item Остальные пакеты сохраняет во временные файлы (temp written)
        \item Выполняет сопоставление с записями второго набора 
        \item Если запись соответствует данному пакету -- она возвращается. Если строка принадлежит другому пакету, она сбрасывается на диск -- в свой временный файл
        \item Процедура повторяется для всех пакетов 
    \end{enumerate}
\end{defin}

\begin{nota}{Группировка и уникальные значения}
    Для выполнения группировки (GROUP BY) и устранения дубликатов (DISTINCT и операции со множествами без ALL) используются методы, схожие с методами соединения: один из способов выполнения состоит в том, чтобы построить хеш-таблицу по нужным полям и получить из нее уникальные значения
\end{nota}

\begin{defin}{Merge join}
    Для использования данного способа основным условием является соединение упорядоченных наборов записей

    \begin{itemize}
        \item Если наборы записей не отсортированы -- выполняет сортировку (дорогая операция)
        \item Сначала берет первые записи обоих наборов и сравнивает их между собой 
        \item Если значения совпадают -- читает следующую строку второго набора 
        \item Если значения не совпадают -- читает следующую строку того набора, для которого значение поля, по которому происходит соединение, меньше (один набор догоняет другой)
        \item Главное отличие -- нет правого и левого набора записей 
    \end{itemize}

    Алгоритм слияния возвращает результат соединения в отсортированном виде. ПОлученный набор записей может быть использован для соединения слиянием со следующим набором записей без дополнительной сортировки

    Подходит для outer join-ов. Не определяет жестко порядок соединения таблиц. Чуть ли не единственный способ реализовать full outer join 

    Если соединяемые наборы записей уже остортированы (например определны индексы) PostgreSQL может предпочесть данный способ соединению хешированием. Не требуются накладные расходы на простроение хеш-таблицы 

    Если требуется выполнение сортировки, то в зависимости от количества записей и объема work\_mem 

    \begin{itemize}
        \item Может быть выполнена быстрая сортировка (quick sort)
        \item Может быть применена частичная пирамидальная сортировка (top-N heapsort) если нужно отсортировать не весь набор данных (LIMIT)
        \item Если данные уже отсортированы, но не по всем ключам, может быть использована инкрементальная сортировка 
        \item Либо может быть отдано предпочтение соединению хешированием 
    \end{itemize}
\end{defin}

\begin{Remark}{Другие варианты}
    Подобно объединению с вложенным циклом, соединение слиянием в PostgreSQL fnкже имеет варианты, на основе которых может выполняться сканирование индекса внешней таблицы 
\end{Remark}

\begin{nota}{Параметры сервера связанные со способами объединения}
    Параметры, включающие или отключающие использование планировщиком запросов соответствующих способов объединения:

    \begin{itemize}
        \item enable\_nestloop
        \item enable\_hashjoin
        \item enable\_mergejoin
    \end{itemize}

    Значение по умолчанию -- on. Если off -- препятствует планировщику использовать соответствующий способ объединения, если есть другие доступные способы
\end{nota}

\newpage

\section{Лекция 3. Запросы к нескольким таблицам}

\subsection{Запросы к нескольким таблицам}

\begin{defin}{Предложение FROM}
    В предложении FROM перечисляются один или несколько источников данных, используемых для формирования результирующей выборки 

    При использовании нескольких источников необходимо указать тип их соединения:

    \begin{itemize}
        \item CROSS JOIN 
        \item\ [ INNER ] JOIN 
        \item LEFT [ OUTER ] JOIN
        \item RIGHT [ OUTER ] JOIN
        \item FULL [ OUTER ] JOIN
        \item NATURAL JOIN 
        \item USING
    \end{itemize}
\end{defin}

\begin{defin}{CROSS JOIN -- перекрестное соединение}
    CROSS JOIN -- возвращает декартово произведение таблиц. Может быть заменено списком таблиц через запятую в разделе FROM

\begin{lstlisting}
FROM tableA CROSS JOIN tableB
\end{lstlisting}
\end{defin}

\begin{nota}{Соединение посредством предиката}
\begin{lstlisting}
FROM tableA [type_of_join] JOIN tableB ON predicate
\end{lstlisting}

    \begin{center}
        \begin{tabular}{|m{9em}|m{29em}|}
            \hline 
            Тип соединения & Описание \\ 
            \hline
            INNER & Используется для соединения строк из обеих таблиц на основе заданного предиката. Используется по умолчанию, когда тип соединения явно не задан \\
            \hline 
            LEFT [ OUTER ] & "Левое (внешнее)"\ Включает в себя все строки из левой таблицы A и те строки из правой таблицы B, для которых выполняется условие предиката. Для строк из таблицы A, для которых не найдено соответствия в таблице B, в столбцы, извлекаемые из таблицы B, заносятся значения NULL \\
            \hline 
            RIGHT [ OUTER ] & "Правое (внешнее)"\ Включает в себя все строки из правой таблицы B и те строки из левой таблицы A, для которых выполняется условие предиката. Для строк из таблицы B, для которых не найдено соответствия в таблице A, в столбцы, извлекаемые из таблицы A, заносятся значения NULL \\
            \hline
            FULL [ OUTER ] & "Полное (внешнее)"\ Это комбинация левого и правого соединений. В полное соединение включаются все строки из обеих таблиц. Для совпадающих строк поля заполняются реальными значениями, для несовпадающих строк поля заполняются в соответствии с правилами левого и правого соединений \\
            \hline
        \end{tabular}
    \end{center}
\end{nota}

\begin{Remark}{}
    Вместо ON можно использовать USING при условии совпадения названий столбцов, используемых для соединения
\end{Remark}

\begin{defin}{SELF JOIN}
    Для объединения записей внутри одной таблицы необходимо использовать объединение таблицы со своей копией. Для создания копии используются псевдонимы таблиц
\end{defin}

\newpage 

\subsection{Использование операторов наборов записей}

\begin{nota}{Требования к наборам записей}
    Оба набора должны иметь одинаковое количество столбцов, совместивых по типу данных 

    ORDER BY не допускается во входных запросах, но может использоваться для сортировки результирующего набора 

    NULL значения считаются равными при сравнении наборов
\end{nota}

\begin{defin}{UNION и UNION ALL}
    UNION возвращает результирующий набор уникальных строк, объединенных из двух входных наборов. Дубликаты удаляются при обработке запроса (влияет на производительность) 

    UNION ALL возвращает результирующий набор со всеми строками из двух входных наборов. Чтобы избежать потери производительности, вызванной фильтрацией дубликатов, используйте UNION ALL вместо UNION всякий раз, когда это позволяют требования
\end{defin}

\begin{defin}{INTERSECT}
    INTERSECT возвращает уникальный результирующий набор строк, которые присутствуют в обоих входных наборах
\end{defin}

\begin{defin}{EXCEPT (MINUS)}
    EXCEPT возвращает только уникальные строки, которые присутствуют в левом наборе, но нет в правом. Порядок, в котором указаны наборы, имеет значение
\end{defin}

\end{document}